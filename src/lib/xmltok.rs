// =============== BEGIN xmltok_h ================
/*
                        __  __            _
                     ___\ \/ /_ __   __ _| |_
                    / _ \\  /| '_ \ / _` | __|
                   |  __//  \| |_) | (_| | |_
                    \___/_/\_\ .__/ \__,_|\__|
                             |_| XML parser

   Copyright (c) 1997-2000 Thai Open Source Software Center Ltd
   Copyright (c) 2000-2017 Expat development team
   Licensed under the MIT license:

   Permission is  hereby granted,  free of charge,  to any  person obtaining
   a  copy  of  this  software   and  associated  documentation  files  (the
   "Software"),  to  deal in  the  Software  without restriction,  including
   without  limitation the  rights  to use,  copy,  modify, merge,  publish,
   distribute, sublicense, and/or sell copies of the Software, and to permit
   persons  to whom  the Software  is  furnished to  do so,  subject to  the
   following conditions:

   The above copyright  notice and this permission notice  shall be included
   in all copies or substantial portions of the Software.

   THE  SOFTWARE  IS  PROVIDED  "AS  IS",  WITHOUT  WARRANTY  OF  ANY  KIND,
   EXPRESS  OR IMPLIED,  INCLUDING  BUT  NOT LIMITED  TO  THE WARRANTIES  OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
   NO EVENT SHALL THE AUTHORS OR  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
   DAMAGES OR  OTHER LIABILITY, WHETHER  IN AN  ACTION OF CONTRACT,  TORT OR
   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
   USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

/* The following token may be returned by XmlContentTok */
pub const XML_TOK_TRAILING_RSQB: libc::c_int = -5; /* ] or ]] at the end of the scan; might be
                                                   start of illegal ]]> sequence */

/* The following tokens may be returned by both XmlPrologTok and
   XmlContentTok.
*/
pub const XML_TOK_NONE: libc::c_int = -4; /* The string to be scanned is empty */
pub const XML_TOK_TRAILING_CR: libc::c_int = -3; /* A CR at the end of the scan;
                                                  * might be part of CRLF sequence */
pub const XML_TOK_PARTIAL_CHAR: libc::c_int = -2; /* only part of a multibyte sequence */
pub const XML_TOK_PARTIAL: libc::c_int = -1; /* only part of a token */
pub const XML_TOK_INVALID: libc::c_int = 0;

/* The following tokens are returned by XmlContentTok; some are also
   returned by XmlAttributeValueTok, XmlEntityTok, XmlCdataSectionTok.
*/

pub const XML_TOK_START_TAG_WITH_ATTS: libc::c_int = 1;
pub const XML_TOK_START_TAG_NO_ATTS: libc::c_int = 2;
pub const XML_TOK_EMPTY_ELEMENT_WITH_ATTS: libc::c_int = 3; /* empty element tag <e/> */
pub const XML_TOK_EMPTY_ELEMENT_NO_ATTS: libc::c_int = 4;
pub const XML_TOK_END_TAG: libc::c_int = 5;
pub const XML_TOK_DATA_CHARS: libc::c_int = 6;
pub const XML_TOK_DATA_NEWLINE: libc::c_int = 7;
pub const XML_TOK_CDATA_SECT_OPEN: libc::c_int = 8;
pub const XML_TOK_ENTITY_REF: libc::c_int = 9;
pub const XML_TOK_CHAR_REF: libc::c_int = 10; /* numeric character reference */

/* The following tokens may be returned by both XmlPrologTok and
   XmlContentTok.
*/
pub const XML_TOK_PI: libc::c_int = 11; /* processing instruction */
pub const XML_TOK_XML_DECL: libc::c_int = 12; /* XML decl or text decl */
pub const XML_TOK_COMMENT: libc::c_int = 13;
pub const XML_TOK_BOM: libc::c_int = 14; /* Byte order mark */

/* The following tokens are returned only by XmlPrologTok */
pub const XML_TOK_PROLOG_S: libc::c_int = 15 as libc::c_int;
pub const XML_TOK_DECL_OPEN: libc::c_int = 16; /* <!foo */
pub const XML_TOK_DECL_CLOSE: libc::c_int = 17; /* > */
pub const XML_TOK_NAME: libc::c_int = 18;
pub const XML_TOK_NMTOKEN: libc::c_int = 19;
pub const XML_TOK_POUND_NAME: libc::c_int = 20; /* #name */
pub const XML_TOK_OR: libc::c_int = 21; /* | */
pub const XML_TOK_PERCENT: libc::c_int = 22;
pub const XML_TOK_OPEN_PAREN: libc::c_int = 23;
pub const XML_TOK_CLOSE_PAREN: libc::c_int = 24;
pub const XML_TOK_OPEN_BRACKET: libc::c_int = 25;
pub const XML_TOK_CLOSE_BRACKET: libc::c_int = 26;
pub const XML_TOK_LITERAL: libc::c_int = 27;
pub const XML_TOK_PARAM_ENTITY_REF: libc::c_int = 28;
pub const XML_TOK_INSTANCE_START: libc::c_int = 29;

/* The following occur only in element type declarations */
pub const XML_TOK_NAME_QUESTION: libc::c_int = 30; /* name? */
pub const XML_TOK_NAME_ASTERISK: libc::c_int = 31; /* name* */
pub const XML_TOK_NAME_PLUS: libc::c_int = 32; /* name+ */
pub const XML_TOK_COND_SECT_OPEN: libc::c_int = 33; /* <![ */
pub const XML_TOK_COND_SECT_CLOSE: libc::c_int = 34; /* ]]> */
pub const XML_TOK_CLOSE_PAREN_QUESTION: libc::c_int = 35; /* )? */
pub const XML_TOK_CLOSE_PAREN_ASTERISK: libc::c_int = 36; /* )* */
pub const XML_TOK_CLOSE_PAREN_PLUS: libc::c_int = 37; /* )+ */
pub const XML_TOK_COMMA: libc::c_int = 38;

/* The following token is returned only by XmlAttributeValueTok */
pub const XML_TOK_ATTRIBUTE_VALUE_S: libc::c_int = 39;

/* The following token is returned only by XmlCdataSectionTok */
pub const XML_TOK_CDATA_SECT_CLOSE: libc::c_int = 40;

/* With namespace processing this is returned by XmlPrologTok for a
   name with a colon.
*/
pub const XML_TOK_PREFIXED_NAME: libc::c_int = 41;
pub const XML_TOK_IGNORE_SECT: libc::c_int = 42;
pub const XML_PROLOG_STATE: libc::c_int = 0;
pub const XML_CONTENT_STATE: libc::c_int = 1;

/* The size of the buffer passed to XmlUtf8Encode must be at least this. */
pub const XML_UTF8_ENCODE_MAX: libc::c_int = 4;
/* The size of the buffer passed to XmlUtf16Encode must be at least this. */
pub const XML_UTF16_ENCODE_MAX: libc::c_int = 2;

pub type POSITION = crate::src::lib::xmltok::position;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct position {
    /* first line and first column are 0 not 1 */
    pub lineNumber: crate::expat_external_h::XML_Size,
    pub columnNumber: crate::expat_external_h::XML_Size,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ATTRIBUTE {
    pub name: *const libc::c_char,
    pub valuePtr: *const libc::c_char,
    pub valueEnd: *const libc::c_char,
    pub normalized: libc::c_char,
}

pub type ENCODING = crate::src::lib::xmltok::encoding;

pub type SCANNER = Option<
    unsafe extern "C" fn(
        _: *const crate::src::lib::xmltok::ENCODING,
        _: *const libc::c_char,
        _: *const libc::c_char,
        _: *mut *const libc::c_char,
    ) -> libc::c_int,
>;

pub type XML_Convert_Result = libc::c_uint;
pub const XML_CONVERT_COMPLETED: crate::src::lib::xmltok::XML_Convert_Result = 0;
pub const XML_CONVERT_INPUT_INCOMPLETE: crate::src::lib::xmltok::XML_Convert_Result = 1;
pub const XML_CONVERT_OUTPUT_EXHAUSTED: crate::src::lib::xmltok::XML_Convert_Result = 2; /* and therefore potentially input remaining as well */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct encoding {
    pub scanners: [crate::src::lib::xmltok::SCANNER; 4],
    pub literalScanners: [crate::src::lib::xmltok::SCANNER; 2],
    pub nameMatchesAscii: Option<
        unsafe extern "C" fn(
            _: *const crate::src::lib::xmltok::ENCODING,
            _: *const libc::c_char,
            _: *const libc::c_char,
            _: *const libc::c_char,
        ) -> libc::c_int,
    >,
    pub nameLength: Option<
        unsafe extern "C" fn(
            _: *const crate::src::lib::xmltok::ENCODING,
            _: *const libc::c_char,
        ) -> libc::c_int,
    >,
    pub skipS: Option<
        unsafe extern "C" fn(
            _: *const crate::src::lib::xmltok::ENCODING,
            _: *const libc::c_char,
        ) -> *const libc::c_char,
    >,
    pub getAtts: Option<
        unsafe extern "C" fn(
            _: *const crate::src::lib::xmltok::ENCODING,
            _: *const libc::c_char,
            _: libc::c_int,
            _: *mut crate::src::lib::xmltok::ATTRIBUTE,
        ) -> libc::c_int,
    >,
    pub charRefNumber: Option<
        unsafe extern "C" fn(
            _: *const crate::src::lib::xmltok::ENCODING,
            _: *const libc::c_char,
        ) -> libc::c_int,
    >,
    pub predefinedEntityName: Option<
        unsafe extern "C" fn(
            _: *const crate::src::lib::xmltok::ENCODING,
            _: *const libc::c_char,
            _: *const libc::c_char,
        ) -> libc::c_int,
    >,
    pub updatePosition: Option<
        unsafe extern "C" fn(
            _: *const crate::src::lib::xmltok::ENCODING,
            _: *const libc::c_char,
            _: *const libc::c_char,
            _: *mut crate::src::lib::xmltok::POSITION,
        ) -> (),
    >,
    pub isPublicId: Option<
        unsafe extern "C" fn(
            _: *const crate::src::lib::xmltok::ENCODING,
            _: *const libc::c_char,
            _: *const libc::c_char,
            _: *mut *const libc::c_char,
        ) -> libc::c_int,
    >,
    pub utf8Convert: Option<
        unsafe extern "C" fn(
            _: *const crate::src::lib::xmltok::ENCODING,
            _: *mut *const libc::c_char,
            _: *const libc::c_char,
            _: *mut *mut libc::c_char,
            _: *const libc::c_char,
        ) -> crate::src::lib::xmltok::XML_Convert_Result,
    >,
    pub utf16Convert: Option<
        unsafe extern "C" fn(
            _: *const crate::src::lib::xmltok::ENCODING,
            _: *mut *const libc::c_char,
            _: *const libc::c_char,
            _: *mut *mut libc::c_ushort,
            _: *const libc::c_ushort,
        ) -> crate::src::lib::xmltok::XML_Convert_Result,
    >,
    pub minBytesPerChar: libc::c_int,
    pub isUtf8: libc::c_char,
    pub isUtf16: libc::c_char,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct INIT_ENCODING {
    pub initEnc: crate::src::lib::xmltok::ENCODING,
    pub encPtr: *mut *const crate::src::lib::xmltok::ENCODING,
}

pub type CONVERTER =
    Option<unsafe extern "C" fn(_: *mut libc::c_void, _: *const libc::c_char) -> libc::c_int>;

// =============== END xmltok_h ================

pub mod xmltok_impl_c {

    /* vertical bar = "|" */
    /* This file is included!
                                __  __            _
                             ___\ \/ /_ __   __ _| |_
                            / _ \\  /| '_ \ / _` | __|
                           |  __//  \| |_) | (_| | |_
                            \___/_/\_\ .__/ \__,_|\__|
                                     |_| XML parser

       Copyright (c) 1997-2000 Thai Open Source Software Center Ltd
       Copyright (c) 2000-2017 Expat development team
       Licensed under the MIT license:

       Permission is  hereby granted,  free of charge,  to any  person obtaining
       a  copy  of  this  software   and  associated  documentation  files  (the
       "Software"),  to  deal in  the  Software  without restriction,  including
       without  limitation the  rights  to use,  copy,  modify, merge,  publish,
       distribute, sublicense, and/or sell copies of the Software, and to permit
       persons  to whom  the Software  is  furnished to  do so,  subject to  the
       following conditions:

       The above copyright  notice and this permission notice  shall be included
       in all copies or substantial portions of the Software.

       THE  SOFTWARE  IS  PROVIDED  "AS  IS",  WITHOUT  WARRANTY  OF  ANY  KIND,
       EXPRESS  OR IMPLIED,  INCLUDING  BUT  NOT LIMITED  TO  THE WARRANTIES  OF
       MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
       NO EVENT SHALL THE AUTHORS OR  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
       DAMAGES OR  OTHER LIABILITY, WHETHER  IN AN  ACTION OF CONTRACT,  TORT OR
       OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
       USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
    /* This file is included!
                                __  __            _
                             ___\ \/ /_ __   __ _| |_
                            / _ \\  /| '_ \ / _` | __|
                           |  __//  \| |_) | (_| | |_
                            \___/_/\_\ .__/ \__,_|\__|
                                     |_| XML parser

       Copyright (c) 1997-2000 Thai Open Source Software Center Ltd
       Copyright (c) 2000-2017 Expat development team
       Licensed under the MIT license:

       Permission is  hereby granted,  free of charge,  to any  person obtaining
       a  copy  of  this  software   and  associated  documentation  files  (the
       "Software"),  to  deal in  the  Software  without restriction,  including
       without  limitation the  rights  to use,  copy,  modify, merge,  publish,
       distribute, sublicense, and/or sell copies of the Software, and to permit
       persons  to whom  the Software  is  furnished to  do so,  subject to  the
       following conditions:

       The above copyright  notice and this permission notice  shall be included
       in all copies or substantial portions of the Software.

       THE  SOFTWARE  IS  PROVIDED  "AS  IS",  WITHOUT  WARRANTY  OF  ANY  KIND,
       EXPRESS  OR IMPLIED,  INCLUDING  BUT  NOT LIMITED  TO  THE WARRANTIES  OF
       MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
       NO EVENT SHALL THE AUTHORS OR  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
       DAMAGES OR  OTHER LIABILITY, WHETHER  IN AN  ACTION OF CONTRACT,  TORT OR
       OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
       USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
    /* This file is included!
                                __  __            _
                             ___\ \/ /_ __   __ _| |_
                            / _ \\  /| '_ \ / _` | __|
                           |  __//  \| |_) | (_| | |_
                            \___/_/\_\ .__/ \__,_|\__|
                                     |_| XML parser

       Copyright (c) 1997-2000 Thai Open Source Software Center Ltd
       Copyright (c) 2000-2017 Expat development team
       Licensed under the MIT license:

       Permission is  hereby granted,  free of charge,  to any  person obtaining
       a  copy  of  this  software   and  associated  documentation  files  (the
       "Software"),  to  deal in  the  Software  without restriction,  including
       without  limitation the  rights  to use,  copy,  modify, merge,  publish,
       distribute, sublicense, and/or sell copies of the Software, and to permit
       persons  to whom  the Software  is  furnished to  do so,  subject to  the
       following conditions:

       The above copyright  notice and this permission notice  shall be included
       in all copies or substantial portions of the Software.

       THE  SOFTWARE  IS  PROVIDED  "AS  IS",  WITHOUT  WARRANTY  OF  ANY  KIND,
       EXPRESS  OR IMPLIED,  INCLUDING  BUT  NOT LIMITED  TO  THE WARRANTIES  OF
       MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
       NO EVENT SHALL THE AUTHORS OR  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
       DAMAGES OR  OTHER LIABILITY, WHETHER  IN AN  ACTION OF CONTRACT,  TORT OR
       OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
       USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
    /* fall through */
    /* fall through */
    /* fall through */
    /* fall through */
    /* fall through */
    /* fall through */
    /* ptr points to character following "<!-" */
    /* ptr points to character following "<!-" */
    /* ptr points to character following "<!-" */

    pub unsafe extern "C" fn big2_scanComment(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        if end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            if !(*ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                && *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0x2d as libc::c_int)
            {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
            ptr = ptr.offset(2 as libc::c_int as isize);
            while end.wrapping_offset_from(ptr) as libc::c_long
                >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
            {
                match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                    (*(enc as *mut normal_encoding)).type_0
                        [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                        as libc::c_int
                } else {
                    unicode_byte_type(
                        *ptr.offset(0 as libc::c_int as isize),
                        *ptr.offset(1 as libc::c_int as isize),
                    )
                } {
                    5 => {
                        if (end.wrapping_offset_from(ptr) as libc::c_long)
                            < 2 as libc::c_int as libc::c_long
                        {
                            return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                        }
                        ptr = ptr.offset(2 as libc::c_int as isize)
                    }
                    6 => {
                        if (end.wrapping_offset_from(ptr) as libc::c_long)
                            < 3 as libc::c_int as libc::c_long
                        {
                            return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                        }
                        ptr = ptr.offset(3 as libc::c_int as isize)
                    }
                    7 => {
                        if (end.wrapping_offset_from(ptr) as libc::c_long)
                            < 4 as libc::c_int as libc::c_long
                        {
                            return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                        }
                        ptr = ptr.offset(4 as libc::c_int as isize)
                    }
                    0 | 1 | 8 => {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    27 => {
                        ptr = ptr.offset(2 as libc::c_int as isize);
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                        {
                            return crate::xmltok_h::XML_TOK_PARTIAL;
                        }
                        if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                            && *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                                == 0x2d as libc::c_int
                        {
                            ptr = ptr.offset(2 as libc::c_int as isize);
                            if !(end.wrapping_offset_from(ptr) as libc::c_long
                                >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                            {
                                return crate::xmltok_h::XML_TOK_PARTIAL;
                            }
                            if !(*ptr.offset(0 as libc::c_int as isize) as libc::c_int
                                == 0 as libc::c_int
                                && *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                                    == 0x3e as libc::c_int)
                            {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                            return crate::xmltok_h::XML_TOK_COMMENT;
                        }
                    }
                    _ => ptr = ptr.offset(2 as libc::c_int as isize),
                }
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }

    pub unsafe extern "C" fn little2_scanComment(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        if end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            if !(*ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                && *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0x2d as libc::c_int)
            {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
            ptr = ptr.offset(2 as libc::c_int as isize);
            while end.wrapping_offset_from(ptr) as libc::c_long
                >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
            {
                match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                    (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                        as libc::c_int
                } else {
                    unicode_byte_type(
                        *ptr.offset(1 as libc::c_int as isize),
                        *ptr.offset(0 as libc::c_int as isize),
                    )
                } {
                    5 => {
                        if (end.wrapping_offset_from(ptr) as libc::c_long)
                            < 2 as libc::c_int as libc::c_long
                        {
                            return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                        }
                        ptr = ptr.offset(2 as libc::c_int as isize)
                    }
                    6 => {
                        if (end.wrapping_offset_from(ptr) as libc::c_long)
                            < 3 as libc::c_int as libc::c_long
                        {
                            return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                        }
                        ptr = ptr.offset(3 as libc::c_int as isize)
                    }
                    7 => {
                        if (end.wrapping_offset_from(ptr) as libc::c_long)
                            < 4 as libc::c_int as libc::c_long
                        {
                            return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                        }
                        ptr = ptr.offset(4 as libc::c_int as isize)
                    }
                    0 | 1 | 8 => {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    27 => {
                        ptr = ptr.offset(2 as libc::c_int as isize);
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                        {
                            return crate::xmltok_h::XML_TOK_PARTIAL;
                        }
                        if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                            && *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                                == 0x2d as libc::c_int
                        {
                            ptr = ptr.offset(2 as libc::c_int as isize);
                            if !(end.wrapping_offset_from(ptr) as libc::c_long
                                >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                            {
                                return crate::xmltok_h::XML_TOK_PARTIAL;
                            }
                            if !(*ptr.offset(1 as libc::c_int as isize) as libc::c_int
                                == 0 as libc::c_int
                                && *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                                    == 0x3e as libc::c_int)
                            {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                            return crate::xmltok_h::XML_TOK_COMMENT;
                        }
                    }
                    _ => ptr = ptr.offset(2 as libc::c_int as isize),
                }
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }

    pub unsafe extern "C" fn normal_scanComment(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        if end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long
        {
            if !(*ptr as libc::c_int == 0x2d as libc::c_int) {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
            ptr = ptr.offset(1 as libc::c_int as isize);
            while end.wrapping_offset_from(ptr) as libc::c_long
                >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long
            {
                match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                    as libc::c_int
                {
                    5 => {
                        if (end.wrapping_offset_from(ptr) as libc::c_long)
                            < 2 as libc::c_int as libc::c_long
                        {
                            return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                        }
                        if (*(enc as *const normal_encoding))
                            .isInvalid2
                            .expect("non-null function pointer")(enc, ptr)
                            != 0
                        {
                            *nextTokPtr = ptr;
                            return crate::xmltok_h::XML_TOK_INVALID;
                        }
                        ptr = ptr.offset(2 as libc::c_int as isize)
                    }
                    6 => {
                        if (end.wrapping_offset_from(ptr) as libc::c_long)
                            < 3 as libc::c_int as libc::c_long
                        {
                            return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                        }
                        if (*(enc as *const normal_encoding))
                            .isInvalid3
                            .expect("non-null function pointer")(enc, ptr)
                            != 0
                        {
                            *nextTokPtr = ptr;
                            return crate::xmltok_h::XML_TOK_INVALID;
                        }
                        ptr = ptr.offset(3 as libc::c_int as isize)
                    }
                    7 => {
                        if (end.wrapping_offset_from(ptr) as libc::c_long)
                            < 4 as libc::c_int as libc::c_long
                        {
                            return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                        }
                        if (*(enc as *const normal_encoding))
                            .isInvalid4
                            .expect("non-null function pointer")(enc, ptr)
                            != 0
                        {
                            *nextTokPtr = ptr;
                            return crate::xmltok_h::XML_TOK_INVALID;
                        }
                        ptr = ptr.offset(4 as libc::c_int as isize)
                    }
                    0 | 1 | 8 => {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    27 => {
                        ptr = ptr.offset(1 as libc::c_int as isize);
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                        {
                            return crate::xmltok_h::XML_TOK_PARTIAL;
                        }
                        if *ptr as libc::c_int == 0x2d as libc::c_int {
                            ptr = ptr.offset(1 as libc::c_int as isize);
                            if !(end.wrapping_offset_from(ptr) as libc::c_long
                                >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                            {
                                return crate::xmltok_h::XML_TOK_PARTIAL;
                            }
                            if !(*ptr as libc::c_int == 0x3e as libc::c_int) {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            *nextTokPtr = ptr.offset(1 as libc::c_int as isize);
                            return crate::xmltok_h::XML_TOK_COMMENT;
                        }
                    }
                    _ => ptr = ptr.offset(1 as libc::c_int as isize),
                }
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }
    /* ptr points to character following "<!" */
    /* ptr points to character following "<!" */
    /* ptr points to character following "<!" */

    pub unsafe extern "C" fn normal_scanDecl(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        if !(end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
        {
            return crate::xmltok_h::XML_TOK_PARTIAL;
        }
        match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize] as libc::c_int
        {
            27 => {
                return normal_scanComment(
                    enc,
                    ptr.offset(1 as libc::c_int as isize),
                    end,
                    nextTokPtr,
                )
            }
            20 => {
                *nextTokPtr = ptr.offset(1 as libc::c_int as isize);
                return crate::xmltok_h::XML_TOK_COND_SECT_OPEN;
            }
            22 | 24 => ptr = ptr.offset(1 as libc::c_int as isize),
            _ => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
        }
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long
        {
            's_151: {
                match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                    as libc::c_int
                {
                    30 => {
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (2 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                        {
                            return crate::xmltok_h::XML_TOK_PARTIAL;
                        }
                        /* don't allow <!ENTITY% foo "whatever"> */
                        /* don't allow <!ENTITY% foo "whatever"> */
                        /* don't allow <!ENTITY% foo "whatever"> */
                        match (*(enc as *mut normal_encoding)).type_0
                            [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                            as libc::c_int
                        {
                            21 | 9 | 10 | 30 => {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            _ => {}
                        }
                    }
                    21 | 9 | 10 => {}
                    22 | 24 => {
                        ptr = ptr.offset(1 as libc::c_int as isize);
                        break 's_151;
                    }
                    _ => {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                }
                /* fall through */
                /* fall through */
                /* fall through */
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_DECL_OPEN;
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }

    pub unsafe extern "C" fn little2_scanDecl(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        if !(end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
        {
            return crate::xmltok_h::XML_TOK_PARTIAL;
        }
        match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
            (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize] as libc::c_int
        } else {
            unicode_byte_type(
                *ptr.offset(1 as libc::c_int as isize),
                *ptr.offset(0 as libc::c_int as isize),
            )
        } {
            27 => {
                return little2_scanComment(
                    enc,
                    ptr.offset(2 as libc::c_int as isize),
                    end,
                    nextTokPtr,
                )
            }
            20 => {
                *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                return crate::xmltok_h::XML_TOK_COND_SECT_OPEN;
            }
            22 | 24 => ptr = ptr.offset(2 as libc::c_int as isize),
            _ => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
        }
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            's_151: {
                match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                    (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                        as libc::c_int
                } else {
                    unicode_byte_type(
                        *ptr.offset(1 as libc::c_int as isize),
                        *ptr.offset(0 as libc::c_int as isize),
                    )
                } {
                    30 => {
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (2 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                        {
                            return crate::xmltok_h::XML_TOK_PARTIAL;
                        }
                        match if *ptr
                            .offset(2 as libc::c_int as isize)
                            .offset(1 as libc::c_int as isize)
                            as libc::c_int
                            == 0 as libc::c_int
                        {
                            (*(enc as *mut normal_encoding)).type_0
                                [*ptr.offset(2 as libc::c_int as isize) as libc::c_uchar as usize]
                                as libc::c_int
                        } else {
                            unicode_byte_type(
                                *ptr.offset(2 as libc::c_int as isize)
                                    .offset(1 as libc::c_int as isize),
                                *ptr.offset(2 as libc::c_int as isize)
                                    .offset(0 as libc::c_int as isize),
                            )
                        } {
                            21 | 9 | 10 | 30 => {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            _ => {}
                        }
                    }
                    21 | 9 | 10 => {}
                    22 | 24 => {
                        ptr = ptr.offset(2 as libc::c_int as isize);
                        break 's_151;
                    }
                    _ => {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                }
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_DECL_OPEN;
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }

    pub unsafe extern "C" fn big2_scanDecl(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        if !(end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
        {
            return crate::xmltok_h::XML_TOK_PARTIAL;
        }
        match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
            (*(enc as *mut normal_encoding)).type_0
                [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                as libc::c_int
        } else {
            unicode_byte_type(
                *ptr.offset(0 as libc::c_int as isize),
                *ptr.offset(1 as libc::c_int as isize),
            )
        } {
            27 => {
                return big2_scanComment(
                    enc,
                    ptr.offset(2 as libc::c_int as isize),
                    end,
                    nextTokPtr,
                )
            }
            20 => {
                *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                return crate::xmltok_h::XML_TOK_COND_SECT_OPEN;
            }
            22 | 24 => ptr = ptr.offset(2 as libc::c_int as isize),
            _ => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
        }
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            's_151: {
                match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                    (*(enc as *mut normal_encoding)).type_0
                        [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                        as libc::c_int
                } else {
                    unicode_byte_type(
                        *ptr.offset(0 as libc::c_int as isize),
                        *ptr.offset(1 as libc::c_int as isize),
                    )
                } {
                    30 => {
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (2 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                        {
                            return crate::xmltok_h::XML_TOK_PARTIAL;
                        }
                        match if *ptr
                            .offset(2 as libc::c_int as isize)
                            .offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == 0 as libc::c_int
                        {
                            (*(enc as *mut normal_encoding)).type_0[*ptr
                                .offset(2 as libc::c_int as isize)
                                .offset(1 as libc::c_int as isize)
                                as libc::c_uchar
                                as usize] as libc::c_int
                        } else {
                            unicode_byte_type(
                                *ptr.offset(2 as libc::c_int as isize)
                                    .offset(0 as libc::c_int as isize),
                                *ptr.offset(2 as libc::c_int as isize)
                                    .offset(1 as libc::c_int as isize),
                            )
                        } {
                            21 | 9 | 10 | 30 => {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            _ => {}
                        }
                    }
                    21 | 9 | 10 => {}
                    22 | 24 => {
                        ptr = ptr.offset(2 as libc::c_int as isize);
                        break 's_151;
                    }
                    _ => {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                }
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_DECL_OPEN;
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }

    pub unsafe extern "C" fn little2_checkPiTarget(
        mut _enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut tokPtr: *mut libc::c_int,
    ) -> libc::c_int {
        let mut upper: libc::c_int = 0 as libc::c_int;
        *tokPtr = crate::xmltok_h::XML_TOK_PI;
        if end.wrapping_offset_from(ptr) as libc::c_long
            != (2 as libc::c_int * 3 as libc::c_int) as libc::c_long
        {
            return 1 as libc::c_int;
        }
        match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
            *ptr.offset(0 as libc::c_int as isize) as libc::c_int
        } else {
            -(1 as libc::c_int)
        } {
            crate::ascii_h_0::ASCII_x => {}
            crate::ascii_h_0::ASCII_X => upper = 1 as libc::c_int,
            _ => return 1 as libc::c_int,
        }
        ptr = ptr.offset(2 as libc::c_int as isize);
        match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
            *ptr.offset(0 as libc::c_int as isize) as libc::c_int
        } else {
            -(1 as libc::c_int)
        } {
            crate::ascii_h_0::ASCII_m => {}
            crate::ascii_h_0::ASCII_M => upper = 1 as libc::c_int,
            _ => return 1 as libc::c_int,
        }
        ptr = ptr.offset(2 as libc::c_int as isize);
        match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
            *ptr.offset(0 as libc::c_int as isize) as libc::c_int
        } else {
            -(1 as libc::c_int)
        } {
            crate::ascii_h_0::ASCII_l => {}
            crate::ascii_h_0::ASCII_L => upper = 1 as libc::c_int,
            _ => return 1 as libc::c_int,
        }
        if upper != 0 {
            return 0 as libc::c_int;
        }
        *tokPtr = crate::xmltok_h::XML_TOK_XML_DECL;
        return 1 as libc::c_int;
    }

    pub unsafe extern "C" fn big2_checkPiTarget(
        mut _enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut tokPtr: *mut libc::c_int,
    ) -> libc::c_int {
        let mut upper: libc::c_int = 0 as libc::c_int;
        *tokPtr = crate::xmltok_h::XML_TOK_PI;
        if end.wrapping_offset_from(ptr) as libc::c_long
            != (2 as libc::c_int * 3 as libc::c_int) as libc::c_long
        {
            return 1 as libc::c_int;
        }
        match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
            *ptr.offset(1 as libc::c_int as isize) as libc::c_int
        } else {
            -(1 as libc::c_int)
        } {
            crate::ascii_h_0::ASCII_x => {}
            crate::ascii_h_0::ASCII_X => upper = 1 as libc::c_int,
            _ => return 1 as libc::c_int,
        }
        ptr = ptr.offset(2 as libc::c_int as isize);
        match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
            *ptr.offset(1 as libc::c_int as isize) as libc::c_int
        } else {
            -(1 as libc::c_int)
        } {
            crate::ascii_h_0::ASCII_m => {}
            crate::ascii_h_0::ASCII_M => upper = 1 as libc::c_int,
            _ => return 1 as libc::c_int,
        }
        ptr = ptr.offset(2 as libc::c_int as isize);
        match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
            *ptr.offset(1 as libc::c_int as isize) as libc::c_int
        } else {
            -(1 as libc::c_int)
        } {
            crate::ascii_h_0::ASCII_l => {}
            crate::ascii_h_0::ASCII_L => upper = 1 as libc::c_int,
            _ => return 1 as libc::c_int,
        }
        if upper != 0 {
            return 0 as libc::c_int;
        }
        *tokPtr = crate::xmltok_h::XML_TOK_XML_DECL;
        return 1 as libc::c_int;
    }

    pub unsafe extern "C" fn normal_checkPiTarget(
        mut _enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut tokPtr: *mut libc::c_int,
    ) -> libc::c_int {
        let mut upper: libc::c_int = 0 as libc::c_int;
        *tokPtr = crate::xmltok_h::XML_TOK_PI;
        if end.wrapping_offset_from(ptr) as libc::c_long
            != (1 as libc::c_int * 3 as libc::c_int) as libc::c_long
        {
            return 1 as libc::c_int;
        }
        match *ptr as libc::c_int {
            crate::ascii_h_0::ASCII_x => {}
            crate::ascii_h_0::ASCII_X => upper = 1 as libc::c_int,
            _ => return 1 as libc::c_int,
        }
        ptr = ptr.offset(1 as libc::c_int as isize);
        match *ptr as libc::c_int {
            crate::ascii_h_0::ASCII_m => {}
            crate::ascii_h_0::ASCII_M => upper = 1 as libc::c_int,
            _ => return 1 as libc::c_int,
        }
        ptr = ptr.offset(1 as libc::c_int as isize);
        match *ptr as libc::c_int {
            crate::ascii_h_0::ASCII_l => {}
            crate::ascii_h_0::ASCII_L => upper = 1 as libc::c_int,
            _ => return 1 as libc::c_int,
        }
        if upper != 0 {
            return 0 as libc::c_int;
        }
        *tokPtr = crate::xmltok_h::XML_TOK_XML_DECL;
        return 1 as libc::c_int;
    }
    /* ptr points to character following "<?" */
    /* ptr points to character following "<?" */
    /* ptr points to character following "<?" */

    pub unsafe extern "C" fn little2_scanPi(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        let mut tok: libc::c_int = 0;
        let mut target: *const libc::c_char = ptr;
        if !(end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
        {
            return crate::xmltok_h::XML_TOK_PARTIAL;
        }
        let mut current_block_32: u64;
        match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
            (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize] as libc::c_int
        } else {
            unicode_byte_type(
                *ptr.offset(1 as libc::c_int as isize),
                *ptr.offset(0 as libc::c_int as isize),
            )
        } {
            29 => {
                if namingBitmap[(((nmstrtPages
                    [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int)
                    << 3 as libc::c_int)
                    + (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                        >> 5 as libc::c_int)) as usize]
                    & (1 as libc::c_uint)
                        << (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            & 0x1f as libc::c_int)
                    == 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                current_block_32 = 6398034955962673631;
            }
            22 | 24 => {
                current_block_32 = 6398034955962673631;
            }
            5 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 2 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(2 as libc::c_int as isize);
                current_block_32 = 11913429853522160501;
            }
            6 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 3 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(3 as libc::c_int as isize);
                current_block_32 = 11913429853522160501;
            }
            7 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(4 as libc::c_int as isize);
                current_block_32 = 11913429853522160501;
            }
            _ => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
        }
        match current_block_32 {
            6398034955962673631 => ptr = ptr.offset(2 as libc::c_int as isize),
            _ => {}
        }
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            let mut current_block_118: u64;
            match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(1 as libc::c_int as isize),
                    *ptr.offset(0 as libc::c_int as isize),
                )
            } {
                29 => {
                    if namingBitmap[(((namePages
                        [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                        as libc::c_int)
                        << 3 as libc::c_int)
                        + (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            >> 5 as libc::c_int)) as usize]
                        & (1 as libc::c_uint)
                            << (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar
                                as libc::c_int
                                & 0x1f as libc::c_int)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    current_block_118 = 12311525036306139934;
                }
                22 | 24 | 25 | 26 | 27 => {
                    current_block_118 = 12311525036306139934;
                }
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    current_block_118 = 18218798608644444571;
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize);
                    current_block_118 = 18218798608644444571;
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    current_block_118 = 18218798608644444571;
                }
                21 | 9 | 10 => {
                    if little2_checkPiTarget(enc, target, ptr, &mut tok) == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    while end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
                    {
                        match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                            == 0 as libc::c_int
                        {
                            (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                                as libc::c_int
                        } else {
                            unicode_byte_type(
                                *ptr.offset(1 as libc::c_int as isize),
                                *ptr.offset(0 as libc::c_int as isize),
                            )
                        } {
                            5 => {
                                if (end.wrapping_offset_from(ptr) as libc::c_long)
                                    < 2 as libc::c_int as libc::c_long
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                }
                                ptr = ptr.offset(2 as libc::c_int as isize)
                            }
                            6 => {
                                if (end.wrapping_offset_from(ptr) as libc::c_long)
                                    < 3 as libc::c_int as libc::c_long
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                }
                                ptr = ptr.offset(3 as libc::c_int as isize)
                            }
                            7 => {
                                if (end.wrapping_offset_from(ptr) as libc::c_long)
                                    < 4 as libc::c_int as libc::c_long
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                }
                                ptr = ptr.offset(4 as libc::c_int as isize)
                            }
                            0 | 1 | 8 => {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            15 => {
                                ptr = ptr.offset(2 as libc::c_int as isize);
                                if !(end.wrapping_offset_from(ptr) as libc::c_long
                                    >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL;
                                }
                                if *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                                    == 0 as libc::c_int
                                    && *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                                        == 0x3e as libc::c_int
                                {
                                    *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                                    return tok;
                                }
                            }
                            _ => ptr = ptr.offset(2 as libc::c_int as isize),
                        }
                    }
                    return crate::xmltok_h::XML_TOK_PARTIAL;
                }
                15 => {
                    if little2_checkPiTarget(enc, target, ptr, &mut tok) == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL;
                    }
                    if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                        && *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                            == 0x3e as libc::c_int
                    {
                        *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                        return tok;
                    }
                    current_block_118 = 1368869732813945810;
                }
                _ => {
                    current_block_118 = 1368869732813945810;
                }
            }
            match current_block_118 {
                1368869732813945810 =>
                /* fall through */
                /* fall through */
                /* fall through */
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                12311525036306139934 => ptr = ptr.offset(2 as libc::c_int as isize),
                _ => {}
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }

    pub unsafe extern "C" fn big2_scanPi(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        let mut tok: libc::c_int = 0;
        let mut target: *const libc::c_char = ptr;
        if !(end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
        {
            return crate::xmltok_h::XML_TOK_PARTIAL;
        }
        let mut current_block_32: u64;
        match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
            (*(enc as *mut normal_encoding)).type_0
                [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                as libc::c_int
        } else {
            unicode_byte_type(
                *ptr.offset(0 as libc::c_int as isize),
                *ptr.offset(1 as libc::c_int as isize),
            )
        } {
            29 => {
                if namingBitmap[(((nmstrtPages
                    [*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int)
                    << 3 as libc::c_int)
                    + (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                        >> 5 as libc::c_int)) as usize]
                    & (1 as libc::c_uint)
                        << (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            & 0x1f as libc::c_int)
                    == 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                current_block_32 = 13803923597135322110;
            }
            22 | 24 => {
                current_block_32 = 13803923597135322110;
            }
            5 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 2 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(2 as libc::c_int as isize);
                current_block_32 = 11913429853522160501;
            }
            6 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 3 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(3 as libc::c_int as isize);
                current_block_32 = 11913429853522160501;
            }
            7 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(4 as libc::c_int as isize);
                current_block_32 = 11913429853522160501;
            }
            _ => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
        }
        match current_block_32 {
            13803923597135322110 => ptr = ptr.offset(2 as libc::c_int as isize),
            _ => {}
        }
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            let mut current_block_118: u64;
            match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0
                    [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(0 as libc::c_int as isize),
                    *ptr.offset(1 as libc::c_int as isize),
                )
            } {
                29 => {
                    if namingBitmap[(((namePages
                        [*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as usize]
                        as libc::c_int)
                        << 3 as libc::c_int)
                        + (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            >> 5 as libc::c_int)) as usize]
                        & (1 as libc::c_uint)
                            << (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar
                                as libc::c_int
                                & 0x1f as libc::c_int)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    current_block_118 = 8820551849686684873;
                }
                22 | 24 | 25 | 26 | 27 => {
                    current_block_118 = 8820551849686684873;
                }
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    current_block_118 = 18218798608644444571;
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize);
                    current_block_118 = 18218798608644444571;
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    current_block_118 = 18218798608644444571;
                }
                21 | 9 | 10 => {
                    if big2_checkPiTarget(enc, target, ptr, &mut tok) == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    while end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
                    {
                        match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                            == 0 as libc::c_int
                        {
                            (*(enc as *mut normal_encoding)).type_0
                                [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                                as libc::c_int
                        } else {
                            unicode_byte_type(
                                *ptr.offset(0 as libc::c_int as isize),
                                *ptr.offset(1 as libc::c_int as isize),
                            )
                        } {
                            5 => {
                                if (end.wrapping_offset_from(ptr) as libc::c_long)
                                    < 2 as libc::c_int as libc::c_long
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                }
                                ptr = ptr.offset(2 as libc::c_int as isize)
                            }
                            6 => {
                                if (end.wrapping_offset_from(ptr) as libc::c_long)
                                    < 3 as libc::c_int as libc::c_long
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                }
                                ptr = ptr.offset(3 as libc::c_int as isize)
                            }
                            7 => {
                                if (end.wrapping_offset_from(ptr) as libc::c_long)
                                    < 4 as libc::c_int as libc::c_long
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                }
                                ptr = ptr.offset(4 as libc::c_int as isize)
                            }
                            0 | 1 | 8 => {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            15 => {
                                ptr = ptr.offset(2 as libc::c_int as isize);
                                if !(end.wrapping_offset_from(ptr) as libc::c_long
                                    >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL;
                                }
                                if *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                                    == 0 as libc::c_int
                                    && *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                                        == 0x3e as libc::c_int
                                {
                                    *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                                    return tok;
                                }
                            }
                            _ => ptr = ptr.offset(2 as libc::c_int as isize),
                        }
                    }
                    return crate::xmltok_h::XML_TOK_PARTIAL;
                }
                15 => {
                    if big2_checkPiTarget(enc, target, ptr, &mut tok) == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL;
                    }
                    if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                        && *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                            == 0x3e as libc::c_int
                    {
                        *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                        return tok;
                    }
                    current_block_118 = 5922746384104648762;
                }
                _ => {
                    current_block_118 = 5922746384104648762;
                }
            }
            match current_block_118 {
                5922746384104648762 => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                8820551849686684873 => ptr = ptr.offset(2 as libc::c_int as isize),
                _ => {}
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }

    pub unsafe extern "C" fn normal_scanPi(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        let mut tok: libc::c_int = 0;
        let mut target: *const libc::c_char = ptr;
        if !(end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
        {
            return crate::xmltok_h::XML_TOK_PARTIAL;
        }
        let mut current_block_32: u64;
        match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize] as libc::c_int
        {
            29 => {
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                current_block_32 = 909593556805851584;
            }
            22 | 24 => {
                current_block_32 = 909593556805851584;
            }
            5 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 2 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if (*(enc as *const normal_encoding))
                    .isNmstrt2
                    .expect("non-null function pointer")(enc, ptr)
                    == 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(2 as libc::c_int as isize);
                current_block_32 = 11913429853522160501;
            }
            6 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 3 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if (*(enc as *const normal_encoding))
                    .isNmstrt3
                    .expect("non-null function pointer")(enc, ptr)
                    == 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(3 as libc::c_int as isize);
                current_block_32 = 11913429853522160501;
            }
            7 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if (*(enc as *const normal_encoding))
                    .isNmstrt4
                    .expect("non-null function pointer")(enc, ptr)
                    == 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(4 as libc::c_int as isize);
                current_block_32 = 11913429853522160501;
            }
            _ => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
        }
        match current_block_32 {
            909593556805851584 => ptr = ptr.offset(1 as libc::c_int as isize),
            _ => {}
        }
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long
        {
            let mut current_block_118: u64;
            match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                as libc::c_int
            {
                29 => {
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    current_block_118 = 5152980791761092907;
                }
                22 | 24 | 25 | 26 | 27 => {
                    current_block_118 = 5152980791761092907;
                }
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if (*(enc as *const normal_encoding))
                        .isName2
                        .expect("non-null function pointer")(enc, ptr)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    current_block_118 = 18218798608644444571;
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if (*(enc as *const normal_encoding))
                        .isName3
                        .expect("non-null function pointer")(enc, ptr)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize);
                    current_block_118 = 18218798608644444571;
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if (*(enc as *const normal_encoding))
                        .isName4
                        .expect("non-null function pointer")(enc, ptr)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    current_block_118 = 18218798608644444571;
                }
                21 | 9 | 10 => {
                    if normal_checkPiTarget(enc, target, ptr, &mut tok) == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(1 as libc::c_int as isize);
                    while end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long
                    {
                        match (*(enc as *mut normal_encoding)).type_0
                            [*ptr as libc::c_uchar as usize]
                            as libc::c_int
                        {
                            5 => {
                                if (end.wrapping_offset_from(ptr) as libc::c_long)
                                    < 2 as libc::c_int as libc::c_long
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                }
                                if (*(enc as *const normal_encoding))
                                    .isInvalid2
                                    .expect("non-null function pointer")(
                                    enc, ptr
                                ) != 0
                                {
                                    *nextTokPtr = ptr;
                                    return crate::xmltok_h::XML_TOK_INVALID;
                                }
                                ptr = ptr.offset(2 as libc::c_int as isize)
                            }
                            6 => {
                                if (end.wrapping_offset_from(ptr) as libc::c_long)
                                    < 3 as libc::c_int as libc::c_long
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                }
                                if (*(enc as *const normal_encoding))
                                    .isInvalid3
                                    .expect("non-null function pointer")(
                                    enc, ptr
                                ) != 0
                                {
                                    *nextTokPtr = ptr;
                                    return crate::xmltok_h::XML_TOK_INVALID;
                                }
                                ptr = ptr.offset(3 as libc::c_int as isize)
                            }
                            7 => {
                                if (end.wrapping_offset_from(ptr) as libc::c_long)
                                    < 4 as libc::c_int as libc::c_long
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                }
                                if (*(enc as *const normal_encoding))
                                    .isInvalid4
                                    .expect("non-null function pointer")(
                                    enc, ptr
                                ) != 0
                                {
                                    *nextTokPtr = ptr;
                                    return crate::xmltok_h::XML_TOK_INVALID;
                                }
                                ptr = ptr.offset(4 as libc::c_int as isize)
                            }
                            0 | 1 | 8 => {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            15 => {
                                ptr = ptr.offset(1 as libc::c_int as isize);
                                if !(end.wrapping_offset_from(ptr) as libc::c_long
                                    >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL;
                                }
                                if *ptr as libc::c_int == 0x3e as libc::c_int {
                                    *nextTokPtr = ptr.offset(1 as libc::c_int as isize);
                                    return tok;
                                }
                            }
                            _ => ptr = ptr.offset(1 as libc::c_int as isize),
                        }
                    }
                    return crate::xmltok_h::XML_TOK_PARTIAL;
                }
                15 => {
                    if normal_checkPiTarget(enc, target, ptr, &mut tok) == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(1 as libc::c_int as isize);
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL;
                    }
                    if *ptr as libc::c_int == 0x3e as libc::c_int {
                        *nextTokPtr = ptr.offset(1 as libc::c_int as isize);
                        return tok;
                    }
                    current_block_118 = 12516980621136662590;
                }
                _ => {
                    current_block_118 = 12516980621136662590;
                }
            }
            match current_block_118 {
                12516980621136662590 => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                5152980791761092907 => ptr = ptr.offset(1 as libc::c_int as isize),
                _ => {}
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }

    pub unsafe extern "C" fn big2_scanCdataSection(
        mut _enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        pub static mut CDATA_LSQB: [libc::c_char; 6] = [
            crate::ascii_h::ASCII_C as libc::c_char,
            crate::ascii_h::ASCII_D as libc::c_char,
            crate::ascii_h::ASCII_A as libc::c_char,
            crate::ascii_h::ASCII_T as libc::c_char,
            crate::ascii_h::ASCII_A as libc::c_char,
            crate::ascii_h::ASCII_LSQB as libc::c_char,
        ];
        let mut i: libc::c_int = 0;
        /* CDATA[ */
        /* CDATA[ */
        /* CDATA[ */
        if !(end.wrapping_offset_from(ptr) as libc::c_long
            >= (6 as libc::c_int * 2 as libc::c_int) as libc::c_long)
        {
            return crate::xmltok_h::XML_TOK_PARTIAL;
        }
        i = 0 as libc::c_int;
        while i < 6 as libc::c_int {
            if !(*ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                && *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                    == CDATA_LSQB[i as usize] as libc::c_int)
            {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
            i += 1;
            ptr = ptr.offset(2 as libc::c_int as isize)
        }
        *nextTokPtr = ptr;
        return crate::xmltok_h::XML_TOK_CDATA_SECT_OPEN;
    }

    pub unsafe extern "C" fn normal_scanCdataSection(
        mut _enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        pub static mut CDATA_LSQB: [libc::c_char; 6] = [
            crate::ascii_h::ASCII_C as libc::c_char,
            crate::ascii_h::ASCII_D as libc::c_char,
            crate::ascii_h::ASCII_A as libc::c_char,
            crate::ascii_h::ASCII_T as libc::c_char,
            crate::ascii_h::ASCII_A as libc::c_char,
            crate::ascii_h::ASCII_LSQB as libc::c_char,
        ];
        let mut i: libc::c_int = 0;
        if !(end.wrapping_offset_from(ptr) as libc::c_long
            >= (6 as libc::c_int * 1 as libc::c_int) as libc::c_long)
        {
            return crate::xmltok_h::XML_TOK_PARTIAL;
        }
        i = 0 as libc::c_int;
        while i < 6 as libc::c_int {
            if !(*ptr as libc::c_int == CDATA_LSQB[i as usize] as libc::c_int) {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
            i += 1;
            ptr = ptr.offset(1 as libc::c_int as isize)
        }
        *nextTokPtr = ptr;
        return crate::xmltok_h::XML_TOK_CDATA_SECT_OPEN;
    }

    pub unsafe extern "C" fn little2_scanCdataSection(
        mut _enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        pub static mut CDATA_LSQB: [libc::c_char; 6] = [
            crate::ascii_h::ASCII_C as libc::c_char,
            crate::ascii_h::ASCII_D as libc::c_char,
            crate::ascii_h::ASCII_A as libc::c_char,
            crate::ascii_h::ASCII_T as libc::c_char,
            crate::ascii_h::ASCII_A as libc::c_char,
            crate::ascii_h::ASCII_LSQB as libc::c_char,
        ];
        let mut i: libc::c_int = 0;
        if !(end.wrapping_offset_from(ptr) as libc::c_long
            >= (6 as libc::c_int * 2 as libc::c_int) as libc::c_long)
        {
            return crate::xmltok_h::XML_TOK_PARTIAL;
        }
        i = 0 as libc::c_int;
        while i < 6 as libc::c_int {
            if !(*ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                && *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                    == CDATA_LSQB[i as usize] as libc::c_int)
            {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
            i += 1;
            ptr = ptr.offset(2 as libc::c_int as isize)
        }
        *nextTokPtr = ptr;
        return crate::xmltok_h::XML_TOK_CDATA_SECT_OPEN;
    }

    pub unsafe extern "C" fn big2_cdataSectionTok(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        if ptr >= end {
            return crate::xmltok_h::XML_TOK_NONE;
        }
        if 2 as libc::c_int > 1 as libc::c_int {
            let mut n: crate::stddef_h::size_t =
                end.wrapping_offset_from(ptr) as libc::c_long as crate::stddef_h::size_t;
            if n & (2 as libc::c_int - 1 as libc::c_int) as libc::c_ulong != 0 {
                n &= !(2 as libc::c_int - 1 as libc::c_int) as libc::c_ulong;
                if n == 0 as libc::c_int as libc::c_ulong {
                    return crate::xmltok_h::XML_TOK_PARTIAL;
                }
                end = ptr.offset(n as isize)
            }
        }
        match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
            (*(enc as *mut normal_encoding)).type_0
                [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                as libc::c_int
        } else {
            unicode_byte_type(
                *ptr.offset(0 as libc::c_int as isize),
                *ptr.offset(1 as libc::c_int as isize),
            )
        } {
            4 => {
                ptr = ptr.offset(2 as libc::c_int as isize);
                if !(end.wrapping_offset_from(ptr) as libc::c_long
                    >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL;
                }
                if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                    && *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0x5d as libc::c_int
                {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL;
                    }
                    if !(*ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                        && *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                            == 0x3e as libc::c_int)
                    {
                        ptr = ptr.offset(-(2 as libc::c_int as isize))
                    } else {
                        *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                        return crate::xmltok_h::XML_TOK_CDATA_SECT_CLOSE;
                    }
                }
            }
            9 => {
                ptr = ptr.offset(2 as libc::c_int as isize);
                if !(end.wrapping_offset_from(ptr) as libc::c_long
                    >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL;
                }
                if (if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                    (*(enc as *mut normal_encoding)).type_0
                        [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                        as libc::c_int
                } else {
                    unicode_byte_type(
                        *ptr.offset(0 as libc::c_int as isize),
                        *ptr.offset(1 as libc::c_int as isize),
                    )
                }) == crate::xmltok_impl_h::BT_LF as libc::c_int
                {
                    ptr = ptr.offset(2 as libc::c_int as isize)
                }
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_DATA_NEWLINE;
            }
            10 => {
                *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                return crate::xmltok_h::XML_TOK_DATA_NEWLINE;
            }
            5 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 2 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                ptr = ptr.offset(2 as libc::c_int as isize)
            }
            6 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 3 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                ptr = ptr.offset(3 as libc::c_int as isize)
            }
            7 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                ptr = ptr.offset(4 as libc::c_int as isize)
            }
            0 | 1 | 8 => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
            _ => ptr = ptr.offset(2 as libc::c_int as isize),
        }
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0
                    [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(0 as libc::c_int as isize),
                    *ptr.offset(1 as libc::c_int as isize),
                )
            } {
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                        || 0 as libc::c_int != 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_DATA_CHARS;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize)
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                        || 0 as libc::c_int != 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_DATA_CHARS;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize)
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                        || 0 as libc::c_int != 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_DATA_CHARS;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize)
                }
                0 | 1 | 8 | 9 | 10 | 4 => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_DATA_CHARS;
                }
                _ => ptr = ptr.offset(2 as libc::c_int as isize),
            }
        }
        *nextTokPtr = ptr;
        return crate::xmltok_h::XML_TOK_DATA_CHARS;
    }

    pub unsafe extern "C" fn little2_cdataSectionTok(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        if ptr >= end {
            return crate::xmltok_h::XML_TOK_NONE;
        }
        if 2 as libc::c_int > 1 as libc::c_int {
            let mut n: crate::stddef_h::size_t =
                end.wrapping_offset_from(ptr) as libc::c_long as crate::stddef_h::size_t;
            if n & (2 as libc::c_int - 1 as libc::c_int) as libc::c_ulong != 0 {
                n &= !(2 as libc::c_int - 1 as libc::c_int) as libc::c_ulong;
                if n == 0 as libc::c_int as libc::c_ulong {
                    return crate::xmltok_h::XML_TOK_PARTIAL;
                }
                end = ptr.offset(n as isize)
            }
        }
        match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
            (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize] as libc::c_int
        } else {
            unicode_byte_type(
                *ptr.offset(1 as libc::c_int as isize),
                *ptr.offset(0 as libc::c_int as isize),
            )
        } {
            4 => {
                ptr = ptr.offset(2 as libc::c_int as isize);
                if !(end.wrapping_offset_from(ptr) as libc::c_long
                    >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL;
                }
                if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                    && *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0x5d as libc::c_int
                {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL;
                    }
                    if !(*ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                        && *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                            == 0x3e as libc::c_int)
                    {
                        ptr = ptr.offset(-(2 as libc::c_int as isize))
                    } else {
                        *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                        return crate::xmltok_h::XML_TOK_CDATA_SECT_CLOSE;
                    }
                }
            }
            9 => {
                ptr = ptr.offset(2 as libc::c_int as isize);
                if !(end.wrapping_offset_from(ptr) as libc::c_long
                    >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL;
                }
                if (if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                    (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                        as libc::c_int
                } else {
                    unicode_byte_type(
                        *ptr.offset(1 as libc::c_int as isize),
                        *ptr.offset(0 as libc::c_int as isize),
                    )
                }) == crate::xmltok_impl_h::BT_LF as libc::c_int
                {
                    ptr = ptr.offset(2 as libc::c_int as isize)
                }
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_DATA_NEWLINE;
            }
            10 => {
                *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                return crate::xmltok_h::XML_TOK_DATA_NEWLINE;
            }
            5 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 2 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                ptr = ptr.offset(2 as libc::c_int as isize)
            }
            6 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 3 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                ptr = ptr.offset(3 as libc::c_int as isize)
            }
            7 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                ptr = ptr.offset(4 as libc::c_int as isize)
            }
            0 | 1 | 8 => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
            _ => ptr = ptr.offset(2 as libc::c_int as isize),
        }
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(1 as libc::c_int as isize),
                    *ptr.offset(0 as libc::c_int as isize),
                )
            } {
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                        || 0 as libc::c_int != 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_DATA_CHARS;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize)
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                        || 0 as libc::c_int != 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_DATA_CHARS;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize)
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                        || 0 as libc::c_int != 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_DATA_CHARS;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize)
                }
                0 | 1 | 8 | 9 | 10 | 4 => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_DATA_CHARS;
                }
                _ => ptr = ptr.offset(2 as libc::c_int as isize),
            }
        }
        *nextTokPtr = ptr;
        return crate::xmltok_h::XML_TOK_DATA_CHARS;
    }

    pub unsafe extern "C" fn normal_cdataSectionTok(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        if ptr >= end {
            return crate::xmltok_h::XML_TOK_NONE;
        }
        if 1 as libc::c_int > 1 as libc::c_int {
            let mut n: crate::stddef_h::size_t =
                end.wrapping_offset_from(ptr) as libc::c_long as crate::stddef_h::size_t;
            if n & (1 as libc::c_int - 1 as libc::c_int) as libc::c_ulong != 0 {
                n &= !(1 as libc::c_int - 1 as libc::c_int) as libc::c_ulong;
                if n == 0 as libc::c_int as libc::c_ulong {
                    return crate::xmltok_h::XML_TOK_PARTIAL;
                }
                end = ptr.offset(n as isize)
            }
        }
        match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize] as libc::c_int
        {
            4 => {
                ptr = ptr.offset(1 as libc::c_int as isize);
                if !(end.wrapping_offset_from(ptr) as libc::c_long
                    >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL;
                }
                if *ptr as libc::c_int == 0x5d as libc::c_int {
                    ptr = ptr.offset(1 as libc::c_int as isize);
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL;
                    }
                    if !(*ptr as libc::c_int == 0x3e as libc::c_int) {
                        ptr = ptr.offset(-(1 as libc::c_int as isize))
                    } else {
                        *nextTokPtr = ptr.offset(1 as libc::c_int as isize);
                        return crate::xmltok_h::XML_TOK_CDATA_SECT_CLOSE;
                    }
                }
            }
            9 => {
                ptr = ptr.offset(1 as libc::c_int as isize);
                if !(end.wrapping_offset_from(ptr) as libc::c_long
                    >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL;
                }
                if (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                    as libc::c_int
                    == crate::xmltok_impl_h::BT_LF as libc::c_int
                {
                    ptr = ptr.offset(1 as libc::c_int as isize)
                }
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_DATA_NEWLINE;
            }
            10 => {
                *nextTokPtr = ptr.offset(1 as libc::c_int as isize);
                return crate::xmltok_h::XML_TOK_DATA_NEWLINE;
            }
            5 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 2 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if (*(enc as *const normal_encoding))
                    .isInvalid2
                    .expect("non-null function pointer")(enc, ptr)
                    != 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(2 as libc::c_int as isize)
            }
            6 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 3 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if (*(enc as *const normal_encoding))
                    .isInvalid3
                    .expect("non-null function pointer")(enc, ptr)
                    != 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(3 as libc::c_int as isize)
            }
            7 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if (*(enc as *const normal_encoding))
                    .isInvalid4
                    .expect("non-null function pointer")(enc, ptr)
                    != 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(4 as libc::c_int as isize)
            }
            0 | 1 | 8 => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
            _ => ptr = ptr.offset(1 as libc::c_int as isize),
        }
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long
        {
            match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                as libc::c_int
            {
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                        || (*(enc as *const normal_encoding))
                            .isInvalid2
                            .expect("non-null function pointer")(enc, ptr)
                            != 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_DATA_CHARS;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize)
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                        || (*(enc as *const normal_encoding))
                            .isInvalid3
                            .expect("non-null function pointer")(enc, ptr)
                            != 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_DATA_CHARS;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize)
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                        || (*(enc as *const normal_encoding))
                            .isInvalid4
                            .expect("non-null function pointer")(enc, ptr)
                            != 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_DATA_CHARS;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize)
                }
                0 | 1 | 8 | 9 | 10 | 4 => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_DATA_CHARS;
                }
                _ => ptr = ptr.offset(1 as libc::c_int as isize),
            }
        }
        *nextTokPtr = ptr;
        return crate::xmltok_h::XML_TOK_DATA_CHARS;
    }
    /* ptr points to character following "</" */
    /* ptr points to character following "</" */
    /* ptr points to character following "</" */

    pub unsafe extern "C" fn normal_scanEndTag(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        if !(end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
        {
            return crate::xmltok_h::XML_TOK_PARTIAL;
        }
        let mut current_block_32: u64;
        match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize] as libc::c_int
        {
            29 => {
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                current_block_32 = 18181195574538971450;
            }
            22 | 24 => {
                current_block_32 = 18181195574538971450;
            }
            5 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 2 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if (*(enc as *const normal_encoding))
                    .isNmstrt2
                    .expect("non-null function pointer")(enc, ptr)
                    == 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(2 as libc::c_int as isize);
                current_block_32 = 5494826135382683477;
            }
            6 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 3 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if (*(enc as *const normal_encoding))
                    .isNmstrt3
                    .expect("non-null function pointer")(enc, ptr)
                    == 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(3 as libc::c_int as isize);
                current_block_32 = 5494826135382683477;
            }
            7 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if (*(enc as *const normal_encoding))
                    .isNmstrt4
                    .expect("non-null function pointer")(enc, ptr)
                    == 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(4 as libc::c_int as isize);
                current_block_32 = 5494826135382683477;
            }
            _ => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
        }
        match current_block_32 {
            18181195574538971450 => ptr = ptr.offset(1 as libc::c_int as isize),
            _ => {}
        }
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long
        {
            let mut current_block_73: u64;
            match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                as libc::c_int
            {
                29 => {
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    current_block_73 = 17691760011438675887;
                }
                22 | 24 | 25 | 26 | 27 => {
                    current_block_73 = 17691760011438675887;
                }
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if (*(enc as *const normal_encoding))
                        .isName2
                        .expect("non-null function pointer")(enc, ptr)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    current_block_73 = 10809827304263610514;
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if (*(enc as *const normal_encoding))
                        .isName3
                        .expect("non-null function pointer")(enc, ptr)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize);
                    current_block_73 = 10809827304263610514;
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if (*(enc as *const normal_encoding))
                        .isName4
                        .expect("non-null function pointer")(enc, ptr)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    current_block_73 = 10809827304263610514;
                }
                21 | 9 | 10 => {
                    ptr = ptr.offset(1 as libc::c_int as isize);
                    while end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long
                    {
                        match (*(enc as *mut normal_encoding)).type_0
                            [*ptr as libc::c_uchar as usize]
                            as libc::c_int
                        {
                            21 | 9 | 10 => {}
                            11 => {
                                *nextTokPtr = ptr.offset(1 as libc::c_int as isize);
                                return crate::xmltok_h::XML_TOK_END_TAG;
                            }
                            _ => {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                        }
                        ptr = ptr.offset(1 as libc::c_int as isize)
                    }
                    return crate::xmltok_h::XML_TOK_PARTIAL;
                }
                23 => {
                    /* no need to check qname syntax here,
                    since end-tag must match exactly */
                    /* no need to check qname syntax here,
                    since end-tag must match exactly */
                    /* no need to check qname syntax here,
                    since end-tag must match exactly */
                    ptr = ptr.offset(1 as libc::c_int as isize);
                    current_block_73 = 10809827304263610514;
                }
                11 => {
                    *nextTokPtr = ptr.offset(1 as libc::c_int as isize);
                    return crate::xmltok_h::XML_TOK_END_TAG;
                }
                _ => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
            }
            match current_block_73 {
                17691760011438675887 => ptr = ptr.offset(1 as libc::c_int as isize),
                _ => {}
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }

    pub unsafe extern "C" fn big2_scanEndTag(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        if !(end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
        {
            return crate::xmltok_h::XML_TOK_PARTIAL;
        }
        let mut current_block_32: u64;
        match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
            (*(enc as *mut normal_encoding)).type_0
                [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                as libc::c_int
        } else {
            unicode_byte_type(
                *ptr.offset(0 as libc::c_int as isize),
                *ptr.offset(1 as libc::c_int as isize),
            )
        } {
            29 => {
                if namingBitmap[(((nmstrtPages
                    [*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int)
                    << 3 as libc::c_int)
                    + (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                        >> 5 as libc::c_int)) as usize]
                    & (1 as libc::c_uint)
                        << (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            & 0x1f as libc::c_int)
                    == 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                current_block_32 = 10497796554217858559;
            }
            22 | 24 => {
                current_block_32 = 10497796554217858559;
            }
            5 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 2 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(2 as libc::c_int as isize);
                current_block_32 = 5494826135382683477;
            }
            6 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 3 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(3 as libc::c_int as isize);
                current_block_32 = 5494826135382683477;
            }
            7 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(4 as libc::c_int as isize);
                current_block_32 = 5494826135382683477;
            }
            _ => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
        }
        match current_block_32 {
            10497796554217858559 => ptr = ptr.offset(2 as libc::c_int as isize),
            _ => {}
        }
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            let mut current_block_73: u64;
            match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0
                    [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(0 as libc::c_int as isize),
                    *ptr.offset(1 as libc::c_int as isize),
                )
            } {
                29 => {
                    if namingBitmap[(((namePages
                        [*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as usize]
                        as libc::c_int)
                        << 3 as libc::c_int)
                        + (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            >> 5 as libc::c_int)) as usize]
                        & (1 as libc::c_uint)
                            << (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar
                                as libc::c_int
                                & 0x1f as libc::c_int)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    current_block_73 = 15122140455506841825;
                }
                22 | 24 | 25 | 26 | 27 => {
                    current_block_73 = 15122140455506841825;
                }
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    current_block_73 = 10809827304263610514;
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize);
                    current_block_73 = 10809827304263610514;
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    current_block_73 = 10809827304263610514;
                }
                21 | 9 | 10 => {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    while end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
                    {
                        match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                            == 0 as libc::c_int
                        {
                            (*(enc as *mut normal_encoding)).type_0
                                [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                                as libc::c_int
                        } else {
                            unicode_byte_type(
                                *ptr.offset(0 as libc::c_int as isize),
                                *ptr.offset(1 as libc::c_int as isize),
                            )
                        } {
                            21 | 9 | 10 => {}
                            11 => {
                                *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                                return crate::xmltok_h::XML_TOK_END_TAG;
                            }
                            _ => {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                        }
                        ptr = ptr.offset(2 as libc::c_int as isize)
                    }
                    return crate::xmltok_h::XML_TOK_PARTIAL;
                }
                23 => {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    current_block_73 = 10809827304263610514;
                }
                11 => {
                    *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                    return crate::xmltok_h::XML_TOK_END_TAG;
                }
                _ => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
            }
            match current_block_73 {
                15122140455506841825 => ptr = ptr.offset(2 as libc::c_int as isize),
                _ => {}
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }

    pub unsafe extern "C" fn little2_scanEndTag(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        if !(end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
        {
            return crate::xmltok_h::XML_TOK_PARTIAL;
        }
        let mut current_block_32: u64;
        match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
            (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize] as libc::c_int
        } else {
            unicode_byte_type(
                *ptr.offset(1 as libc::c_int as isize),
                *ptr.offset(0 as libc::c_int as isize),
            )
        } {
            29 => {
                if namingBitmap[(((nmstrtPages
                    [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int)
                    << 3 as libc::c_int)
                    + (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                        >> 5 as libc::c_int)) as usize]
                    & (1 as libc::c_uint)
                        << (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            & 0x1f as libc::c_int)
                    == 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                current_block_32 = 188456398757501463;
            }
            22 | 24 => {
                current_block_32 = 188456398757501463;
            }
            5 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 2 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(2 as libc::c_int as isize);
                current_block_32 = 5494826135382683477;
            }
            6 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 3 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(3 as libc::c_int as isize);
                current_block_32 = 5494826135382683477;
            }
            7 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(4 as libc::c_int as isize);
                current_block_32 = 5494826135382683477;
            }
            _ => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
        }
        match current_block_32 {
            188456398757501463 => ptr = ptr.offset(2 as libc::c_int as isize),
            _ => {}
        }
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            let mut current_block_73: u64;
            match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(1 as libc::c_int as isize),
                    *ptr.offset(0 as libc::c_int as isize),
                )
            } {
                29 => {
                    if namingBitmap[(((namePages
                        [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                        as libc::c_int)
                        << 3 as libc::c_int)
                        + (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            >> 5 as libc::c_int)) as usize]
                        & (1 as libc::c_uint)
                            << (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar
                                as libc::c_int
                                & 0x1f as libc::c_int)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    current_block_73 = 8542218964871577364;
                }
                22 | 24 | 25 | 26 | 27 => {
                    current_block_73 = 8542218964871577364;
                }
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    current_block_73 = 10809827304263610514;
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize);
                    current_block_73 = 10809827304263610514;
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    current_block_73 = 10809827304263610514;
                }
                21 | 9 | 10 => {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    while end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
                    {
                        match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                            == 0 as libc::c_int
                        {
                            (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                                as libc::c_int
                        } else {
                            unicode_byte_type(
                                *ptr.offset(1 as libc::c_int as isize),
                                *ptr.offset(0 as libc::c_int as isize),
                            )
                        } {
                            21 | 9 | 10 => {}
                            11 => {
                                *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                                return crate::xmltok_h::XML_TOK_END_TAG;
                            }
                            _ => {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                        }
                        ptr = ptr.offset(2 as libc::c_int as isize)
                    }
                    return crate::xmltok_h::XML_TOK_PARTIAL;
                }
                23 => {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    current_block_73 = 10809827304263610514;
                }
                11 => {
                    *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                    return crate::xmltok_h::XML_TOK_END_TAG;
                }
                _ => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
            }
            match current_block_73 {
                8542218964871577364 => ptr = ptr.offset(2 as libc::c_int as isize),
                _ => {}
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }
    /* ptr points to character following "&#X" */
    /* ptr points to character following "&#X" */
    /* ptr points to character following "&#X" */

    pub unsafe extern "C" fn little2_scanHexCharRef(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        if end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(1 as libc::c_int as isize),
                    *ptr.offset(0 as libc::c_int as isize),
                )
            } {
                25 | 24 => {}
                _ => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
            }
            ptr = ptr.offset(2 as libc::c_int as isize);
            while end.wrapping_offset_from(ptr) as libc::c_long
                >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
            {
                match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                    (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                        as libc::c_int
                } else {
                    unicode_byte_type(
                        *ptr.offset(1 as libc::c_int as isize),
                        *ptr.offset(0 as libc::c_int as isize),
                    )
                } {
                    25 | 24 => {}
                    18 => {
                        *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                        return crate::xmltok_h::XML_TOK_CHAR_REF;
                    }
                    _ => {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                }
                ptr = ptr.offset(2 as libc::c_int as isize)
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }

    pub unsafe extern "C" fn big2_scanHexCharRef(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        if end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0
                    [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(0 as libc::c_int as isize),
                    *ptr.offset(1 as libc::c_int as isize),
                )
            } {
                25 | 24 => {}
                _ => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
            }
            ptr = ptr.offset(2 as libc::c_int as isize);
            while end.wrapping_offset_from(ptr) as libc::c_long
                >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
            {
                match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                    (*(enc as *mut normal_encoding)).type_0
                        [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                        as libc::c_int
                } else {
                    unicode_byte_type(
                        *ptr.offset(0 as libc::c_int as isize),
                        *ptr.offset(1 as libc::c_int as isize),
                    )
                } {
                    25 | 24 => {}
                    18 => {
                        *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                        return crate::xmltok_h::XML_TOK_CHAR_REF;
                    }
                    _ => {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                }
                ptr = ptr.offset(2 as libc::c_int as isize)
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }

    pub unsafe extern "C" fn normal_scanHexCharRef(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        if end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long
        {
            match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                as libc::c_int
            {
                25 | 24 => {}
                _ => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
            }
            ptr = ptr.offset(1 as libc::c_int as isize);
            while end.wrapping_offset_from(ptr) as libc::c_long
                >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long
            {
                match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                    as libc::c_int
                {
                    25 | 24 => {}
                    18 => {
                        *nextTokPtr = ptr.offset(1 as libc::c_int as isize);
                        return crate::xmltok_h::XML_TOK_CHAR_REF;
                    }
                    _ => {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                }
                ptr = ptr.offset(1 as libc::c_int as isize)
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }
    /* ptr points to character following "&#" */
    /* ptr points to character following "&#" */
    /* ptr points to character following "&#" */

    pub unsafe extern "C" fn little2_scanCharRef(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        if end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                && *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0x78 as libc::c_int
            {
                return little2_scanHexCharRef(
                    enc,
                    ptr.offset(2 as libc::c_int as isize),
                    end,
                    nextTokPtr,
                );
            }
            match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(1 as libc::c_int as isize),
                    *ptr.offset(0 as libc::c_int as isize),
                )
            } {
                25 => {}
                _ => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
            }
            ptr = ptr.offset(2 as libc::c_int as isize);
            while end.wrapping_offset_from(ptr) as libc::c_long
                >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
            {
                match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                    (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                        as libc::c_int
                } else {
                    unicode_byte_type(
                        *ptr.offset(1 as libc::c_int as isize),
                        *ptr.offset(0 as libc::c_int as isize),
                    )
                } {
                    25 => {}
                    18 => {
                        *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                        return crate::xmltok_h::XML_TOK_CHAR_REF;
                    }
                    _ => {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                }
                ptr = ptr.offset(2 as libc::c_int as isize)
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }

    pub unsafe extern "C" fn big2_scanCharRef(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        if end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                && *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0x78 as libc::c_int
            {
                return big2_scanHexCharRef(
                    enc,
                    ptr.offset(2 as libc::c_int as isize),
                    end,
                    nextTokPtr,
                );
            }
            match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0
                    [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(0 as libc::c_int as isize),
                    *ptr.offset(1 as libc::c_int as isize),
                )
            } {
                25 => {}
                _ => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
            }
            ptr = ptr.offset(2 as libc::c_int as isize);
            while end.wrapping_offset_from(ptr) as libc::c_long
                >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
            {
                match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                    (*(enc as *mut normal_encoding)).type_0
                        [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                        as libc::c_int
                } else {
                    unicode_byte_type(
                        *ptr.offset(0 as libc::c_int as isize),
                        *ptr.offset(1 as libc::c_int as isize),
                    )
                } {
                    25 => {}
                    18 => {
                        *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                        return crate::xmltok_h::XML_TOK_CHAR_REF;
                    }
                    _ => {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                }
                ptr = ptr.offset(2 as libc::c_int as isize)
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }

    pub unsafe extern "C" fn normal_scanCharRef(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        if end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long
        {
            if *ptr as libc::c_int == 0x78 as libc::c_int {
                return normal_scanHexCharRef(
                    enc,
                    ptr.offset(1 as libc::c_int as isize),
                    end,
                    nextTokPtr,
                );
            }
            match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                as libc::c_int
            {
                25 => {}
                _ => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
            }
            ptr = ptr.offset(1 as libc::c_int as isize);
            while end.wrapping_offset_from(ptr) as libc::c_long
                >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long
            {
                match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                    as libc::c_int
                {
                    25 => {}
                    18 => {
                        *nextTokPtr = ptr.offset(1 as libc::c_int as isize);
                        return crate::xmltok_h::XML_TOK_CHAR_REF;
                    }
                    _ => {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                }
                ptr = ptr.offset(1 as libc::c_int as isize)
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }
    /* ptr points to character following "&" */
    /* ptr points to character following "&" */
    /* ptr points to character following "&" */

    pub unsafe extern "C" fn normal_scanRef(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        if !(end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
        {
            return crate::xmltok_h::XML_TOK_PARTIAL;
        }
        let mut current_block_33: u64;
        match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize] as libc::c_int
        {
            29 => {
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                current_block_33 = 15143551936184752825;
            }
            22 | 24 => {
                current_block_33 = 15143551936184752825;
            }
            5 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 2 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if (*(enc as *const normal_encoding))
                    .isNmstrt2
                    .expect("non-null function pointer")(enc, ptr)
                    == 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(2 as libc::c_int as isize);
                current_block_33 = 18377268871191777778;
            }
            6 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 3 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if (*(enc as *const normal_encoding))
                    .isNmstrt3
                    .expect("non-null function pointer")(enc, ptr)
                    == 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(3 as libc::c_int as isize);
                current_block_33 = 18377268871191777778;
            }
            7 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if (*(enc as *const normal_encoding))
                    .isNmstrt4
                    .expect("non-null function pointer")(enc, ptr)
                    == 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(4 as libc::c_int as isize);
                current_block_33 = 18377268871191777778;
            }
            19 => {
                return normal_scanCharRef(
                    enc,
                    ptr.offset(1 as libc::c_int as isize),
                    end,
                    nextTokPtr,
                )
            }
            _ => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
        }
        match current_block_33 {
            15143551936184752825 => ptr = ptr.offset(1 as libc::c_int as isize),
            _ => {}
        }
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long
        {
            let mut current_block_64: u64;
            match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                as libc::c_int
            {
                29 => {
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    current_block_64 = 12579958577185958249;
                }
                22 | 24 | 25 | 26 | 27 => {
                    current_block_64 = 12579958577185958249;
                }
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if (*(enc as *const normal_encoding))
                        .isName2
                        .expect("non-null function pointer")(enc, ptr)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    current_block_64 = 1134115459065347084;
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if (*(enc as *const normal_encoding))
                        .isName3
                        .expect("non-null function pointer")(enc, ptr)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize);
                    current_block_64 = 1134115459065347084;
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if (*(enc as *const normal_encoding))
                        .isName4
                        .expect("non-null function pointer")(enc, ptr)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    current_block_64 = 1134115459065347084;
                }
                18 => {
                    *nextTokPtr = ptr.offset(1 as libc::c_int as isize);
                    return crate::xmltok_h::XML_TOK_ENTITY_REF;
                }
                _ => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
            }
            match current_block_64 {
                12579958577185958249 => ptr = ptr.offset(1 as libc::c_int as isize),
                _ => {}
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }

    pub unsafe extern "C" fn little2_scanRef(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        if !(end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
        {
            return crate::xmltok_h::XML_TOK_PARTIAL;
        }
        let mut current_block_33: u64;
        match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
            (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize] as libc::c_int
        } else {
            unicode_byte_type(
                *ptr.offset(1 as libc::c_int as isize),
                *ptr.offset(0 as libc::c_int as isize),
            )
        } {
            29 => {
                if namingBitmap[(((nmstrtPages
                    [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int)
                    << 3 as libc::c_int)
                    + (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                        >> 5 as libc::c_int)) as usize]
                    & (1 as libc::c_uint)
                        << (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            & 0x1f as libc::c_int)
                    == 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                current_block_33 = 8695478541019159461;
            }
            22 | 24 => {
                current_block_33 = 8695478541019159461;
            }
            5 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 2 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(2 as libc::c_int as isize);
                current_block_33 = 18377268871191777778;
            }
            6 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 3 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(3 as libc::c_int as isize);
                current_block_33 = 18377268871191777778;
            }
            7 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(4 as libc::c_int as isize);
                current_block_33 = 18377268871191777778;
            }
            19 => {
                return little2_scanCharRef(
                    enc,
                    ptr.offset(2 as libc::c_int as isize),
                    end,
                    nextTokPtr,
                )
            }
            _ => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
        }
        match current_block_33 {
            8695478541019159461 => ptr = ptr.offset(2 as libc::c_int as isize),
            _ => {}
        }
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            let mut current_block_64: u64;
            match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(1 as libc::c_int as isize),
                    *ptr.offset(0 as libc::c_int as isize),
                )
            } {
                29 => {
                    if namingBitmap[(((namePages
                        [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                        as libc::c_int)
                        << 3 as libc::c_int)
                        + (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            >> 5 as libc::c_int)) as usize]
                        & (1 as libc::c_uint)
                            << (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar
                                as libc::c_int
                                & 0x1f as libc::c_int)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    current_block_64 = 16314533736538551187;
                }
                22 | 24 | 25 | 26 | 27 => {
                    current_block_64 = 16314533736538551187;
                }
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    current_block_64 = 1134115459065347084;
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize);
                    current_block_64 = 1134115459065347084;
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    current_block_64 = 1134115459065347084;
                }
                18 => {
                    *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                    return crate::xmltok_h::XML_TOK_ENTITY_REF;
                }
                _ => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
            }
            match current_block_64 {
                16314533736538551187 => ptr = ptr.offset(2 as libc::c_int as isize),
                _ => {}
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }

    pub unsafe extern "C" fn big2_scanRef(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        if !(end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
        {
            return crate::xmltok_h::XML_TOK_PARTIAL;
        }
        let mut current_block_33: u64;
        match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
            (*(enc as *mut normal_encoding)).type_0
                [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                as libc::c_int
        } else {
            unicode_byte_type(
                *ptr.offset(0 as libc::c_int as isize),
                *ptr.offset(1 as libc::c_int as isize),
            )
        } {
            29 => {
                if namingBitmap[(((nmstrtPages
                    [*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int)
                    << 3 as libc::c_int)
                    + (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                        >> 5 as libc::c_int)) as usize]
                    & (1 as libc::c_uint)
                        << (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            & 0x1f as libc::c_int)
                    == 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                current_block_33 = 11934390993149424930;
            }
            22 | 24 => {
                current_block_33 = 11934390993149424930;
            }
            5 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 2 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(2 as libc::c_int as isize);
                current_block_33 = 18377268871191777778;
            }
            6 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 3 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(3 as libc::c_int as isize);
                current_block_33 = 18377268871191777778;
            }
            7 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(4 as libc::c_int as isize);
                current_block_33 = 18377268871191777778;
            }
            19 => {
                return big2_scanCharRef(
                    enc,
                    ptr.offset(2 as libc::c_int as isize),
                    end,
                    nextTokPtr,
                )
            }
            _ => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
        }
        match current_block_33 {
            11934390993149424930 => ptr = ptr.offset(2 as libc::c_int as isize),
            _ => {}
        }
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            let mut current_block_64: u64;
            match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0
                    [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(0 as libc::c_int as isize),
                    *ptr.offset(1 as libc::c_int as isize),
                )
            } {
                29 => {
                    if namingBitmap[(((namePages
                        [*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as usize]
                        as libc::c_int)
                        << 3 as libc::c_int)
                        + (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            >> 5 as libc::c_int)) as usize]
                        & (1 as libc::c_uint)
                            << (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar
                                as libc::c_int
                                & 0x1f as libc::c_int)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    current_block_64 = 10291975244637513717;
                }
                22 | 24 | 25 | 26 | 27 => {
                    current_block_64 = 10291975244637513717;
                }
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    current_block_64 = 1134115459065347084;
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize);
                    current_block_64 = 1134115459065347084;
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    current_block_64 = 1134115459065347084;
                }
                18 => {
                    *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                    return crate::xmltok_h::XML_TOK_ENTITY_REF;
                }
                _ => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
            }
            match current_block_64 {
                10291975244637513717 => ptr = ptr.offset(2 as libc::c_int as isize),
                _ => {}
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }
    /* ptr points to character following first character of attribute name */
    /* ptr points to character following first character of attribute name */
    /* ptr points to character following first character of attribute name */

    pub unsafe extern "C" fn big2_scanAtts(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        let mut hadColon: libc::c_int = 0 as libc::c_int;
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            let mut current_block_186: u64;
            match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0
                    [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(0 as libc::c_int as isize),
                    *ptr.offset(1 as libc::c_int as isize),
                )
            } {
                29 => {
                    if namingBitmap[(((namePages
                        [*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as usize]
                        as libc::c_int)
                        << 3 as libc::c_int)
                        + (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            >> 5 as libc::c_int)) as usize]
                        & (1 as libc::c_uint)
                            << (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar
                                as libc::c_int
                                & 0x1f as libc::c_int)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    current_block_186 = 17518983136156868271;
                }
                22 | 24 | 25 | 26 | 27 => {
                    current_block_186 = 17518983136156868271;
                }
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    current_block_186 = 11099343707781121639;
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize);
                    current_block_186 = 11099343707781121639;
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    current_block_186 = 11099343707781121639;
                }
                23 => {
                    if hadColon != 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    hadColon = 1 as libc::c_int;
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL;
                    }
                    let mut current_block_64: u64;
                    match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                        == 0 as libc::c_int
                    {
                        (*(enc as *mut normal_encoding)).type_0
                            [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                            as libc::c_int
                    } else {
                        unicode_byte_type(
                            *ptr.offset(0 as libc::c_int as isize),
                            *ptr.offset(1 as libc::c_int as isize),
                        )
                    } {
                        29 => {
                            if namingBitmap[(((nmstrtPages
                                [*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as usize]
                                as libc::c_int)
                                << 3 as libc::c_int)
                                + (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar
                                    as libc::c_int
                                    >> 5 as libc::c_int))
                                as usize]
                                & (1 as libc::c_uint)
                                    << (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar
                                        as libc::c_int
                                        & 0x1f as libc::c_int)
                                == 0
                            {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            current_block_64 = 1844840963447537551;
                        }
                        22 | 24 => {
                            current_block_64 = 1844840963447537551;
                        }
                        5 => {
                            if (end.wrapping_offset_from(ptr) as libc::c_long)
                                < 2 as libc::c_int as libc::c_long
                            {
                                return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                            }
                            if 0 as libc::c_int == 0 {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            ptr = ptr.offset(2 as libc::c_int as isize);
                            current_block_64 = 317151059986244064;
                        }
                        6 => {
                            if (end.wrapping_offset_from(ptr) as libc::c_long)
                                < 3 as libc::c_int as libc::c_long
                            {
                                return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                            }
                            if 0 as libc::c_int == 0 {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            ptr = ptr.offset(3 as libc::c_int as isize);
                            current_block_64 = 317151059986244064;
                        }
                        7 => {
                            if (end.wrapping_offset_from(ptr) as libc::c_long)
                                < 4 as libc::c_int as libc::c_long
                            {
                                return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                            }
                            if 0 as libc::c_int == 0 {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            ptr = ptr.offset(4 as libc::c_int as isize);
                            current_block_64 = 317151059986244064;
                        }
                        _ => {
                            *nextTokPtr = ptr;
                            return crate::xmltok_h::XML_TOK_INVALID;
                        }
                    }
                    match current_block_64 {
                        1844840963447537551 => ptr = ptr.offset(2 as libc::c_int as isize),
                        _ => {}
                    }
                    current_block_186 = 11099343707781121639;
                }
                21 | 9 | 10 => {
                    loop {
                        let mut t: libc::c_int = 0;
                        ptr = ptr.offset(2 as libc::c_int as isize);
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                        {
                            return crate::xmltok_h::XML_TOK_PARTIAL;
                        }
                        t = if *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                            == 0 as libc::c_int
                        {
                            (*(enc as *mut normal_encoding)).type_0
                                [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                                as libc::c_int
                        } else {
                            unicode_byte_type(
                                *ptr.offset(0 as libc::c_int as isize),
                                *ptr.offset(1 as libc::c_int as isize),
                            )
                        };
                        if t == crate::xmltok_impl_h::BT_EQUALS as libc::c_int {
                            break;
                        }
                        match t {
                            21 | 10 | 9 => {}
                            _ => {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                        }
                    }
                    current_block_186 = 17167606947040001567;
                }
                14 => {
                    current_block_186 = 17167606947040001567;
                }
                _ => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
            }
            match current_block_186 {
                17167606947040001567 =>
                /* fall through */
                /* fall through */
                /* fall through */
                {
                    let mut open: libc::c_int = 0;
                    hadColon = 0 as libc::c_int;
                    loop {
                        ptr = ptr.offset(2 as libc::c_int as isize);
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                        {
                            return crate::xmltok_h::XML_TOK_PARTIAL;
                        }
                        open = if *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                            == 0 as libc::c_int
                        {
                            (*(enc as *mut normal_encoding)).type_0
                                [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                                as libc::c_int
                        } else {
                            unicode_byte_type(
                                *ptr.offset(0 as libc::c_int as isize),
                                *ptr.offset(1 as libc::c_int as isize),
                            )
                        };
                        if open == crate::xmltok_impl_h::BT_QUOT as libc::c_int
                            || open == crate::xmltok_impl_h::BT_APOS as libc::c_int
                        {
                            break;
                        }
                        match open {
                            21 | 10 | 9 => {}
                            _ => {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                        }
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    loop
                    /* in attribute value */
                    /* in attribute value */
                    /* in attribute value */
                    {
                        let mut t_0: libc::c_int = 0;
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                        {
                            return crate::xmltok_h::XML_TOK_PARTIAL;
                        }
                        t_0 = if *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                            == 0 as libc::c_int
                        {
                            (*(enc as *mut normal_encoding)).type_0
                                [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                                as libc::c_int
                        } else {
                            unicode_byte_type(
                                *ptr.offset(0 as libc::c_int as isize),
                                *ptr.offset(1 as libc::c_int as isize),
                            )
                        };
                        if t_0 == open {
                            break;
                        }
                        match t_0 {
                            5 => {
                                if (end.wrapping_offset_from(ptr) as libc::c_long)
                                    < 2 as libc::c_int as libc::c_long
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                }
                                ptr = ptr.offset(2 as libc::c_int as isize)
                            }
                            6 => {
                                if (end.wrapping_offset_from(ptr) as libc::c_long)
                                    < 3 as libc::c_int as libc::c_long
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                }
                                ptr = ptr.offset(3 as libc::c_int as isize)
                            }
                            7 => {
                                if (end.wrapping_offset_from(ptr) as libc::c_long)
                                    < 4 as libc::c_int as libc::c_long
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                }
                                ptr = ptr.offset(4 as libc::c_int as isize)
                            }
                            0 | 1 | 8 => {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            3 => {
                                let mut tok: libc::c_int = big2_scanRef(
                                    enc,
                                    ptr.offset(2 as libc::c_int as isize),
                                    end,
                                    &mut ptr,
                                );
                                if tok <= 0 as libc::c_int {
                                    if tok == crate::xmltok_h::XML_TOK_INVALID {
                                        *nextTokPtr = ptr
                                    }
                                    return tok;
                                }
                            }
                            2 => {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            _ => ptr = ptr.offset(2 as libc::c_int as isize),
                        }
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL;
                    }
                    match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                        == 0 as libc::c_int
                    {
                        (*(enc as *mut normal_encoding)).type_0
                            [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                            as libc::c_int
                    } else {
                        unicode_byte_type(
                            *ptr.offset(0 as libc::c_int as isize),
                            *ptr.offset(1 as libc::c_int as isize),
                        )
                    } {
                        21 | 9 | 10 => {
                            loop
                            /* ptr points to closing quote */
                            /* ptr points to closing quote */
                            /* ptr points to closing quote */
                            {
                                ptr = ptr.offset(2 as libc::c_int as isize);
                                if !(end.wrapping_offset_from(ptr) as libc::c_long
                                    >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL;
                                }
                                match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                                    == 0 as libc::c_int
                                {
                                    (*(enc as *mut normal_encoding)).type_0[*ptr
                                        .offset(1 as libc::c_int as isize)
                                        as libc::c_uchar
                                        as usize] as libc::c_int
                                } else {
                                    unicode_byte_type(
                                        *ptr.offset(0 as libc::c_int as isize),
                                        *ptr.offset(1 as libc::c_int as isize),
                                    )
                                } {
                                    29 => {
                                        if namingBitmap[(((nmstrtPages[*ptr
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_uchar
                                            as usize]
                                            as libc::c_int)
                                            << 3 as libc::c_int)
                                            + (*ptr.offset(1 as libc::c_int as isize)
                                                as libc::c_uchar
                                                as libc::c_int
                                                >> 5 as libc::c_int))
                                            as usize]
                                            & (1 as libc::c_uint)
                                                << (*ptr.offset(1 as libc::c_int as isize)
                                                    as libc::c_uchar
                                                    as libc::c_int
                                                    & 0x1f as libc::c_int)
                                            == 0
                                        {
                                            *nextTokPtr = ptr;
                                            return crate::xmltok_h::XML_TOK_INVALID;
                                        }
                                        current_block_186 = 5783548739092765259;
                                        break;
                                    }
                                    22 | 24 => {
                                        current_block_186 = 5783548739092765259;
                                        break;
                                    }
                                    5 => {
                                        if (end.wrapping_offset_from(ptr) as libc::c_long)
                                            < 2 as libc::c_int as libc::c_long
                                        {
                                            return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                        }
                                        if 0 as libc::c_int == 0 {
                                            *nextTokPtr = ptr;
                                            return crate::xmltok_h::XML_TOK_INVALID;
                                        }
                                        ptr = ptr.offset(2 as libc::c_int as isize);
                                        current_block_186 = 11099343707781121639;
                                        break;
                                    }
                                    6 => {
                                        if (end.wrapping_offset_from(ptr) as libc::c_long)
                                            < 3 as libc::c_int as libc::c_long
                                        {
                                            return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                        }
                                        if 0 as libc::c_int == 0 {
                                            *nextTokPtr = ptr;
                                            return crate::xmltok_h::XML_TOK_INVALID;
                                        }
                                        ptr = ptr.offset(3 as libc::c_int as isize);
                                        current_block_186 = 11099343707781121639;
                                        break;
                                    }
                                    7 => {
                                        if (end.wrapping_offset_from(ptr) as libc::c_long)
                                            < 4 as libc::c_int as libc::c_long
                                        {
                                            return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                        }
                                        if 0 as libc::c_int == 0 {
                                            *nextTokPtr = ptr;
                                            return crate::xmltok_h::XML_TOK_INVALID;
                                        }
                                        ptr = ptr.offset(4 as libc::c_int as isize);
                                        current_block_186 = 11099343707781121639;
                                        break;
                                    }
                                    21 | 9 | 10 => {}
                                    11 => {
                                        current_block_186 = 8371071221061937948;
                                        break;
                                    }
                                    17 => {
                                        current_block_186 = 1275279814574597502;
                                        break;
                                    }
                                    _ => {
                                        *nextTokPtr = ptr;
                                        return crate::xmltok_h::XML_TOK_INVALID;
                                    }
                                }
                            }
                            match current_block_186 {
                                8371071221061937948 => {}
                                1275279814574597502 => {}
                                11099343707781121639 => {}
                                _ => {
                                    ptr = ptr.offset(2 as libc::c_int as isize);
                                    current_block_186 = 11099343707781121639;
                                }
                            }
                        }
                        17 => {
                            current_block_186 = 1275279814574597502;
                        }
                        11 => {
                            current_block_186 = 8371071221061937948;
                        }
                        _ => {
                            *nextTokPtr = ptr;
                            return crate::xmltok_h::XML_TOK_INVALID;
                        }
                    }
                    match current_block_186 {
                        11099343707781121639 => {}
                        _ => match current_block_186 {
                            1275279814574597502 => {
                                ptr = ptr.offset(2 as libc::c_int as isize);
                                if !(end.wrapping_offset_from(ptr) as libc::c_long
                                    >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL;
                                }
                                if !(*ptr.offset(0 as libc::c_int as isize) as libc::c_int
                                    == 0 as libc::c_int
                                    && *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                                        == 0x3e as libc::c_int)
                                {
                                    *nextTokPtr = ptr;
                                    return crate::xmltok_h::XML_TOK_INVALID;
                                }
                                *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                                return crate::xmltok_h::XML_TOK_EMPTY_ELEMENT_WITH_ATTS;
                            }
                            _ => {
                                *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                                return crate::xmltok_h::XML_TOK_START_TAG_WITH_ATTS;
                            }
                        },
                    }
                }
                17518983136156868271 => ptr = ptr.offset(2 as libc::c_int as isize),
                _ => {}
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }

    pub unsafe extern "C" fn little2_scanAtts(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        let mut hadColon: libc::c_int = 0 as libc::c_int;
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            let mut current_block_186: u64;
            match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(1 as libc::c_int as isize),
                    *ptr.offset(0 as libc::c_int as isize),
                )
            } {
                29 => {
                    if namingBitmap[(((namePages
                        [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                        as libc::c_int)
                        << 3 as libc::c_int)
                        + (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            >> 5 as libc::c_int)) as usize]
                        & (1 as libc::c_uint)
                            << (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar
                                as libc::c_int
                                & 0x1f as libc::c_int)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    current_block_186 = 13609164463425058869;
                }
                22 | 24 | 25 | 26 | 27 => {
                    current_block_186 = 13609164463425058869;
                }
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    current_block_186 = 11099343707781121639;
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize);
                    current_block_186 = 11099343707781121639;
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    current_block_186 = 11099343707781121639;
                }
                23 => {
                    if hadColon != 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    hadColon = 1 as libc::c_int;
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL;
                    }
                    let mut current_block_64: u64;
                    match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                        == 0 as libc::c_int
                    {
                        (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                            as libc::c_int
                    } else {
                        unicode_byte_type(
                            *ptr.offset(1 as libc::c_int as isize),
                            *ptr.offset(0 as libc::c_int as isize),
                        )
                    } {
                        29 => {
                            if namingBitmap[(((nmstrtPages
                                [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                                as libc::c_int)
                                << 3 as libc::c_int)
                                + (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar
                                    as libc::c_int
                                    >> 5 as libc::c_int))
                                as usize]
                                & (1 as libc::c_uint)
                                    << (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar
                                        as libc::c_int
                                        & 0x1f as libc::c_int)
                                == 0
                            {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            current_block_64 = 16848571710846909653;
                        }
                        22 | 24 => {
                            current_block_64 = 16848571710846909653;
                        }
                        5 => {
                            if (end.wrapping_offset_from(ptr) as libc::c_long)
                                < 2 as libc::c_int as libc::c_long
                            {
                                return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                            }
                            if 0 as libc::c_int == 0 {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            ptr = ptr.offset(2 as libc::c_int as isize);
                            current_block_64 = 317151059986244064;
                        }
                        6 => {
                            if (end.wrapping_offset_from(ptr) as libc::c_long)
                                < 3 as libc::c_int as libc::c_long
                            {
                                return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                            }
                            if 0 as libc::c_int == 0 {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            ptr = ptr.offset(3 as libc::c_int as isize);
                            current_block_64 = 317151059986244064;
                        }
                        7 => {
                            if (end.wrapping_offset_from(ptr) as libc::c_long)
                                < 4 as libc::c_int as libc::c_long
                            {
                                return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                            }
                            if 0 as libc::c_int == 0 {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            ptr = ptr.offset(4 as libc::c_int as isize);
                            current_block_64 = 317151059986244064;
                        }
                        _ => {
                            *nextTokPtr = ptr;
                            return crate::xmltok_h::XML_TOK_INVALID;
                        }
                    }
                    match current_block_64 {
                        16848571710846909653 => ptr = ptr.offset(2 as libc::c_int as isize),
                        _ => {}
                    }
                    current_block_186 = 11099343707781121639;
                }
                21 | 9 | 10 => {
                    loop {
                        let mut t: libc::c_int = 0;
                        ptr = ptr.offset(2 as libc::c_int as isize);
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                        {
                            return crate::xmltok_h::XML_TOK_PARTIAL;
                        }
                        t = if *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                            == 0 as libc::c_int
                        {
                            (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                                as libc::c_int
                        } else {
                            unicode_byte_type(
                                *ptr.offset(1 as libc::c_int as isize),
                                *ptr.offset(0 as libc::c_int as isize),
                            )
                        };
                        if t == crate::xmltok_impl_h::BT_EQUALS as libc::c_int {
                            break;
                        }
                        match t {
                            21 | 10 | 9 => {}
                            _ => {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                        }
                    }
                    current_block_186 = 17167606947040001567;
                }
                14 => {
                    current_block_186 = 17167606947040001567;
                }
                _ => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
            }
            match current_block_186 {
                17167606947040001567 => {
                    let mut open: libc::c_int = 0;
                    hadColon = 0 as libc::c_int;
                    loop {
                        ptr = ptr.offset(2 as libc::c_int as isize);
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                        {
                            return crate::xmltok_h::XML_TOK_PARTIAL;
                        }
                        open = if *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                            == 0 as libc::c_int
                        {
                            (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                                as libc::c_int
                        } else {
                            unicode_byte_type(
                                *ptr.offset(1 as libc::c_int as isize),
                                *ptr.offset(0 as libc::c_int as isize),
                            )
                        };
                        if open == crate::xmltok_impl_h::BT_QUOT as libc::c_int
                            || open == crate::xmltok_impl_h::BT_APOS as libc::c_int
                        {
                            break;
                        }
                        match open {
                            21 | 10 | 9 => {}
                            _ => {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                        }
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    loop {
                        let mut t_0: libc::c_int = 0;
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                        {
                            return crate::xmltok_h::XML_TOK_PARTIAL;
                        }
                        t_0 = if *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                            == 0 as libc::c_int
                        {
                            (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                                as libc::c_int
                        } else {
                            unicode_byte_type(
                                *ptr.offset(1 as libc::c_int as isize),
                                *ptr.offset(0 as libc::c_int as isize),
                            )
                        };
                        if t_0 == open {
                            break;
                        }
                        match t_0 {
                            5 => {
                                if (end.wrapping_offset_from(ptr) as libc::c_long)
                                    < 2 as libc::c_int as libc::c_long
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                }
                                ptr = ptr.offset(2 as libc::c_int as isize)
                            }
                            6 => {
                                if (end.wrapping_offset_from(ptr) as libc::c_long)
                                    < 3 as libc::c_int as libc::c_long
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                }
                                ptr = ptr.offset(3 as libc::c_int as isize)
                            }
                            7 => {
                                if (end.wrapping_offset_from(ptr) as libc::c_long)
                                    < 4 as libc::c_int as libc::c_long
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                }
                                ptr = ptr.offset(4 as libc::c_int as isize)
                            }
                            0 | 1 | 8 => {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            3 => {
                                let mut tok: libc::c_int = little2_scanRef(
                                    enc,
                                    ptr.offset(2 as libc::c_int as isize),
                                    end,
                                    &mut ptr,
                                );
                                if tok <= 0 as libc::c_int {
                                    if tok == crate::xmltok_h::XML_TOK_INVALID {
                                        *nextTokPtr = ptr
                                    }
                                    return tok;
                                }
                            }
                            2 => {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            _ => ptr = ptr.offset(2 as libc::c_int as isize),
                        }
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL;
                    }
                    match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                        == 0 as libc::c_int
                    {
                        (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                            as libc::c_int
                    } else {
                        unicode_byte_type(
                            *ptr.offset(1 as libc::c_int as isize),
                            *ptr.offset(0 as libc::c_int as isize),
                        )
                    } {
                        21 | 9 | 10 => {
                            loop {
                                ptr = ptr.offset(2 as libc::c_int as isize);
                                if !(end.wrapping_offset_from(ptr) as libc::c_long
                                    >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL;
                                }
                                match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                                    == 0 as libc::c_int
                                {
                                    (*(enc as *mut normal_encoding)).type_0
                                        [*ptr as libc::c_uchar as usize]
                                        as libc::c_int
                                } else {
                                    unicode_byte_type(
                                        *ptr.offset(1 as libc::c_int as isize),
                                        *ptr.offset(0 as libc::c_int as isize),
                                    )
                                } {
                                    29 => {
                                        if namingBitmap[(((nmstrtPages[*ptr
                                            .offset(1 as libc::c_int as isize)
                                            as libc::c_uchar
                                            as usize]
                                            as libc::c_int)
                                            << 3 as libc::c_int)
                                            + (*ptr.offset(0 as libc::c_int as isize)
                                                as libc::c_uchar
                                                as libc::c_int
                                                >> 5 as libc::c_int))
                                            as usize]
                                            & (1 as libc::c_uint)
                                                << (*ptr.offset(0 as libc::c_int as isize)
                                                    as libc::c_uchar
                                                    as libc::c_int
                                                    & 0x1f as libc::c_int)
                                            == 0
                                        {
                                            *nextTokPtr = ptr;
                                            return crate::xmltok_h::XML_TOK_INVALID;
                                        }
                                        current_block_186 = 2518365774060181242;
                                        break;
                                    }
                                    22 | 24 => {
                                        current_block_186 = 2518365774060181242;
                                        break;
                                    }
                                    5 => {
                                        if (end.wrapping_offset_from(ptr) as libc::c_long)
                                            < 2 as libc::c_int as libc::c_long
                                        {
                                            return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                        }
                                        if 0 as libc::c_int == 0 {
                                            *nextTokPtr = ptr;
                                            return crate::xmltok_h::XML_TOK_INVALID;
                                        }
                                        ptr = ptr.offset(2 as libc::c_int as isize);
                                        current_block_186 = 11099343707781121639;
                                        break;
                                    }
                                    6 => {
                                        if (end.wrapping_offset_from(ptr) as libc::c_long)
                                            < 3 as libc::c_int as libc::c_long
                                        {
                                            return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                        }
                                        if 0 as libc::c_int == 0 {
                                            *nextTokPtr = ptr;
                                            return crate::xmltok_h::XML_TOK_INVALID;
                                        }
                                        ptr = ptr.offset(3 as libc::c_int as isize);
                                        current_block_186 = 11099343707781121639;
                                        break;
                                    }
                                    7 => {
                                        if (end.wrapping_offset_from(ptr) as libc::c_long)
                                            < 4 as libc::c_int as libc::c_long
                                        {
                                            return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                        }
                                        if 0 as libc::c_int == 0 {
                                            *nextTokPtr = ptr;
                                            return crate::xmltok_h::XML_TOK_INVALID;
                                        }
                                        ptr = ptr.offset(4 as libc::c_int as isize);
                                        current_block_186 = 11099343707781121639;
                                        break;
                                    }
                                    21 | 9 | 10 => {}
                                    11 => {
                                        current_block_186 = 6641879004945384064;
                                        break;
                                    }
                                    17 => {
                                        current_block_186 = 6487149160532398276;
                                        break;
                                    }
                                    _ => {
                                        *nextTokPtr = ptr;
                                        return crate::xmltok_h::XML_TOK_INVALID;
                                    }
                                }
                            }
                            match current_block_186 {
                                6641879004945384064 => {}
                                6487149160532398276 => {}
                                11099343707781121639 => {}
                                _ => {
                                    ptr = ptr.offset(2 as libc::c_int as isize);
                                    current_block_186 = 11099343707781121639;
                                }
                            }
                        }
                        17 => {
                            current_block_186 = 6487149160532398276;
                        }
                        11 => {
                            current_block_186 = 6641879004945384064;
                        }
                        _ => {
                            *nextTokPtr = ptr;
                            return crate::xmltok_h::XML_TOK_INVALID;
                        }
                    }
                    match current_block_186 {
                        11099343707781121639 => {}
                        _ => match current_block_186 {
                            6487149160532398276 => {
                                ptr = ptr.offset(2 as libc::c_int as isize);
                                if !(end.wrapping_offset_from(ptr) as libc::c_long
                                    >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL;
                                }
                                if !(*ptr.offset(1 as libc::c_int as isize) as libc::c_int
                                    == 0 as libc::c_int
                                    && *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                                        == 0x3e as libc::c_int)
                                {
                                    *nextTokPtr = ptr;
                                    return crate::xmltok_h::XML_TOK_INVALID;
                                }
                                *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                                return crate::xmltok_h::XML_TOK_EMPTY_ELEMENT_WITH_ATTS;
                            }
                            _ => {
                                *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                                return crate::xmltok_h::XML_TOK_START_TAG_WITH_ATTS;
                            }
                        },
                    }
                }
                13609164463425058869 => ptr = ptr.offset(2 as libc::c_int as isize),
                _ => {}
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }

    pub unsafe extern "C" fn normal_scanAtts(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        let mut hadColon: libc::c_int = 0 as libc::c_int;
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long
        {
            let mut current_block_186: u64;
            match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                as libc::c_int
            {
                29 => {
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    current_block_186 = 1328744425620679301;
                }
                22 | 24 | 25 | 26 | 27 => {
                    current_block_186 = 1328744425620679301;
                }
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if (*(enc as *const normal_encoding))
                        .isName2
                        .expect("non-null function pointer")(enc, ptr)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    current_block_186 = 11099343707781121639;
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if (*(enc as *const normal_encoding))
                        .isName3
                        .expect("non-null function pointer")(enc, ptr)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize);
                    current_block_186 = 11099343707781121639;
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if (*(enc as *const normal_encoding))
                        .isName4
                        .expect("non-null function pointer")(enc, ptr)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    current_block_186 = 11099343707781121639;
                }
                23 => {
                    if hadColon != 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    hadColon = 1 as libc::c_int;
                    ptr = ptr.offset(1 as libc::c_int as isize);
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL;
                    }
                    let mut current_block_64: u64;
                    match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                        as libc::c_int
                    {
                        29 => {
                            if 0 as libc::c_int == 0 {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            current_block_64 = 13714184482889841412;
                        }
                        22 | 24 => {
                            current_block_64 = 13714184482889841412;
                        }
                        5 => {
                            if (end.wrapping_offset_from(ptr) as libc::c_long)
                                < 2 as libc::c_int as libc::c_long
                            {
                                return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                            }
                            if (*(enc as *const normal_encoding))
                                .isNmstrt2
                                .expect("non-null function pointer")(
                                enc, ptr
                            ) == 0
                            {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            ptr = ptr.offset(2 as libc::c_int as isize);
                            current_block_64 = 317151059986244064;
                        }
                        6 => {
                            if (end.wrapping_offset_from(ptr) as libc::c_long)
                                < 3 as libc::c_int as libc::c_long
                            {
                                return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                            }
                            if (*(enc as *const normal_encoding))
                                .isNmstrt3
                                .expect("non-null function pointer")(
                                enc, ptr
                            ) == 0
                            {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            ptr = ptr.offset(3 as libc::c_int as isize);
                            current_block_64 = 317151059986244064;
                        }
                        7 => {
                            if (end.wrapping_offset_from(ptr) as libc::c_long)
                                < 4 as libc::c_int as libc::c_long
                            {
                                return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                            }
                            if (*(enc as *const normal_encoding))
                                .isNmstrt4
                                .expect("non-null function pointer")(
                                enc, ptr
                            ) == 0
                            {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            ptr = ptr.offset(4 as libc::c_int as isize);
                            current_block_64 = 317151059986244064;
                        }
                        _ => {
                            *nextTokPtr = ptr;
                            return crate::xmltok_h::XML_TOK_INVALID;
                        }
                    }
                    match current_block_64 {
                        13714184482889841412 => ptr = ptr.offset(1 as libc::c_int as isize),
                        _ => {}
                    }
                    current_block_186 = 11099343707781121639;
                }
                21 | 9 | 10 => {
                    loop {
                        let mut t: libc::c_int = 0;
                        ptr = ptr.offset(1 as libc::c_int as isize);
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                        {
                            return crate::xmltok_h::XML_TOK_PARTIAL;
                        }
                        t = (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                            as libc::c_int;
                        if t == crate::xmltok_impl_h::BT_EQUALS as libc::c_int {
                            break;
                        }
                        match t {
                            21 | 10 | 9 => {}
                            _ => {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                        }
                    }
                    current_block_186 = 17167606947040001567;
                }
                14 => {
                    current_block_186 = 17167606947040001567;
                }
                _ => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
            }
            match current_block_186 {
                17167606947040001567 => {
                    let mut open: libc::c_int = 0;
                    hadColon = 0 as libc::c_int;
                    loop {
                        ptr = ptr.offset(1 as libc::c_int as isize);
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                        {
                            return crate::xmltok_h::XML_TOK_PARTIAL;
                        }
                        open = (*(enc as *mut normal_encoding)).type_0
                            [*ptr as libc::c_uchar as usize]
                            as libc::c_int;
                        if open == crate::xmltok_impl_h::BT_QUOT as libc::c_int
                            || open == crate::xmltok_impl_h::BT_APOS as libc::c_int
                        {
                            break;
                        }
                        match open {
                            21 | 10 | 9 => {}
                            _ => {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                        }
                    }
                    ptr = ptr.offset(1 as libc::c_int as isize);
                    loop {
                        let mut t_0: libc::c_int = 0;
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                        {
                            return crate::xmltok_h::XML_TOK_PARTIAL;
                        }
                        t_0 = (*(enc as *mut normal_encoding)).type_0
                            [*ptr as libc::c_uchar as usize]
                            as libc::c_int;
                        if t_0 == open {
                            break;
                        }
                        match t_0 {
                            5 => {
                                if (end.wrapping_offset_from(ptr) as libc::c_long)
                                    < 2 as libc::c_int as libc::c_long
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                }
                                if (*(enc as *const normal_encoding))
                                    .isInvalid2
                                    .expect("non-null function pointer")(
                                    enc, ptr
                                ) != 0
                                {
                                    *nextTokPtr = ptr;
                                    return crate::xmltok_h::XML_TOK_INVALID;
                                }
                                ptr = ptr.offset(2 as libc::c_int as isize)
                            }
                            6 => {
                                if (end.wrapping_offset_from(ptr) as libc::c_long)
                                    < 3 as libc::c_int as libc::c_long
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                }
                                if (*(enc as *const normal_encoding))
                                    .isInvalid3
                                    .expect("non-null function pointer")(
                                    enc, ptr
                                ) != 0
                                {
                                    *nextTokPtr = ptr;
                                    return crate::xmltok_h::XML_TOK_INVALID;
                                }
                                ptr = ptr.offset(3 as libc::c_int as isize)
                            }
                            7 => {
                                if (end.wrapping_offset_from(ptr) as libc::c_long)
                                    < 4 as libc::c_int as libc::c_long
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                }
                                if (*(enc as *const normal_encoding))
                                    .isInvalid4
                                    .expect("non-null function pointer")(
                                    enc, ptr
                                ) != 0
                                {
                                    *nextTokPtr = ptr;
                                    return crate::xmltok_h::XML_TOK_INVALID;
                                }
                                ptr = ptr.offset(4 as libc::c_int as isize)
                            }
                            0 | 1 | 8 => {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            3 => {
                                let mut tok: libc::c_int = normal_scanRef(
                                    enc,
                                    ptr.offset(1 as libc::c_int as isize),
                                    end,
                                    &mut ptr,
                                );
                                if tok <= 0 as libc::c_int {
                                    if tok == crate::xmltok_h::XML_TOK_INVALID {
                                        *nextTokPtr = ptr
                                    }
                                    return tok;
                                }
                            }
                            2 => {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            _ => ptr = ptr.offset(1 as libc::c_int as isize),
                        }
                    }
                    ptr = ptr.offset(1 as libc::c_int as isize);
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL;
                    }
                    match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                        as libc::c_int
                    {
                        21 | 9 | 10 => {
                            loop {
                                ptr = ptr.offset(1 as libc::c_int as isize);
                                if !(end.wrapping_offset_from(ptr) as libc::c_long
                                    >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL;
                                }
                                match (*(enc as *mut normal_encoding)).type_0
                                    [*ptr as libc::c_uchar as usize]
                                    as libc::c_int
                                {
                                    29 => {
                                        if 0 as libc::c_int == 0 {
                                            *nextTokPtr = ptr;
                                            return crate::xmltok_h::XML_TOK_INVALID;
                                        }
                                        current_block_186 = 10484988340598120725;
                                        break;
                                    }
                                    22 | 24 => {
                                        current_block_186 = 10484988340598120725;
                                        break;
                                    }
                                    5 => {
                                        if (end.wrapping_offset_from(ptr) as libc::c_long)
                                            < 2 as libc::c_int as libc::c_long
                                        {
                                            return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                        }
                                        if (*(enc as *const normal_encoding))
                                            .isNmstrt2
                                            .expect("non-null function pointer")(
                                            enc, ptr
                                        ) == 0
                                        {
                                            *nextTokPtr = ptr;
                                            return crate::xmltok_h::XML_TOK_INVALID;
                                        }
                                        ptr = ptr.offset(2 as libc::c_int as isize);
                                        current_block_186 = 11099343707781121639;
                                        break;
                                    }
                                    6 => {
                                        if (end.wrapping_offset_from(ptr) as libc::c_long)
                                            < 3 as libc::c_int as libc::c_long
                                        {
                                            return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                        }
                                        if (*(enc as *const normal_encoding))
                                            .isNmstrt3
                                            .expect("non-null function pointer")(
                                            enc, ptr
                                        ) == 0
                                        {
                                            *nextTokPtr = ptr;
                                            return crate::xmltok_h::XML_TOK_INVALID;
                                        }
                                        ptr = ptr.offset(3 as libc::c_int as isize);
                                        current_block_186 = 11099343707781121639;
                                        break;
                                    }
                                    7 => {
                                        if (end.wrapping_offset_from(ptr) as libc::c_long)
                                            < 4 as libc::c_int as libc::c_long
                                        {
                                            return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                        }
                                        if (*(enc as *const normal_encoding))
                                            .isNmstrt4
                                            .expect("non-null function pointer")(
                                            enc, ptr
                                        ) == 0
                                        {
                                            *nextTokPtr = ptr;
                                            return crate::xmltok_h::XML_TOK_INVALID;
                                        }
                                        ptr = ptr.offset(4 as libc::c_int as isize);
                                        current_block_186 = 11099343707781121639;
                                        break;
                                    }
                                    21 | 9 | 10 => {}
                                    11 => {
                                        current_block_186 = 359750854795906639;
                                        break;
                                    }
                                    17 => {
                                        current_block_186 = 13746452913673866366;
                                        break;
                                    }
                                    _ => {
                                        *nextTokPtr = ptr;
                                        return crate::xmltok_h::XML_TOK_INVALID;
                                    }
                                }
                            }
                            match current_block_186 {
                                359750854795906639 => {}
                                13746452913673866366 => {}
                                11099343707781121639 => {}
                                _ => {
                                    ptr = ptr.offset(1 as libc::c_int as isize);
                                    current_block_186 = 11099343707781121639;
                                }
                            }
                        }
                        17 => {
                            current_block_186 = 13746452913673866366;
                        }
                        11 => {
                            current_block_186 = 359750854795906639;
                        }
                        _ => {
                            *nextTokPtr = ptr;
                            return crate::xmltok_h::XML_TOK_INVALID;
                        }
                    }
                    match current_block_186 {
                        11099343707781121639 => {}
                        _ => match current_block_186 {
                            13746452913673866366 => {
                                ptr = ptr.offset(1 as libc::c_int as isize);
                                if !(end.wrapping_offset_from(ptr) as libc::c_long
                                    >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL;
                                }
                                if !(*ptr as libc::c_int == 0x3e as libc::c_int) {
                                    *nextTokPtr = ptr;
                                    return crate::xmltok_h::XML_TOK_INVALID;
                                }
                                *nextTokPtr = ptr.offset(1 as libc::c_int as isize);
                                return crate::xmltok_h::XML_TOK_EMPTY_ELEMENT_WITH_ATTS;
                            }
                            _ => {
                                *nextTokPtr = ptr.offset(1 as libc::c_int as isize);
                                return crate::xmltok_h::XML_TOK_START_TAG_WITH_ATTS;
                            }
                        },
                    }
                }
                1328744425620679301 => ptr = ptr.offset(1 as libc::c_int as isize),
                _ => {}
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }
    /* ptr points to character following "<" */
    /* ptr points to character following "<" */
    /* ptr points to character following "<" */

    pub unsafe extern "C" fn normal_scanLt(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        let mut hadColon: libc::c_int = 0;
        if !(end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
        {
            return crate::xmltok_h::XML_TOK_PARTIAL;
        }
        let mut current_block_45: u64;
        match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize] as libc::c_int
        {
            29 => {
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                current_block_45 = 2093567751087104139;
            }
            22 | 24 => {
                current_block_45 = 2093567751087104139;
            }
            5 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 2 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if (*(enc as *const normal_encoding))
                    .isNmstrt2
                    .expect("non-null function pointer")(enc, ptr)
                    == 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(2 as libc::c_int as isize);
                current_block_45 = 1847472278776910194;
            }
            6 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 3 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if (*(enc as *const normal_encoding))
                    .isNmstrt3
                    .expect("non-null function pointer")(enc, ptr)
                    == 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(3 as libc::c_int as isize);
                current_block_45 = 1847472278776910194;
            }
            7 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if (*(enc as *const normal_encoding))
                    .isNmstrt4
                    .expect("non-null function pointer")(enc, ptr)
                    == 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(4 as libc::c_int as isize);
                current_block_45 = 1847472278776910194;
            }
            16 => {
                ptr = ptr.offset(1 as libc::c_int as isize);
                if !(end.wrapping_offset_from(ptr) as libc::c_long
                    >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL;
                }
                match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                    as libc::c_int
                {
                    27 => {
                        return normal_scanComment(
                            enc,
                            ptr.offset(1 as libc::c_int as isize),
                            end,
                            nextTokPtr,
                        )
                    }
                    20 => {
                        return normal_scanCdataSection(
                            enc,
                            ptr.offset(1 as libc::c_int as isize),
                            end,
                            nextTokPtr,
                        )
                    }
                    _ => {}
                }
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
            15 => {
                return normal_scanPi(enc, ptr.offset(1 as libc::c_int as isize), end, nextTokPtr)
            }
            17 => {
                return normal_scanEndTag(
                    enc,
                    ptr.offset(1 as libc::c_int as isize),
                    end,
                    nextTokPtr,
                )
            }
            _ => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
        }
        match current_block_45 {
            2093567751087104139 => ptr = ptr.offset(1 as libc::c_int as isize),
            _ => {}
        }
        hadColon = 0 as libc::c_int;
        /* we have a start-tag */
        /* we have a start-tag */
        /* we have a start-tag */
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long
        {
            let mut current_block_161: u64;
            match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                as libc::c_int
            {
                29 => {
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    current_block_161 = 9017017852254768106;
                }
                22 | 24 | 25 | 26 | 27 => {
                    current_block_161 = 9017017852254768106;
                }
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if (*(enc as *const normal_encoding))
                        .isName2
                        .expect("non-null function pointer")(enc, ptr)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    current_block_161 = 12655303178690906525;
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if (*(enc as *const normal_encoding))
                        .isName3
                        .expect("non-null function pointer")(enc, ptr)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize);
                    current_block_161 = 12655303178690906525;
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if (*(enc as *const normal_encoding))
                        .isName4
                        .expect("non-null function pointer")(enc, ptr)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    current_block_161 = 12655303178690906525;
                }
                23 => {
                    if hadColon != 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    hadColon = 1 as libc::c_int;
                    ptr = ptr.offset(1 as libc::c_int as isize);
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL;
                    }
                    let mut current_block_112: u64;
                    match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                        as libc::c_int
                    {
                        29 => {
                            if 0 as libc::c_int == 0 {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            current_block_112 = 15659092796775618263;
                        }
                        22 | 24 => {
                            current_block_112 = 15659092796775618263;
                        }
                        5 => {
                            if (end.wrapping_offset_from(ptr) as libc::c_long)
                                < 2 as libc::c_int as libc::c_long
                            {
                                return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                            }
                            if (*(enc as *const normal_encoding))
                                .isNmstrt2
                                .expect("non-null function pointer")(
                                enc, ptr
                            ) == 0
                            {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            ptr = ptr.offset(2 as libc::c_int as isize);
                            current_block_112 = 2463987395154258233;
                        }
                        6 => {
                            if (end.wrapping_offset_from(ptr) as libc::c_long)
                                < 3 as libc::c_int as libc::c_long
                            {
                                return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                            }
                            if (*(enc as *const normal_encoding))
                                .isNmstrt3
                                .expect("non-null function pointer")(
                                enc, ptr
                            ) == 0
                            {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            ptr = ptr.offset(3 as libc::c_int as isize);
                            current_block_112 = 2463987395154258233;
                        }
                        7 => {
                            if (end.wrapping_offset_from(ptr) as libc::c_long)
                                < 4 as libc::c_int as libc::c_long
                            {
                                return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                            }
                            if (*(enc as *const normal_encoding))
                                .isNmstrt4
                                .expect("non-null function pointer")(
                                enc, ptr
                            ) == 0
                            {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            ptr = ptr.offset(4 as libc::c_int as isize);
                            current_block_112 = 2463987395154258233;
                        }
                        _ => {
                            *nextTokPtr = ptr;
                            return crate::xmltok_h::XML_TOK_INVALID;
                        }
                    }
                    match current_block_112 {
                        15659092796775618263 => ptr = ptr.offset(1 as libc::c_int as isize),
                        _ => {}
                    }
                    current_block_161 = 12655303178690906525;
                }
                21 | 9 | 10 => {
                    ptr = ptr.offset(1 as libc::c_int as isize);
                    loop {
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                        {
                            current_block_161 = 13000670339742628194;
                            break;
                        }
                        match (*(enc as *mut normal_encoding)).type_0
                            [*ptr as libc::c_uchar as usize]
                            as libc::c_int
                        {
                            29 => {
                                if 0 as libc::c_int == 0 {
                                    *nextTokPtr = ptr;
                                    return crate::xmltok_h::XML_TOK_INVALID;
                                }
                                current_block_161 = 5850705615406568950;
                            }
                            22 | 24 => {
                                current_block_161 = 5850705615406568950;
                            }
                            5 => {
                                if (end.wrapping_offset_from(ptr) as libc::c_long)
                                    < 2 as libc::c_int as libc::c_long
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                }
                                if (*(enc as *const normal_encoding))
                                    .isNmstrt2
                                    .expect("non-null function pointer")(
                                    enc, ptr
                                ) == 0
                                {
                                    *nextTokPtr = ptr;
                                    return crate::xmltok_h::XML_TOK_INVALID;
                                }
                                ptr = ptr.offset(2 as libc::c_int as isize);
                                current_block_161 = 7999014830792590863;
                            }
                            6 => {
                                if (end.wrapping_offset_from(ptr) as libc::c_long)
                                    < 3 as libc::c_int as libc::c_long
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                }
                                if (*(enc as *const normal_encoding))
                                    .isNmstrt3
                                    .expect("non-null function pointer")(
                                    enc, ptr
                                ) == 0
                                {
                                    *nextTokPtr = ptr;
                                    return crate::xmltok_h::XML_TOK_INVALID;
                                }
                                ptr = ptr.offset(3 as libc::c_int as isize);
                                current_block_161 = 7999014830792590863;
                            }
                            7 => {
                                if (end.wrapping_offset_from(ptr) as libc::c_long)
                                    < 4 as libc::c_int as libc::c_long
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                }
                                if (*(enc as *const normal_encoding))
                                    .isNmstrt4
                                    .expect("non-null function pointer")(
                                    enc, ptr
                                ) == 0
                                {
                                    *nextTokPtr = ptr;
                                    return crate::xmltok_h::XML_TOK_INVALID;
                                }
                                ptr = ptr.offset(4 as libc::c_int as isize);
                                current_block_161 = 7999014830792590863;
                            }
                            11 => {
                                current_block_161 = 11968577662814546452;
                                break;
                            }
                            17 => {
                                current_block_161 = 885266785391146906;
                                break;
                            }
                            21 | 9 | 10 => {
                                ptr = ptr.offset(1 as libc::c_int as isize);
                                continue;
                            }
                            _ => {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                        }
                        match current_block_161 {
                            5850705615406568950 => ptr = ptr.offset(1 as libc::c_int as isize),
                            _ => {}
                        }
                        return normal_scanAtts(enc, ptr, end, nextTokPtr);
                    }
                    match current_block_161 {
                        11968577662814546452 => {}
                        885266785391146906 => {}
                        _ => return crate::xmltok_h::XML_TOK_PARTIAL,
                    }
                }
                11 => {
                    current_block_161 = 11968577662814546452;
                }
                17 => {
                    current_block_161 = 885266785391146906;
                }
                _ => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
            }
            match current_block_161 {
                885266785391146906 => {
                    ptr = ptr.offset(1 as libc::c_int as isize);
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL;
                    }
                    if !(*ptr as libc::c_int == 0x3e as libc::c_int) {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    *nextTokPtr = ptr.offset(1 as libc::c_int as isize);
                    return crate::xmltok_h::XML_TOK_EMPTY_ELEMENT_NO_ATTS;
                }
                11968577662814546452 => {
                    *nextTokPtr = ptr.offset(1 as libc::c_int as isize);
                    return crate::xmltok_h::XML_TOK_START_TAG_NO_ATTS;
                }
                9017017852254768106 => ptr = ptr.offset(1 as libc::c_int as isize),
                _ => {}
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }

    pub unsafe extern "C" fn big2_scanLt(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        let mut hadColon: libc::c_int = 0;
        if !(end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
        {
            return crate::xmltok_h::XML_TOK_PARTIAL;
        }
        let mut current_block_45: u64;
        match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
            (*(enc as *mut normal_encoding)).type_0
                [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                as libc::c_int
        } else {
            unicode_byte_type(
                *ptr.offset(0 as libc::c_int as isize),
                *ptr.offset(1 as libc::c_int as isize),
            )
        } {
            29 => {
                if namingBitmap[(((nmstrtPages
                    [*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int)
                    << 3 as libc::c_int)
                    + (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                        >> 5 as libc::c_int)) as usize]
                    & (1 as libc::c_uint)
                        << (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            & 0x1f as libc::c_int)
                    == 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                current_block_45 = 3982799367787197894;
            }
            22 | 24 => {
                current_block_45 = 3982799367787197894;
            }
            5 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 2 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(2 as libc::c_int as isize);
                current_block_45 = 1847472278776910194;
            }
            6 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 3 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(3 as libc::c_int as isize);
                current_block_45 = 1847472278776910194;
            }
            7 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(4 as libc::c_int as isize);
                current_block_45 = 1847472278776910194;
            }
            16 => {
                ptr = ptr.offset(2 as libc::c_int as isize);
                if !(end.wrapping_offset_from(ptr) as libc::c_long
                    >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL;
                }
                match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                    (*(enc as *mut normal_encoding)).type_0
                        [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                        as libc::c_int
                } else {
                    unicode_byte_type(
                        *ptr.offset(0 as libc::c_int as isize),
                        *ptr.offset(1 as libc::c_int as isize),
                    )
                } {
                    27 => {
                        return big2_scanComment(
                            enc,
                            ptr.offset(2 as libc::c_int as isize),
                            end,
                            nextTokPtr,
                        )
                    }
                    20 => {
                        return big2_scanCdataSection(
                            enc,
                            ptr.offset(2 as libc::c_int as isize),
                            end,
                            nextTokPtr,
                        )
                    }
                    _ => {}
                }
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
            15 => return big2_scanPi(enc, ptr.offset(2 as libc::c_int as isize), end, nextTokPtr),
            17 => {
                return big2_scanEndTag(enc, ptr.offset(2 as libc::c_int as isize), end, nextTokPtr)
            }
            _ => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
        }
        match current_block_45 {
            3982799367787197894 => ptr = ptr.offset(2 as libc::c_int as isize),
            _ => {}
        }
        hadColon = 0 as libc::c_int;
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            let mut current_block_161: u64;
            match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0
                    [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(0 as libc::c_int as isize),
                    *ptr.offset(1 as libc::c_int as isize),
                )
            } {
                29 => {
                    if namingBitmap[(((namePages
                        [*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as usize]
                        as libc::c_int)
                        << 3 as libc::c_int)
                        + (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            >> 5 as libc::c_int)) as usize]
                        & (1 as libc::c_uint)
                            << (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar
                                as libc::c_int
                                & 0x1f as libc::c_int)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    current_block_161 = 14827193857955628413;
                }
                22 | 24 | 25 | 26 | 27 => {
                    current_block_161 = 14827193857955628413;
                }
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    current_block_161 = 12655303178690906525;
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize);
                    current_block_161 = 12655303178690906525;
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    current_block_161 = 12655303178690906525;
                }
                23 => {
                    if hadColon != 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    hadColon = 1 as libc::c_int;
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL;
                    }
                    let mut current_block_112: u64;
                    match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                        == 0 as libc::c_int
                    {
                        (*(enc as *mut normal_encoding)).type_0
                            [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                            as libc::c_int
                    } else {
                        unicode_byte_type(
                            *ptr.offset(0 as libc::c_int as isize),
                            *ptr.offset(1 as libc::c_int as isize),
                        )
                    } {
                        29 => {
                            if namingBitmap[(((nmstrtPages
                                [*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as usize]
                                as libc::c_int)
                                << 3 as libc::c_int)
                                + (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar
                                    as libc::c_int
                                    >> 5 as libc::c_int))
                                as usize]
                                & (1 as libc::c_uint)
                                    << (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar
                                        as libc::c_int
                                        & 0x1f as libc::c_int)
                                == 0
                            {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            current_block_112 = 7694897095983579606;
                        }
                        22 | 24 => {
                            current_block_112 = 7694897095983579606;
                        }
                        5 => {
                            if (end.wrapping_offset_from(ptr) as libc::c_long)
                                < 2 as libc::c_int as libc::c_long
                            {
                                return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                            }
                            if 0 as libc::c_int == 0 {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            ptr = ptr.offset(2 as libc::c_int as isize);
                            current_block_112 = 2463987395154258233;
                        }
                        6 => {
                            if (end.wrapping_offset_from(ptr) as libc::c_long)
                                < 3 as libc::c_int as libc::c_long
                            {
                                return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                            }
                            if 0 as libc::c_int == 0 {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            ptr = ptr.offset(3 as libc::c_int as isize);
                            current_block_112 = 2463987395154258233;
                        }
                        7 => {
                            if (end.wrapping_offset_from(ptr) as libc::c_long)
                                < 4 as libc::c_int as libc::c_long
                            {
                                return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                            }
                            if 0 as libc::c_int == 0 {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            ptr = ptr.offset(4 as libc::c_int as isize);
                            current_block_112 = 2463987395154258233;
                        }
                        _ => {
                            *nextTokPtr = ptr;
                            return crate::xmltok_h::XML_TOK_INVALID;
                        }
                    }
                    match current_block_112 {
                        7694897095983579606 => ptr = ptr.offset(2 as libc::c_int as isize),
                        _ => {}
                    }
                    current_block_161 = 12655303178690906525;
                }
                21 | 9 | 10 => {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    loop {
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                        {
                            current_block_161 = 13000670339742628194;
                            break;
                        }
                        match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                            == 0 as libc::c_int
                        {
                            (*(enc as *mut normal_encoding)).type_0
                                [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                                as libc::c_int
                        } else {
                            unicode_byte_type(
                                *ptr.offset(0 as libc::c_int as isize),
                                *ptr.offset(1 as libc::c_int as isize),
                            )
                        } {
                            29 => {
                                if namingBitmap[(((nmstrtPages[*ptr
                                    .offset(0 as libc::c_int as isize)
                                    as libc::c_uchar
                                    as usize]
                                    as libc::c_int)
                                    << 3 as libc::c_int)
                                    + (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar
                                        as libc::c_int
                                        >> 5 as libc::c_int))
                                    as usize]
                                    & (1 as libc::c_uint)
                                        << (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar
                                            as libc::c_int
                                            & 0x1f as libc::c_int)
                                    == 0
                                {
                                    *nextTokPtr = ptr;
                                    return crate::xmltok_h::XML_TOK_INVALID;
                                }
                                current_block_161 = 16787315395666308353;
                            }
                            22 | 24 => {
                                current_block_161 = 16787315395666308353;
                            }
                            5 => {
                                if (end.wrapping_offset_from(ptr) as libc::c_long)
                                    < 2 as libc::c_int as libc::c_long
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                }
                                if 0 as libc::c_int == 0 {
                                    *nextTokPtr = ptr;
                                    return crate::xmltok_h::XML_TOK_INVALID;
                                }
                                ptr = ptr.offset(2 as libc::c_int as isize);
                                current_block_161 = 7999014830792590863;
                            }
                            6 => {
                                if (end.wrapping_offset_from(ptr) as libc::c_long)
                                    < 3 as libc::c_int as libc::c_long
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                }
                                if 0 as libc::c_int == 0 {
                                    *nextTokPtr = ptr;
                                    return crate::xmltok_h::XML_TOK_INVALID;
                                }
                                ptr = ptr.offset(3 as libc::c_int as isize);
                                current_block_161 = 7999014830792590863;
                            }
                            7 => {
                                if (end.wrapping_offset_from(ptr) as libc::c_long)
                                    < 4 as libc::c_int as libc::c_long
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                }
                                if 0 as libc::c_int == 0 {
                                    *nextTokPtr = ptr;
                                    return crate::xmltok_h::XML_TOK_INVALID;
                                }
                                ptr = ptr.offset(4 as libc::c_int as isize);
                                current_block_161 = 7999014830792590863;
                            }
                            11 => {
                                current_block_161 = 8186870683368195072;
                                break;
                            }
                            17 => {
                                current_block_161 = 1225701803299345799;
                                break;
                            }
                            21 | 9 | 10 => {
                                ptr = ptr.offset(2 as libc::c_int as isize);
                                continue;
                            }
                            _ => {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                        }
                        match current_block_161 {
                            16787315395666308353 => ptr = ptr.offset(2 as libc::c_int as isize),
                            _ => {}
                        }
                        return big2_scanAtts(enc, ptr, end, nextTokPtr);
                    }
                    match current_block_161 {
                        8186870683368195072 => {}
                        1225701803299345799 => {}
                        _ => return crate::xmltok_h::XML_TOK_PARTIAL,
                    }
                }
                11 => {
                    current_block_161 = 8186870683368195072;
                }
                17 => {
                    current_block_161 = 1225701803299345799;
                }
                _ => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
            }
            match current_block_161 {
                1225701803299345799 => {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL;
                    }
                    if !(*ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                        && *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                            == 0x3e as libc::c_int)
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                    return crate::xmltok_h::XML_TOK_EMPTY_ELEMENT_NO_ATTS;
                }
                8186870683368195072 => {
                    *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                    return crate::xmltok_h::XML_TOK_START_TAG_NO_ATTS;
                }
                14827193857955628413 => ptr = ptr.offset(2 as libc::c_int as isize),
                _ => {}
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }

    pub unsafe extern "C" fn little2_scanLt(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        let mut hadColon: libc::c_int = 0;
        if !(end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
        {
            return crate::xmltok_h::XML_TOK_PARTIAL;
        }
        let mut current_block_45: u64;
        match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
            (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize] as libc::c_int
        } else {
            unicode_byte_type(
                *ptr.offset(1 as libc::c_int as isize),
                *ptr.offset(0 as libc::c_int as isize),
            )
        } {
            29 => {
                if namingBitmap[(((nmstrtPages
                    [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int)
                    << 3 as libc::c_int)
                    + (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                        >> 5 as libc::c_int)) as usize]
                    & (1 as libc::c_uint)
                        << (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            & 0x1f as libc::c_int)
                    == 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                current_block_45 = 3604408518828465902;
            }
            22 | 24 => {
                current_block_45 = 3604408518828465902;
            }
            5 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 2 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(2 as libc::c_int as isize);
                current_block_45 = 1847472278776910194;
            }
            6 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 3 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(3 as libc::c_int as isize);
                current_block_45 = 1847472278776910194;
            }
            7 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(4 as libc::c_int as isize);
                current_block_45 = 1847472278776910194;
            }
            16 => {
                ptr = ptr.offset(2 as libc::c_int as isize);
                if !(end.wrapping_offset_from(ptr) as libc::c_long
                    >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL;
                }
                match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                    (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                        as libc::c_int
                } else {
                    unicode_byte_type(
                        *ptr.offset(1 as libc::c_int as isize),
                        *ptr.offset(0 as libc::c_int as isize),
                    )
                } {
                    27 => {
                        return little2_scanComment(
                            enc,
                            ptr.offset(2 as libc::c_int as isize),
                            end,
                            nextTokPtr,
                        )
                    }
                    20 => {
                        return little2_scanCdataSection(
                            enc,
                            ptr.offset(2 as libc::c_int as isize),
                            end,
                            nextTokPtr,
                        )
                    }
                    _ => {}
                }
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
            15 => {
                return little2_scanPi(enc, ptr.offset(2 as libc::c_int as isize), end, nextTokPtr)
            }
            17 => {
                return little2_scanEndTag(
                    enc,
                    ptr.offset(2 as libc::c_int as isize),
                    end,
                    nextTokPtr,
                )
            }
            _ => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
        }
        match current_block_45 {
            3604408518828465902 => ptr = ptr.offset(2 as libc::c_int as isize),
            _ => {}
        }
        hadColon = 0 as libc::c_int;
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            let mut current_block_161: u64;
            match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(1 as libc::c_int as isize),
                    *ptr.offset(0 as libc::c_int as isize),
                )
            } {
                29 => {
                    if namingBitmap[(((namePages
                        [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                        as libc::c_int)
                        << 3 as libc::c_int)
                        + (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            >> 5 as libc::c_int)) as usize]
                        & (1 as libc::c_uint)
                            << (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar
                                as libc::c_int
                                & 0x1f as libc::c_int)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    current_block_161 = 11090466150472633662;
                }
                22 | 24 | 25 | 26 | 27 => {
                    current_block_161 = 11090466150472633662;
                }
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    current_block_161 = 12655303178690906525;
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize);
                    current_block_161 = 12655303178690906525;
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    current_block_161 = 12655303178690906525;
                }
                23 => {
                    if hadColon != 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    hadColon = 1 as libc::c_int;
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL;
                    }
                    let mut current_block_112: u64;
                    match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                        == 0 as libc::c_int
                    {
                        (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                            as libc::c_int
                    } else {
                        unicode_byte_type(
                            *ptr.offset(1 as libc::c_int as isize),
                            *ptr.offset(0 as libc::c_int as isize),
                        )
                    } {
                        29 => {
                            if namingBitmap[(((nmstrtPages
                                [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                                as libc::c_int)
                                << 3 as libc::c_int)
                                + (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar
                                    as libc::c_int
                                    >> 5 as libc::c_int))
                                as usize]
                                & (1 as libc::c_uint)
                                    << (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar
                                        as libc::c_int
                                        & 0x1f as libc::c_int)
                                == 0
                            {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            current_block_112 = 5114428014282072970;
                        }
                        22 | 24 => {
                            current_block_112 = 5114428014282072970;
                        }
                        5 => {
                            if (end.wrapping_offset_from(ptr) as libc::c_long)
                                < 2 as libc::c_int as libc::c_long
                            {
                                return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                            }
                            if 0 as libc::c_int == 0 {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            ptr = ptr.offset(2 as libc::c_int as isize);
                            current_block_112 = 2463987395154258233;
                        }
                        6 => {
                            if (end.wrapping_offset_from(ptr) as libc::c_long)
                                < 3 as libc::c_int as libc::c_long
                            {
                                return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                            }
                            if 0 as libc::c_int == 0 {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            ptr = ptr.offset(3 as libc::c_int as isize);
                            current_block_112 = 2463987395154258233;
                        }
                        7 => {
                            if (end.wrapping_offset_from(ptr) as libc::c_long)
                                < 4 as libc::c_int as libc::c_long
                            {
                                return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                            }
                            if 0 as libc::c_int == 0 {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            ptr = ptr.offset(4 as libc::c_int as isize);
                            current_block_112 = 2463987395154258233;
                        }
                        _ => {
                            *nextTokPtr = ptr;
                            return crate::xmltok_h::XML_TOK_INVALID;
                        }
                    }
                    match current_block_112 {
                        5114428014282072970 => ptr = ptr.offset(2 as libc::c_int as isize),
                        _ => {}
                    }
                    current_block_161 = 12655303178690906525;
                }
                21 | 9 | 10 => {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    loop {
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                        {
                            current_block_161 = 13000670339742628194;
                            break;
                        }
                        match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                            == 0 as libc::c_int
                        {
                            (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                                as libc::c_int
                        } else {
                            unicode_byte_type(
                                *ptr.offset(1 as libc::c_int as isize),
                                *ptr.offset(0 as libc::c_int as isize),
                            )
                        } {
                            29 => {
                                if namingBitmap[(((nmstrtPages[*ptr
                                    .offset(1 as libc::c_int as isize)
                                    as libc::c_uchar
                                    as usize]
                                    as libc::c_int)
                                    << 3 as libc::c_int)
                                    + (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar
                                        as libc::c_int
                                        >> 5 as libc::c_int))
                                    as usize]
                                    & (1 as libc::c_uint)
                                        << (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar
                                            as libc::c_int
                                            & 0x1f as libc::c_int)
                                    == 0
                                {
                                    *nextTokPtr = ptr;
                                    return crate::xmltok_h::XML_TOK_INVALID;
                                }
                                current_block_161 = 8174279831488790583;
                            }
                            22 | 24 => {
                                current_block_161 = 8174279831488790583;
                            }
                            5 => {
                                if (end.wrapping_offset_from(ptr) as libc::c_long)
                                    < 2 as libc::c_int as libc::c_long
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                }
                                if 0 as libc::c_int == 0 {
                                    *nextTokPtr = ptr;
                                    return crate::xmltok_h::XML_TOK_INVALID;
                                }
                                ptr = ptr.offset(2 as libc::c_int as isize);
                                current_block_161 = 7999014830792590863;
                            }
                            6 => {
                                if (end.wrapping_offset_from(ptr) as libc::c_long)
                                    < 3 as libc::c_int as libc::c_long
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                }
                                if 0 as libc::c_int == 0 {
                                    *nextTokPtr = ptr;
                                    return crate::xmltok_h::XML_TOK_INVALID;
                                }
                                ptr = ptr.offset(3 as libc::c_int as isize);
                                current_block_161 = 7999014830792590863;
                            }
                            7 => {
                                if (end.wrapping_offset_from(ptr) as libc::c_long)
                                    < 4 as libc::c_int as libc::c_long
                                {
                                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                }
                                if 0 as libc::c_int == 0 {
                                    *nextTokPtr = ptr;
                                    return crate::xmltok_h::XML_TOK_INVALID;
                                }
                                ptr = ptr.offset(4 as libc::c_int as isize);
                                current_block_161 = 7999014830792590863;
                            }
                            11 => {
                                current_block_161 = 16654161972338254730;
                                break;
                            }
                            17 => {
                                current_block_161 = 13380707534857435492;
                                break;
                            }
                            21 | 9 | 10 => {
                                ptr = ptr.offset(2 as libc::c_int as isize);
                                continue;
                            }
                            _ => {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                        }
                        match current_block_161 {
                            8174279831488790583 => ptr = ptr.offset(2 as libc::c_int as isize),
                            _ => {}
                        }
                        return little2_scanAtts(enc, ptr, end, nextTokPtr);
                    }
                    match current_block_161 {
                        16654161972338254730 => {}
                        13380707534857435492 => {}
                        _ => return crate::xmltok_h::XML_TOK_PARTIAL,
                    }
                }
                11 => {
                    current_block_161 = 16654161972338254730;
                }
                17 => {
                    current_block_161 = 13380707534857435492;
                }
                _ => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
            }
            match current_block_161 {
                13380707534857435492 => {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL;
                    }
                    if !(*ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                        && *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                            == 0x3e as libc::c_int)
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                    return crate::xmltok_h::XML_TOK_EMPTY_ELEMENT_NO_ATTS;
                }
                16654161972338254730 => {
                    *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                    return crate::xmltok_h::XML_TOK_START_TAG_NO_ATTS;
                }
                11090466150472633662 => ptr = ptr.offset(2 as libc::c_int as isize),
                _ => {}
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }

    pub unsafe extern "C" fn little2_contentTok(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        if ptr >= end {
            return crate::xmltok_h::XML_TOK_NONE;
        }
        if 2 as libc::c_int > 1 as libc::c_int {
            let mut n: crate::stddef_h::size_t =
                end.wrapping_offset_from(ptr) as libc::c_long as crate::stddef_h::size_t;
            if n & (2 as libc::c_int - 1 as libc::c_int) as libc::c_ulong != 0 {
                n &= !(2 as libc::c_int - 1 as libc::c_int) as libc::c_ulong;
                if n == 0 as libc::c_int as libc::c_ulong {
                    return crate::xmltok_h::XML_TOK_PARTIAL;
                }
                end = ptr.offset(n as isize)
            }
        }
        match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
            (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize] as libc::c_int
        } else {
            unicode_byte_type(
                *ptr.offset(1 as libc::c_int as isize),
                *ptr.offset(0 as libc::c_int as isize),
            )
        } {
            2 => {
                return little2_scanLt(enc, ptr.offset(2 as libc::c_int as isize), end, nextTokPtr)
            }
            3 => {
                return little2_scanRef(enc, ptr.offset(2 as libc::c_int as isize), end, nextTokPtr)
            }
            9 => {
                ptr = ptr.offset(2 as libc::c_int as isize);
                if !(end.wrapping_offset_from(ptr) as libc::c_long
                    >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                {
                    return crate::xmltok_h::XML_TOK_TRAILING_CR;
                }
                if (if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                    (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                        as libc::c_int
                } else {
                    unicode_byte_type(
                        *ptr.offset(1 as libc::c_int as isize),
                        *ptr.offset(0 as libc::c_int as isize),
                    )
                }) == crate::xmltok_impl_h::BT_LF as libc::c_int
                {
                    ptr = ptr.offset(2 as libc::c_int as isize)
                }
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_DATA_NEWLINE;
            }
            10 => {
                *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                return crate::xmltok_h::XML_TOK_DATA_NEWLINE;
            }
            4 => {
                ptr = ptr.offset(2 as libc::c_int as isize);
                if !(end.wrapping_offset_from(ptr) as libc::c_long
                    >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                {
                    return crate::xmltok_h::XML_TOK_TRAILING_RSQB;
                }
                if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                    && *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0x5d as libc::c_int
                {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                    {
                        return crate::xmltok_h::XML_TOK_TRAILING_RSQB;
                    }
                    if !(*ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                        && *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                            == 0x3e as libc::c_int)
                    {
                        ptr = ptr.offset(-(2 as libc::c_int as isize))
                    } else {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                }
            }
            5 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 2 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                ptr = ptr.offset(2 as libc::c_int as isize)
            }
            6 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 3 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                ptr = ptr.offset(3 as libc::c_int as isize)
            }
            7 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                ptr = ptr.offset(4 as libc::c_int as isize)
            }
            0 | 1 | 8 => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
            _ => ptr = ptr.offset(2 as libc::c_int as isize),
        }
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            let mut current_block_76: u64;
            match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(1 as libc::c_int as isize),
                    *ptr.offset(0 as libc::c_int as isize),
                )
            } {
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                        || 0 as libc::c_int != 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_DATA_CHARS;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    current_block_76 = 10213293998891106930;
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                        || 0 as libc::c_int != 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_DATA_CHARS;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize);
                    current_block_76 = 10213293998891106930;
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                        || 0 as libc::c_int != 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_DATA_CHARS;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    current_block_76 = 10213293998891106930;
                }
                4 => {
                    if end.wrapping_offset_from(ptr) as libc::c_long
                        >= (2 as libc::c_int * 2 as libc::c_int) as libc::c_long
                    {
                        if !(*ptr
                            .offset(2 as libc::c_int as isize)
                            .offset(1 as libc::c_int as isize)
                            as libc::c_int
                            == 0 as libc::c_int
                            && *ptr
                                .offset(2 as libc::c_int as isize)
                                .offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == 0x5d as libc::c_int)
                        {
                            ptr = ptr.offset(2 as libc::c_int as isize);
                            current_block_76 = 10213293998891106930;
                        } else if end.wrapping_offset_from(ptr) as libc::c_long
                            >= (3 as libc::c_int * 2 as libc::c_int) as libc::c_long
                        {
                            if !(*ptr
                                .offset((2 as libc::c_int * 2 as libc::c_int) as isize)
                                .offset(1 as libc::c_int as isize)
                                as libc::c_int
                                == 0 as libc::c_int
                                && *ptr
                                    .offset((2 as libc::c_int * 2 as libc::c_int) as isize)
                                    .offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == 0x3e as libc::c_int)
                            {
                                ptr = ptr.offset(2 as libc::c_int as isize)
                            } else {
                                *nextTokPtr =
                                    ptr.offset((2 as libc::c_int * 2 as libc::c_int) as isize);
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            current_block_76 = 10213293998891106930;
                        } else {
                            current_block_76 = 8987447449223982590;
                        }
                    } else {
                        current_block_76 = 8987447449223982590;
                    }
                }
                3 | 2 | 0 | 1 | 8 | 9 | 10 => {
                    current_block_76 = 8987447449223982590;
                }
                _ => {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    current_block_76 = 10213293998891106930;
                }
            }
            match current_block_76 {
                10213293998891106930 => {}
                _ =>
                /* fall through */
                /* fall through */
                /* fall through */
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_DATA_CHARS;
                }
            }
        }
        *nextTokPtr = ptr;
        return crate::xmltok_h::XML_TOK_DATA_CHARS;
    }

    pub unsafe extern "C" fn normal_contentTok(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        if ptr >= end {
            return crate::xmltok_h::XML_TOK_NONE;
        }
        if 1 as libc::c_int > 1 as libc::c_int {
            let mut n: crate::stddef_h::size_t =
                end.wrapping_offset_from(ptr) as libc::c_long as crate::stddef_h::size_t;
            if n & (1 as libc::c_int - 1 as libc::c_int) as libc::c_ulong != 0 {
                n &= !(1 as libc::c_int - 1 as libc::c_int) as libc::c_ulong;
                if n == 0 as libc::c_int as libc::c_ulong {
                    return crate::xmltok_h::XML_TOK_PARTIAL;
                }
                end = ptr.offset(n as isize)
            }
        }
        match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize] as libc::c_int
        {
            2 => return normal_scanLt(enc, ptr.offset(1 as libc::c_int as isize), end, nextTokPtr),
            3 => {
                return normal_scanRef(enc, ptr.offset(1 as libc::c_int as isize), end, nextTokPtr)
            }
            9 => {
                ptr = ptr.offset(1 as libc::c_int as isize);
                if !(end.wrapping_offset_from(ptr) as libc::c_long
                    >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                {
                    return crate::xmltok_h::XML_TOK_TRAILING_CR;
                }
                if (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                    as libc::c_int
                    == crate::xmltok_impl_h::BT_LF as libc::c_int
                {
                    ptr = ptr.offset(1 as libc::c_int as isize)
                }
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_DATA_NEWLINE;
            }
            10 => {
                *nextTokPtr = ptr.offset(1 as libc::c_int as isize);
                return crate::xmltok_h::XML_TOK_DATA_NEWLINE;
            }
            4 => {
                ptr = ptr.offset(1 as libc::c_int as isize);
                if !(end.wrapping_offset_from(ptr) as libc::c_long
                    >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                {
                    return crate::xmltok_h::XML_TOK_TRAILING_RSQB;
                }
                if *ptr as libc::c_int == 0x5d as libc::c_int {
                    ptr = ptr.offset(1 as libc::c_int as isize);
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                    {
                        return crate::xmltok_h::XML_TOK_TRAILING_RSQB;
                    }
                    if !(*ptr as libc::c_int == 0x3e as libc::c_int) {
                        ptr = ptr.offset(-(1 as libc::c_int as isize))
                    } else {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                }
            }
            5 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 2 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if (*(enc as *const normal_encoding))
                    .isInvalid2
                    .expect("non-null function pointer")(enc, ptr)
                    != 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(2 as libc::c_int as isize)
            }
            6 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 3 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if (*(enc as *const normal_encoding))
                    .isInvalid3
                    .expect("non-null function pointer")(enc, ptr)
                    != 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(3 as libc::c_int as isize)
            }
            7 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if (*(enc as *const normal_encoding))
                    .isInvalid4
                    .expect("non-null function pointer")(enc, ptr)
                    != 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(4 as libc::c_int as isize)
            }
            0 | 1 | 8 => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
            _ => ptr = ptr.offset(1 as libc::c_int as isize),
        }
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long
        {
            let mut current_block_76: u64;
            match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                as libc::c_int
            {
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                        || (*(enc as *const normal_encoding))
                            .isInvalid2
                            .expect("non-null function pointer")(enc, ptr)
                            != 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_DATA_CHARS;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    current_block_76 = 10213293998891106930;
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                        || (*(enc as *const normal_encoding))
                            .isInvalid3
                            .expect("non-null function pointer")(enc, ptr)
                            != 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_DATA_CHARS;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize);
                    current_block_76 = 10213293998891106930;
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                        || (*(enc as *const normal_encoding))
                            .isInvalid4
                            .expect("non-null function pointer")(enc, ptr)
                            != 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_DATA_CHARS;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    current_block_76 = 10213293998891106930;
                }
                4 => {
                    if end.wrapping_offset_from(ptr) as libc::c_long
                        >= (2 as libc::c_int * 1 as libc::c_int) as libc::c_long
                    {
                        if !(*ptr.offset(1 as libc::c_int as isize) as libc::c_int
                            == 0x5d as libc::c_int)
                        {
                            ptr = ptr.offset(1 as libc::c_int as isize);
                            current_block_76 = 10213293998891106930;
                        } else if end.wrapping_offset_from(ptr) as libc::c_long
                            >= (3 as libc::c_int * 1 as libc::c_int) as libc::c_long
                        {
                            if !(*ptr.offset((2 as libc::c_int * 1 as libc::c_int) as isize)
                                as libc::c_int
                                == 0x3e as libc::c_int)
                            {
                                ptr = ptr.offset(1 as libc::c_int as isize)
                            } else {
                                *nextTokPtr =
                                    ptr.offset((2 as libc::c_int * 1 as libc::c_int) as isize);
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            current_block_76 = 10213293998891106930;
                        } else {
                            current_block_76 = 15298127564675707271;
                        }
                    } else {
                        current_block_76 = 15298127564675707271;
                    }
                }
                3 | 2 | 0 | 1 | 8 | 9 | 10 => {
                    current_block_76 = 15298127564675707271;
                }
                _ => {
                    ptr = ptr.offset(1 as libc::c_int as isize);
                    current_block_76 = 10213293998891106930;
                }
            }
            match current_block_76 {
                10213293998891106930 => {}
                _ => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_DATA_CHARS;
                }
            }
        }
        *nextTokPtr = ptr;
        return crate::xmltok_h::XML_TOK_DATA_CHARS;
    }

    pub unsafe extern "C" fn big2_contentTok(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        if ptr >= end {
            return crate::xmltok_h::XML_TOK_NONE;
        }
        if 2 as libc::c_int > 1 as libc::c_int {
            let mut n: crate::stddef_h::size_t =
                end.wrapping_offset_from(ptr) as libc::c_long as crate::stddef_h::size_t;
            if n & (2 as libc::c_int - 1 as libc::c_int) as libc::c_ulong != 0 {
                n &= !(2 as libc::c_int - 1 as libc::c_int) as libc::c_ulong;
                if n == 0 as libc::c_int as libc::c_ulong {
                    return crate::xmltok_h::XML_TOK_PARTIAL;
                }
                end = ptr.offset(n as isize)
            }
        }
        match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
            (*(enc as *mut normal_encoding)).type_0
                [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                as libc::c_int
        } else {
            unicode_byte_type(
                *ptr.offset(0 as libc::c_int as isize),
                *ptr.offset(1 as libc::c_int as isize),
            )
        } {
            2 => return big2_scanLt(enc, ptr.offset(2 as libc::c_int as isize), end, nextTokPtr),
            3 => return big2_scanRef(enc, ptr.offset(2 as libc::c_int as isize), end, nextTokPtr),
            9 => {
                ptr = ptr.offset(2 as libc::c_int as isize);
                if !(end.wrapping_offset_from(ptr) as libc::c_long
                    >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                {
                    return crate::xmltok_h::XML_TOK_TRAILING_CR;
                }
                if (if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                    (*(enc as *mut normal_encoding)).type_0
                        [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                        as libc::c_int
                } else {
                    unicode_byte_type(
                        *ptr.offset(0 as libc::c_int as isize),
                        *ptr.offset(1 as libc::c_int as isize),
                    )
                }) == crate::xmltok_impl_h::BT_LF as libc::c_int
                {
                    ptr = ptr.offset(2 as libc::c_int as isize)
                }
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_DATA_NEWLINE;
            }
            10 => {
                *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                return crate::xmltok_h::XML_TOK_DATA_NEWLINE;
            }
            4 => {
                ptr = ptr.offset(2 as libc::c_int as isize);
                if !(end.wrapping_offset_from(ptr) as libc::c_long
                    >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                {
                    return crate::xmltok_h::XML_TOK_TRAILING_RSQB;
                }
                if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                    && *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0x5d as libc::c_int
                {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                    {
                        return crate::xmltok_h::XML_TOK_TRAILING_RSQB;
                    }
                    if !(*ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                        && *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                            == 0x3e as libc::c_int)
                    {
                        ptr = ptr.offset(-(2 as libc::c_int as isize))
                    } else {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                }
            }
            5 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 2 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                ptr = ptr.offset(2 as libc::c_int as isize)
            }
            6 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 3 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                ptr = ptr.offset(3 as libc::c_int as isize)
            }
            7 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                ptr = ptr.offset(4 as libc::c_int as isize)
            }
            0 | 1 | 8 => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
            _ => ptr = ptr.offset(2 as libc::c_int as isize),
        }
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            let mut current_block_76: u64;
            match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0
                    [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(0 as libc::c_int as isize),
                    *ptr.offset(1 as libc::c_int as isize),
                )
            } {
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                        || 0 as libc::c_int != 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_DATA_CHARS;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    current_block_76 = 10213293998891106930;
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                        || 0 as libc::c_int != 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_DATA_CHARS;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize);
                    current_block_76 = 10213293998891106930;
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                        || 0 as libc::c_int != 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_DATA_CHARS;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    current_block_76 = 10213293998891106930;
                }
                4 => {
                    if end.wrapping_offset_from(ptr) as libc::c_long
                        >= (2 as libc::c_int * 2 as libc::c_int) as libc::c_long
                    {
                        if !(*ptr
                            .offset(2 as libc::c_int as isize)
                            .offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == 0 as libc::c_int
                            && *ptr
                                .offset(2 as libc::c_int as isize)
                                .offset(1 as libc::c_int as isize)
                                as libc::c_int
                                == 0x5d as libc::c_int)
                        {
                            ptr = ptr.offset(2 as libc::c_int as isize);
                            current_block_76 = 10213293998891106930;
                        } else if end.wrapping_offset_from(ptr) as libc::c_long
                            >= (3 as libc::c_int * 2 as libc::c_int) as libc::c_long
                        {
                            if !(*ptr
                                .offset((2 as libc::c_int * 2 as libc::c_int) as isize)
                                .offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == 0 as libc::c_int
                                && *ptr
                                    .offset((2 as libc::c_int * 2 as libc::c_int) as isize)
                                    .offset(1 as libc::c_int as isize)
                                    as libc::c_int
                                    == 0x3e as libc::c_int)
                            {
                                ptr = ptr.offset(2 as libc::c_int as isize)
                            } else {
                                *nextTokPtr =
                                    ptr.offset((2 as libc::c_int * 2 as libc::c_int) as isize);
                                return crate::xmltok_h::XML_TOK_INVALID;
                            }
                            current_block_76 = 10213293998891106930;
                        } else {
                            current_block_76 = 14775589748497275135;
                        }
                    } else {
                        current_block_76 = 14775589748497275135;
                    }
                }
                3 | 2 | 0 | 1 | 8 | 9 | 10 => {
                    current_block_76 = 14775589748497275135;
                }
                _ => {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    current_block_76 = 10213293998891106930;
                }
            }
            match current_block_76 {
                10213293998891106930 => {}
                _ => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_DATA_CHARS;
                }
            }
        }
        *nextTokPtr = ptr;
        return crate::xmltok_h::XML_TOK_DATA_CHARS;
    }
    /* ptr points to character following "%" */
    /* ptr points to character following "%" */
    /* ptr points to character following "%" */

    pub unsafe extern "C" fn little2_scanPercent(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        if !(end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
        {
            return crate::xmltok_h::XML_TOK_PARTIAL;
        }
        let mut current_block_34: u64;
        match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
            (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize] as libc::c_int
        } else {
            unicode_byte_type(
                *ptr.offset(1 as libc::c_int as isize),
                *ptr.offset(0 as libc::c_int as isize),
            )
        } {
            29 => {
                if namingBitmap[(((nmstrtPages
                    [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int)
                    << 3 as libc::c_int)
                    + (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                        >> 5 as libc::c_int)) as usize]
                    & (1 as libc::c_uint)
                        << (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            & 0x1f as libc::c_int)
                    == 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                current_block_34 = 5609339353924833948;
            }
            22 | 24 => {
                current_block_34 = 5609339353924833948;
            }
            5 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 2 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(2 as libc::c_int as isize);
                current_block_34 = 9520865839495247062;
            }
            6 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 3 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(3 as libc::c_int as isize);
                current_block_34 = 9520865839495247062;
            }
            7 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(4 as libc::c_int as isize);
                current_block_34 = 9520865839495247062;
            }
            21 | 10 | 9 | 30 => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_PERCENT;
            }
            _ => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
        }
        match current_block_34 {
            5609339353924833948 => ptr = ptr.offset(2 as libc::c_int as isize),
            _ => {}
        }
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            let mut current_block_65: u64;
            match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(1 as libc::c_int as isize),
                    *ptr.offset(0 as libc::c_int as isize),
                )
            } {
                29 => {
                    if namingBitmap[(((namePages
                        [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                        as libc::c_int)
                        << 3 as libc::c_int)
                        + (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            >> 5 as libc::c_int)) as usize]
                        & (1 as libc::c_uint)
                            << (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar
                                as libc::c_int
                                & 0x1f as libc::c_int)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    current_block_65 = 14924637866976491194;
                }
                22 | 24 | 25 | 26 | 27 => {
                    current_block_65 = 14924637866976491194;
                }
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    current_block_65 = 12758904613967585247;
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize);
                    current_block_65 = 12758904613967585247;
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    current_block_65 = 12758904613967585247;
                }
                18 => {
                    *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                    return crate::xmltok_h::XML_TOK_PARAM_ENTITY_REF;
                }
                _ => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
            }
            match current_block_65 {
                14924637866976491194 => ptr = ptr.offset(2 as libc::c_int as isize),
                _ => {}
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }

    pub unsafe extern "C" fn big2_scanPercent(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        if !(end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
        {
            return crate::xmltok_h::XML_TOK_PARTIAL;
        }
        let mut current_block_34: u64;
        match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
            (*(enc as *mut normal_encoding)).type_0
                [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                as libc::c_int
        } else {
            unicode_byte_type(
                *ptr.offset(0 as libc::c_int as isize),
                *ptr.offset(1 as libc::c_int as isize),
            )
        } {
            29 => {
                if namingBitmap[(((nmstrtPages
                    [*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int)
                    << 3 as libc::c_int)
                    + (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                        >> 5 as libc::c_int)) as usize]
                    & (1 as libc::c_uint)
                        << (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            & 0x1f as libc::c_int)
                    == 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                current_block_34 = 2535787018921809524;
            }
            22 | 24 => {
                current_block_34 = 2535787018921809524;
            }
            5 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 2 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(2 as libc::c_int as isize);
                current_block_34 = 9520865839495247062;
            }
            6 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 3 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(3 as libc::c_int as isize);
                current_block_34 = 9520865839495247062;
            }
            7 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(4 as libc::c_int as isize);
                current_block_34 = 9520865839495247062;
            }
            21 | 10 | 9 | 30 => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_PERCENT;
            }
            _ => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
        }
        match current_block_34 {
            2535787018921809524 => ptr = ptr.offset(2 as libc::c_int as isize),
            _ => {}
        }
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            let mut current_block_65: u64;
            match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0
                    [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(0 as libc::c_int as isize),
                    *ptr.offset(1 as libc::c_int as isize),
                )
            } {
                29 => {
                    if namingBitmap[(((namePages
                        [*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as usize]
                        as libc::c_int)
                        << 3 as libc::c_int)
                        + (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            >> 5 as libc::c_int)) as usize]
                        & (1 as libc::c_uint)
                            << (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar
                                as libc::c_int
                                & 0x1f as libc::c_int)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    current_block_65 = 16518566462615084259;
                }
                22 | 24 | 25 | 26 | 27 => {
                    current_block_65 = 16518566462615084259;
                }
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    current_block_65 = 12758904613967585247;
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize);
                    current_block_65 = 12758904613967585247;
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    current_block_65 = 12758904613967585247;
                }
                18 => {
                    *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                    return crate::xmltok_h::XML_TOK_PARAM_ENTITY_REF;
                }
                _ => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
            }
            match current_block_65 {
                16518566462615084259 => ptr = ptr.offset(2 as libc::c_int as isize),
                _ => {}
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }

    pub unsafe extern "C" fn normal_scanPercent(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        if !(end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
        {
            return crate::xmltok_h::XML_TOK_PARTIAL;
        }
        let mut current_block_34: u64;
        match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize] as libc::c_int
        {
            29 => {
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                current_block_34 = 16508288390984586136;
            }
            22 | 24 => {
                current_block_34 = 16508288390984586136;
            }
            5 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 2 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if (*(enc as *const normal_encoding))
                    .isNmstrt2
                    .expect("non-null function pointer")(enc, ptr)
                    == 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(2 as libc::c_int as isize);
                current_block_34 = 9520865839495247062;
            }
            6 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 3 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if (*(enc as *const normal_encoding))
                    .isNmstrt3
                    .expect("non-null function pointer")(enc, ptr)
                    == 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(3 as libc::c_int as isize);
                current_block_34 = 9520865839495247062;
            }
            7 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if (*(enc as *const normal_encoding))
                    .isNmstrt4
                    .expect("non-null function pointer")(enc, ptr)
                    == 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(4 as libc::c_int as isize);
                current_block_34 = 9520865839495247062;
            }
            21 | 10 | 9 | 30 => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_PERCENT;
            }
            _ => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
        }
        match current_block_34 {
            16508288390984586136 => ptr = ptr.offset(1 as libc::c_int as isize),
            _ => {}
        }
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long
        {
            let mut current_block_65: u64;
            match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                as libc::c_int
            {
                29 => {
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    current_block_65 = 3744295902770449260;
                }
                22 | 24 | 25 | 26 | 27 => {
                    current_block_65 = 3744295902770449260;
                }
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if (*(enc as *const normal_encoding))
                        .isName2
                        .expect("non-null function pointer")(enc, ptr)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    current_block_65 = 12758904613967585247;
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if (*(enc as *const normal_encoding))
                        .isName3
                        .expect("non-null function pointer")(enc, ptr)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize);
                    current_block_65 = 12758904613967585247;
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if (*(enc as *const normal_encoding))
                        .isName4
                        .expect("non-null function pointer")(enc, ptr)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    current_block_65 = 12758904613967585247;
                }
                18 => {
                    *nextTokPtr = ptr.offset(1 as libc::c_int as isize);
                    return crate::xmltok_h::XML_TOK_PARAM_ENTITY_REF;
                }
                _ => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
            }
            match current_block_65 {
                3744295902770449260 => ptr = ptr.offset(1 as libc::c_int as isize),
                _ => {}
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }

    pub unsafe extern "C" fn little2_scanPoundName(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        if !(end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
        {
            return crate::xmltok_h::XML_TOK_PARTIAL;
        }
        let mut current_block_32: u64;
        match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
            (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize] as libc::c_int
        } else {
            unicode_byte_type(
                *ptr.offset(1 as libc::c_int as isize),
                *ptr.offset(0 as libc::c_int as isize),
            )
        } {
            29 => {
                if namingBitmap[(((nmstrtPages
                    [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int)
                    << 3 as libc::c_int)
                    + (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                        >> 5 as libc::c_int)) as usize]
                    & (1 as libc::c_uint)
                        << (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            & 0x1f as libc::c_int)
                    == 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                current_block_32 = 2269812350301213550;
            }
            22 | 24 => {
                current_block_32 = 2269812350301213550;
            }
            5 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 2 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(2 as libc::c_int as isize);
                current_block_32 = 5494826135382683477;
            }
            6 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 3 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(3 as libc::c_int as isize);
                current_block_32 = 5494826135382683477;
            }
            7 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(4 as libc::c_int as isize);
                current_block_32 = 5494826135382683477;
            }
            _ => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
        }
        match current_block_32 {
            2269812350301213550 => ptr = ptr.offset(2 as libc::c_int as isize),
            _ => {}
        }
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            let mut current_block_63: u64;
            match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(1 as libc::c_int as isize),
                    *ptr.offset(0 as libc::c_int as isize),
                )
            } {
                29 => {
                    if namingBitmap[(((namePages
                        [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                        as libc::c_int)
                        << 3 as libc::c_int)
                        + (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            >> 5 as libc::c_int)) as usize]
                        & (1 as libc::c_uint)
                            << (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar
                                as libc::c_int
                                & 0x1f as libc::c_int)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    current_block_63 = 15716831554174598335;
                }
                22 | 24 | 25 | 26 | 27 => {
                    current_block_63 = 15716831554174598335;
                }
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    current_block_63 = 8869332144787829186;
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize);
                    current_block_63 = 8869332144787829186;
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    current_block_63 = 8869332144787829186;
                }
                9 | 10 | 21 | 32 | 11 | 30 | 36 => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_POUND_NAME;
                }
                _ => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
            }
            match current_block_63 {
                15716831554174598335 => ptr = ptr.offset(2 as libc::c_int as isize),
                _ => {}
            }
        }
        return -crate::xmltok_h::XML_TOK_POUND_NAME;
    }

    pub unsafe extern "C" fn normal_scanPoundName(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        if !(end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
        {
            return crate::xmltok_h::XML_TOK_PARTIAL;
        }
        let mut current_block_32: u64;
        match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize] as libc::c_int
        {
            29 => {
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                current_block_32 = 14531478163722833811;
            }
            22 | 24 => {
                current_block_32 = 14531478163722833811;
            }
            5 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 2 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if (*(enc as *const normal_encoding))
                    .isNmstrt2
                    .expect("non-null function pointer")(enc, ptr)
                    == 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(2 as libc::c_int as isize);
                current_block_32 = 5494826135382683477;
            }
            6 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 3 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if (*(enc as *const normal_encoding))
                    .isNmstrt3
                    .expect("non-null function pointer")(enc, ptr)
                    == 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(3 as libc::c_int as isize);
                current_block_32 = 5494826135382683477;
            }
            7 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if (*(enc as *const normal_encoding))
                    .isNmstrt4
                    .expect("non-null function pointer")(enc, ptr)
                    == 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(4 as libc::c_int as isize);
                current_block_32 = 5494826135382683477;
            }
            _ => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
        }
        match current_block_32 {
            14531478163722833811 => ptr = ptr.offset(1 as libc::c_int as isize),
            _ => {}
        }
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long
        {
            let mut current_block_63: u64;
            match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                as libc::c_int
            {
                29 => {
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    current_block_63 = 1251073717335040501;
                }
                22 | 24 | 25 | 26 | 27 => {
                    current_block_63 = 1251073717335040501;
                }
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if (*(enc as *const normal_encoding))
                        .isName2
                        .expect("non-null function pointer")(enc, ptr)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    current_block_63 = 8869332144787829186;
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if (*(enc as *const normal_encoding))
                        .isName3
                        .expect("non-null function pointer")(enc, ptr)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize);
                    current_block_63 = 8869332144787829186;
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if (*(enc as *const normal_encoding))
                        .isName4
                        .expect("non-null function pointer")(enc, ptr)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    current_block_63 = 8869332144787829186;
                }
                9 | 10 | 21 | 32 | 11 | 30 | 36 => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_POUND_NAME;
                }
                _ => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
            }
            match current_block_63 {
                1251073717335040501 => ptr = ptr.offset(1 as libc::c_int as isize),
                _ => {}
            }
        }
        return -crate::xmltok_h::XML_TOK_POUND_NAME;
    }

    pub unsafe extern "C" fn big2_scanPoundName(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        if !(end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
        {
            return crate::xmltok_h::XML_TOK_PARTIAL;
        }
        let mut current_block_32: u64;
        match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
            (*(enc as *mut normal_encoding)).type_0
                [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                as libc::c_int
        } else {
            unicode_byte_type(
                *ptr.offset(0 as libc::c_int as isize),
                *ptr.offset(1 as libc::c_int as isize),
            )
        } {
            29 => {
                if namingBitmap[(((nmstrtPages
                    [*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int)
                    << 3 as libc::c_int)
                    + (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                        >> 5 as libc::c_int)) as usize]
                    & (1 as libc::c_uint)
                        << (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            & 0x1f as libc::c_int)
                    == 0
                {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                current_block_32 = 633956857006047984;
            }
            22 | 24 => {
                current_block_32 = 633956857006047984;
            }
            5 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 2 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(2 as libc::c_int as isize);
                current_block_32 = 5494826135382683477;
            }
            6 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 3 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(3 as libc::c_int as isize);
                current_block_32 = 5494826135382683477;
            }
            7 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if 0 as libc::c_int == 0 {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                ptr = ptr.offset(4 as libc::c_int as isize);
                current_block_32 = 5494826135382683477;
            }
            _ => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
        }
        match current_block_32 {
            633956857006047984 => ptr = ptr.offset(2 as libc::c_int as isize),
            _ => {}
        }
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            let mut current_block_63: u64;
            match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0
                    [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(0 as libc::c_int as isize),
                    *ptr.offset(1 as libc::c_int as isize),
                )
            } {
                29 => {
                    if namingBitmap[(((namePages
                        [*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as usize]
                        as libc::c_int)
                        << 3 as libc::c_int)
                        + (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            >> 5 as libc::c_int)) as usize]
                        & (1 as libc::c_uint)
                            << (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar
                                as libc::c_int
                                & 0x1f as libc::c_int)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    current_block_63 = 3145220949513738010;
                }
                22 | 24 | 25 | 26 | 27 => {
                    current_block_63 = 3145220949513738010;
                }
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    current_block_63 = 8869332144787829186;
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize);
                    current_block_63 = 8869332144787829186;
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    current_block_63 = 8869332144787829186;
                }
                9 | 10 | 21 | 32 | 11 | 30 | 36 => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_POUND_NAME;
                }
                _ => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
            }
            match current_block_63 {
                3145220949513738010 => ptr = ptr.offset(2 as libc::c_int as isize),
                _ => {}
            }
        }
        return -crate::xmltok_h::XML_TOK_POUND_NAME;
    }

    pub unsafe extern "C" fn little2_scanLit(
        mut open: libc::c_int,
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            let mut t: libc::c_int =
                if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                    (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                        as libc::c_int
                } else {
                    unicode_byte_type(
                        *ptr.offset(1 as libc::c_int as isize),
                        *ptr.offset(0 as libc::c_int as isize),
                    )
                };
            match t {
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize)
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize)
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize)
                }
                0 | 1 | 8 => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                12 | 13 => {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    if !(t != open) {
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                        {
                            return -crate::xmltok_h::XML_TOK_LITERAL;
                        }
                        *nextTokPtr = ptr;
                        match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                            == 0 as libc::c_int
                        {
                            (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                                as libc::c_int
                        } else {
                            unicode_byte_type(
                                *ptr.offset(1 as libc::c_int as isize),
                                *ptr.offset(0 as libc::c_int as isize),
                            )
                        } {
                            21 | 9 | 10 | 11 | 30 | 20 => return crate::xmltok_h::XML_TOK_LITERAL,
                            _ => return crate::xmltok_h::XML_TOK_INVALID,
                        }
                    }
                }
                _ => ptr = ptr.offset(2 as libc::c_int as isize),
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }

    pub unsafe extern "C" fn big2_scanLit(
        mut open: libc::c_int,
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            let mut t: libc::c_int =
                if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                    (*(enc as *mut normal_encoding)).type_0
                        [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                        as libc::c_int
                } else {
                    unicode_byte_type(
                        *ptr.offset(0 as libc::c_int as isize),
                        *ptr.offset(1 as libc::c_int as isize),
                    )
                };
            match t {
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize)
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize)
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize)
                }
                0 | 1 | 8 => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                12 | 13 => {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    if !(t != open) {
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                        {
                            return -crate::xmltok_h::XML_TOK_LITERAL;
                        }
                        *nextTokPtr = ptr;
                        match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                            == 0 as libc::c_int
                        {
                            (*(enc as *mut normal_encoding)).type_0
                                [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                                as libc::c_int
                        } else {
                            unicode_byte_type(
                                *ptr.offset(0 as libc::c_int as isize),
                                *ptr.offset(1 as libc::c_int as isize),
                            )
                        } {
                            21 | 9 | 10 | 11 | 30 | 20 => return crate::xmltok_h::XML_TOK_LITERAL,
                            _ => return crate::xmltok_h::XML_TOK_INVALID,
                        }
                    }
                }
                _ => ptr = ptr.offset(2 as libc::c_int as isize),
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }

    pub unsafe extern "C" fn normal_scanLit(
        mut open: libc::c_int,
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long
        {
            let mut t: libc::c_int = (*(enc as *mut normal_encoding)).type_0
                [*ptr as libc::c_uchar as usize]
                as libc::c_int;
            match t {
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if (*(enc as *const normal_encoding))
                        .isInvalid2
                        .expect("non-null function pointer")(enc, ptr)
                        != 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize)
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if (*(enc as *const normal_encoding))
                        .isInvalid3
                        .expect("non-null function pointer")(enc, ptr)
                        != 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize)
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if (*(enc as *const normal_encoding))
                        .isInvalid4
                        .expect("non-null function pointer")(enc, ptr)
                        != 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize)
                }
                0 | 1 | 8 => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                12 | 13 => {
                    ptr = ptr.offset(1 as libc::c_int as isize);
                    if !(t != open) {
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                        {
                            return -crate::xmltok_h::XML_TOK_LITERAL;
                        }
                        *nextTokPtr = ptr;
                        match (*(enc as *mut normal_encoding)).type_0
                            [*ptr as libc::c_uchar as usize]
                            as libc::c_int
                        {
                            21 | 9 | 10 | 11 | 30 | 20 => return crate::xmltok_h::XML_TOK_LITERAL,
                            _ => return crate::xmltok_h::XML_TOK_INVALID,
                        }
                    }
                }
                _ => ptr = ptr.offset(1 as libc::c_int as isize),
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }

    pub unsafe extern "C" fn little2_prologTok(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        let mut tok: libc::c_int = 0;
        if ptr >= end {
            return crate::xmltok_h::XML_TOK_NONE;
        }
        if 2 as libc::c_int > 1 as libc::c_int {
            let mut n: crate::stddef_h::size_t =
                end.wrapping_offset_from(ptr) as libc::c_long as crate::stddef_h::size_t;
            if n & (2 as libc::c_int - 1 as libc::c_int) as libc::c_ulong != 0 {
                n &= !(2 as libc::c_int - 1 as libc::c_int) as libc::c_ulong;
                if n == 0 as libc::c_int as libc::c_ulong {
                    return crate::xmltok_h::XML_TOK_PARTIAL;
                }
                end = ptr.offset(n as isize)
            }
        }
        let mut current_block_112: u64;
        match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
            (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize] as libc::c_int
        } else {
            unicode_byte_type(
                *ptr.offset(1 as libc::c_int as isize),
                *ptr.offset(0 as libc::c_int as isize),
            )
        } {
            12 => {
                return little2_scanLit(
                    crate::xmltok_impl_h::BT_QUOT as libc::c_int,
                    enc,
                    ptr.offset(2 as libc::c_int as isize),
                    end,
                    nextTokPtr,
                )
            }
            13 => {
                return little2_scanLit(
                    crate::xmltok_impl_h::BT_APOS as libc::c_int,
                    enc,
                    ptr.offset(2 as libc::c_int as isize),
                    end,
                    nextTokPtr,
                )
            }
            2 => {
                ptr = ptr.offset(2 as libc::c_int as isize);
                if !(end.wrapping_offset_from(ptr) as libc::c_long
                    >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL;
                }
                match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                    (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                        as libc::c_int
                } else {
                    unicode_byte_type(
                        *ptr.offset(1 as libc::c_int as isize),
                        *ptr.offset(0 as libc::c_int as isize),
                    )
                } {
                    16 => {
                        return little2_scanDecl(
                            enc,
                            ptr.offset(2 as libc::c_int as isize),
                            end,
                            nextTokPtr,
                        )
                    }
                    15 => {
                        return little2_scanPi(
                            enc,
                            ptr.offset(2 as libc::c_int as isize),
                            end,
                            nextTokPtr,
                        )
                    }
                    22 | 24 | 29 | 5 | 6 | 7 => {
                        *nextTokPtr = ptr.offset(-(2 as libc::c_int as isize));
                        return crate::src::lib::xmltok::XML_TOK_INSTANCE_START;
                    }
                    _ => {}
                }
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
            9 => {
                if ptr.offset(2 as libc::c_int as isize) == end {
                    *nextTokPtr = end;
                    /* indicate that this might be part of a CR/LF pair */
                    /* indicate that this might be part of a CR/LF pair */
                    /* indicate that this might be part of a CR/LF pair */
                    return -crate::src::lib::xmltok::XML_TOK_PROLOG_S;
                }
                current_block_112 = 18365440899698678160;
            }
            21 | 10 => {
                current_block_112 = 18365440899698678160;
            }
            30 => {
                return little2_scanPercent(
                    enc,
                    ptr.offset(2 as libc::c_int as isize),
                    end,
                    nextTokPtr,
                )
            }
            35 => {
                *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                return crate::xmltok_h::XML_TOK_COMMA;
            }
            20 => {
                *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                return crate::xmltok_h::XML_TOK_OPEN_BRACKET;
            }
            4 => {
                ptr = ptr.offset(2 as libc::c_int as isize);
                if !(end.wrapping_offset_from(ptr) as libc::c_long
                    >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                {
                    return -crate::xmltok_h::XML_TOK_CLOSE_BRACKET;
                }
                if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                    && *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0x5d as libc::c_int
                {
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (2 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL;
                    }
                    if *ptr
                        .offset(2 as libc::c_int as isize)
                        .offset(1 as libc::c_int as isize) as libc::c_int
                        == 0 as libc::c_int
                        && *ptr
                            .offset(2 as libc::c_int as isize)
                            .offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == 0x3e as libc::c_int
                    {
                        *nextTokPtr = ptr.offset((2 as libc::c_int * 2 as libc::c_int) as isize);
                        return crate::xmltok_h::XML_TOK_COND_SECT_CLOSE;
                    }
                }
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_CLOSE_BRACKET;
            }
            31 => {
                *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                return crate::xmltok_h::XML_TOK_OPEN_PAREN;
            }
            32 => {
                ptr = ptr.offset(2 as libc::c_int as isize);
                if !(end.wrapping_offset_from(ptr) as libc::c_long
                    >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                {
                    return -crate::xmltok_h::XML_TOK_CLOSE_PAREN;
                }
                match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                    (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                        as libc::c_int
                } else {
                    unicode_byte_type(
                        *ptr.offset(1 as libc::c_int as isize),
                        *ptr.offset(0 as libc::c_int as isize),
                    )
                } {
                    33 => {
                        *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                        return crate::xmltok_h::XML_TOK_CLOSE_PAREN_ASTERISK;
                    }
                    15 => {
                        *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                        return crate::xmltok_h::XML_TOK_CLOSE_PAREN_QUESTION;
                    }
                    34 => {
                        *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                        return crate::xmltok_h::XML_TOK_CLOSE_PAREN_PLUS;
                    }
                    9 | 10 | 21 | 11 | 35 | 36 | 32 => {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_CLOSE_PAREN;
                    }
                    _ => {}
                }
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
            36 => {
                *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                return crate::xmltok_h::XML_TOK_OR;
            }
            11 => {
                *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                return crate::xmltok_h::XML_TOK_DECL_CLOSE;
            }
            19 => {
                return little2_scanPoundName(
                    enc,
                    ptr.offset(2 as libc::c_int as isize),
                    end,
                    nextTokPtr,
                )
            }
            5 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 2 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
            6 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 3 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
            7 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
            22 | 24 => {
                tok = crate::xmltok_h::XML_TOK_NAME;
                ptr = ptr.offset(2 as libc::c_int as isize);
                current_block_112 = 2222055338596505704;
            }
            25 | 26 | 27 | 23 => {
                tok = crate::xmltok_h::XML_TOK_NMTOKEN;
                ptr = ptr.offset(2 as libc::c_int as isize);
                current_block_112 = 2222055338596505704;
            }
            29 => {
                if namingBitmap[(((nmstrtPages
                    [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int)
                    << 3 as libc::c_int)
                    + (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                        >> 5 as libc::c_int)) as usize]
                    & (1 as libc::c_uint)
                        << (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            & 0x1f as libc::c_int)
                    != 0
                {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    tok = crate::xmltok_h::XML_TOK_NAME;
                    current_block_112 = 2222055338596505704;
                } else if namingBitmap[(((namePages
                    [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int)
                    << 3 as libc::c_int)
                    + (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                        >> 5 as libc::c_int)) as usize]
                    & (1 as libc::c_uint)
                        << (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            & 0x1f as libc::c_int)
                    != 0
                {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    tok = crate::xmltok_h::XML_TOK_NMTOKEN;
                    current_block_112 = 2222055338596505704;
                } else {
                    current_block_112 = 15425764709914638707;
                }
            }
            _ => {
                current_block_112 = 15425764709914638707;
            }
        }
        match current_block_112 {
            2222055338596505704 => {}
            18365440899698678160 =>
            /* fall through */
            /* fall through */
            /* fall through */
            {
                loop {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                    {
                        break;
                    }
                    let mut current_block_32: u64;
                    match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                        == 0 as libc::c_int
                    {
                        (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                            as libc::c_int
                    } else {
                        unicode_byte_type(
                            *ptr.offset(1 as libc::c_int as isize),
                            *ptr.offset(0 as libc::c_int as isize),
                        )
                    } {
                        21 | 10 => {
                            current_block_32 = 14072441030219150333;
                        }
                        9 => {
                            /* don't split CR/LF pair */
                            /* don't split CR/LF pair */
                            /* don't split CR/LF pair */
                            if ptr.offset(2 as libc::c_int as isize) != end {
                                current_block_32 = 14072441030219150333;
                            } else {
                                current_block_32 = 9063685204218595982;
                            }
                        }
                        _ => {
                            current_block_32 = 9063685204218595982;
                        }
                    }
                    match current_block_32 {
                        14072441030219150333 => {}
                        _ =>
                        /* fall through */
                        /* fall through */
                        /* fall through */
                        {
                            *nextTokPtr = ptr;
                            return crate::src::lib::xmltok::XML_TOK_PROLOG_S;
                        }
                    }
                }
                *nextTokPtr = ptr;
                return crate::src::lib::xmltok::XML_TOK_PROLOG_S;
            }
            _ =>
            /* fall through */
            /* fall through */
            /* fall through */
            {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
        }
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            let mut current_block_198: u64;
            match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(1 as libc::c_int as isize),
                    *ptr.offset(0 as libc::c_int as isize),
                )
            } {
                29 => {
                    if namingBitmap[(((namePages
                        [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                        as libc::c_int)
                        << 3 as libc::c_int)
                        + (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            >> 5 as libc::c_int)) as usize]
                        & (1 as libc::c_uint)
                            << (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar
                                as libc::c_int
                                & 0x1f as libc::c_int)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    current_block_198 = 16114569038092921525;
                }
                22 | 24 | 25 | 26 | 27 => {
                    current_block_198 = 16114569038092921525;
                }
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    current_block_198 = 11165907417739823532;
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize);
                    current_block_198 = 11165907417739823532;
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    current_block_198 = 11165907417739823532;
                }
                11 | 32 | 35 | 36 | 20 | 30 | 21 | 9 | 10 => {
                    *nextTokPtr = ptr;
                    return tok;
                }
                23 => {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    match tok {
                        crate::xmltok_h::XML_TOK_NAME => {
                            if !(end.wrapping_offset_from(ptr) as libc::c_long
                                >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                            {
                                return crate::xmltok_h::XML_TOK_PARTIAL;
                            }
                            tok = crate::xmltok_h::XML_TOK_PREFIXED_NAME;
                            let mut current_block_175: u64;
                            match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                                == 0 as libc::c_int
                            {
                                (*(enc as *mut normal_encoding)).type_0
                                    [*ptr as libc::c_uchar as usize]
                                    as libc::c_int
                            } else {
                                unicode_byte_type(
                                    *ptr.offset(1 as libc::c_int as isize),
                                    *ptr.offset(0 as libc::c_int as isize),
                                )
                            } {
                                29 => {
                                    if namingBitmap[(((namePages[*ptr
                                        .offset(1 as libc::c_int as isize)
                                        as libc::c_uchar
                                        as usize]
                                        as libc::c_int)
                                        << 3 as libc::c_int)
                                        + (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar
                                            as libc::c_int
                                            >> 5 as libc::c_int))
                                        as usize]
                                        & (1 as libc::c_uint)
                                            << (*ptr.offset(0 as libc::c_int as isize)
                                                as libc::c_uchar
                                                as libc::c_int
                                                & 0x1f as libc::c_int)
                                        == 0
                                    {
                                        *nextTokPtr = ptr;
                                        return crate::xmltok_h::XML_TOK_INVALID;
                                    }
                                    current_block_175 = 995715539629334807;
                                }
                                22 | 24 | 25 | 26 | 27 => {
                                    current_block_175 = 995715539629334807;
                                }
                                5 => {
                                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                                        < 2 as libc::c_int as libc::c_long
                                    {
                                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                    }
                                    if 0 as libc::c_int == 0 {
                                        *nextTokPtr = ptr;
                                        return crate::xmltok_h::XML_TOK_INVALID;
                                    }
                                    ptr = ptr.offset(2 as libc::c_int as isize);
                                    current_block_175 = 4755552050407867010;
                                }
                                6 => {
                                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                                        < 3 as libc::c_int as libc::c_long
                                    {
                                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                    }
                                    if 0 as libc::c_int == 0 {
                                        *nextTokPtr = ptr;
                                        return crate::xmltok_h::XML_TOK_INVALID;
                                    }
                                    ptr = ptr.offset(3 as libc::c_int as isize);
                                    current_block_175 = 4755552050407867010;
                                }
                                7 => {
                                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                                        < 4 as libc::c_int as libc::c_long
                                    {
                                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                    }
                                    if 0 as libc::c_int == 0 {
                                        *nextTokPtr = ptr;
                                        return crate::xmltok_h::XML_TOK_INVALID;
                                    }
                                    ptr = ptr.offset(4 as libc::c_int as isize);
                                    current_block_175 = 4755552050407867010;
                                }
                                _ => {
                                    tok = crate::xmltok_h::XML_TOK_NMTOKEN;
                                    current_block_175 = 4755552050407867010;
                                }
                            }
                            match current_block_175 {
                                995715539629334807 => ptr = ptr.offset(2 as libc::c_int as isize),
                                _ => {}
                            }
                        }
                        crate::xmltok_h::XML_TOK_PREFIXED_NAME => {
                            tok = crate::xmltok_h::XML_TOK_NMTOKEN
                        }
                        _ => {}
                    }
                    current_block_198 = 11165907417739823532;
                }
                34 => {
                    if tok == crate::xmltok_h::XML_TOK_NMTOKEN {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                    return crate::xmltok_h::XML_TOK_NAME_PLUS;
                }
                33 => {
                    if tok == crate::xmltok_h::XML_TOK_NMTOKEN {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                    return crate::xmltok_h::XML_TOK_NAME_ASTERISK;
                }
                15 => {
                    if tok == crate::xmltok_h::XML_TOK_NMTOKEN {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                    return crate::xmltok_h::XML_TOK_NAME_QUESTION;
                }
                _ => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
            }
            match current_block_198 {
                16114569038092921525 => ptr = ptr.offset(2 as libc::c_int as isize),
                _ => {}
            }
        }
        return -tok;
    }

    pub unsafe extern "C" fn normal_prologTok(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        let mut tok: libc::c_int = 0;
        if ptr >= end {
            return crate::xmltok_h::XML_TOK_NONE;
        }
        if 1 as libc::c_int > 1 as libc::c_int {
            let mut n: crate::stddef_h::size_t =
                end.wrapping_offset_from(ptr) as libc::c_long as crate::stddef_h::size_t;
            if n & (1 as libc::c_int - 1 as libc::c_int) as libc::c_ulong != 0 {
                n &= !(1 as libc::c_int - 1 as libc::c_int) as libc::c_ulong;
                if n == 0 as libc::c_int as libc::c_ulong {
                    return crate::xmltok_h::XML_TOK_PARTIAL;
                }
                end = ptr.offset(n as isize)
            }
        }
        let mut current_block_112: u64;
        match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize] as libc::c_int
        {
            12 => {
                return normal_scanLit(
                    crate::xmltok_impl_h::BT_QUOT as libc::c_int,
                    enc,
                    ptr.offset(1 as libc::c_int as isize),
                    end,
                    nextTokPtr,
                )
            }
            13 => {
                return normal_scanLit(
                    crate::xmltok_impl_h::BT_APOS as libc::c_int,
                    enc,
                    ptr.offset(1 as libc::c_int as isize),
                    end,
                    nextTokPtr,
                )
            }
            2 => {
                ptr = ptr.offset(1 as libc::c_int as isize);
                if !(end.wrapping_offset_from(ptr) as libc::c_long
                    >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL;
                }
                match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                    as libc::c_int
                {
                    16 => {
                        return normal_scanDecl(
                            enc,
                            ptr.offset(1 as libc::c_int as isize),
                            end,
                            nextTokPtr,
                        )
                    }
                    15 => {
                        return normal_scanPi(
                            enc,
                            ptr.offset(1 as libc::c_int as isize),
                            end,
                            nextTokPtr,
                        )
                    }
                    22 | 24 | 29 | 5 | 6 | 7 => {
                        *nextTokPtr = ptr.offset(-(1 as libc::c_int as isize));
                        return crate::src::lib::xmltok::XML_TOK_INSTANCE_START;
                    }
                    _ => {}
                }
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
            9 => {
                if ptr.offset(1 as libc::c_int as isize) == end {
                    *nextTokPtr = end;
                    return -crate::src::lib::xmltok::XML_TOK_PROLOG_S;
                }
                current_block_112 = 12267575154421147267;
            }
            21 | 10 => {
                current_block_112 = 12267575154421147267;
            }
            30 => {
                return normal_scanPercent(
                    enc,
                    ptr.offset(1 as libc::c_int as isize),
                    end,
                    nextTokPtr,
                )
            }
            35 => {
                *nextTokPtr = ptr.offset(1 as libc::c_int as isize);
                return crate::xmltok_h::XML_TOK_COMMA;
            }
            20 => {
                *nextTokPtr = ptr.offset(1 as libc::c_int as isize);
                return crate::xmltok_h::XML_TOK_OPEN_BRACKET;
            }
            4 => {
                ptr = ptr.offset(1 as libc::c_int as isize);
                if !(end.wrapping_offset_from(ptr) as libc::c_long
                    >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                {
                    return -crate::xmltok_h::XML_TOK_CLOSE_BRACKET;
                }
                if *ptr as libc::c_int == 0x5d as libc::c_int {
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (2 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL;
                    }
                    if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0x3e as libc::c_int
                    {
                        *nextTokPtr = ptr.offset((2 as libc::c_int * 1 as libc::c_int) as isize);
                        return crate::xmltok_h::XML_TOK_COND_SECT_CLOSE;
                    }
                }
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_CLOSE_BRACKET;
            }
            31 => {
                *nextTokPtr = ptr.offset(1 as libc::c_int as isize);
                return crate::xmltok_h::XML_TOK_OPEN_PAREN;
            }
            32 => {
                ptr = ptr.offset(1 as libc::c_int as isize);
                if !(end.wrapping_offset_from(ptr) as libc::c_long
                    >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                {
                    return -crate::xmltok_h::XML_TOK_CLOSE_PAREN;
                }
                match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                    as libc::c_int
                {
                    33 => {
                        *nextTokPtr = ptr.offset(1 as libc::c_int as isize);
                        return crate::xmltok_h::XML_TOK_CLOSE_PAREN_ASTERISK;
                    }
                    15 => {
                        *nextTokPtr = ptr.offset(1 as libc::c_int as isize);
                        return crate::xmltok_h::XML_TOK_CLOSE_PAREN_QUESTION;
                    }
                    34 => {
                        *nextTokPtr = ptr.offset(1 as libc::c_int as isize);
                        return crate::xmltok_h::XML_TOK_CLOSE_PAREN_PLUS;
                    }
                    9 | 10 | 21 | 11 | 35 | 36 | 32 => {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_CLOSE_PAREN;
                    }
                    _ => {}
                }
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
            36 => {
                *nextTokPtr = ptr.offset(1 as libc::c_int as isize);
                return crate::xmltok_h::XML_TOK_OR;
            }
            11 => {
                *nextTokPtr = ptr.offset(1 as libc::c_int as isize);
                return crate::xmltok_h::XML_TOK_DECL_CLOSE;
            }
            19 => {
                return normal_scanPoundName(
                    enc,
                    ptr.offset(1 as libc::c_int as isize),
                    end,
                    nextTokPtr,
                )
            }
            5 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 2 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if (*(enc as *const normal_encoding))
                    .isNmstrt2
                    .expect("non-null function pointer")(enc, ptr)
                    != 0
                {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    tok = crate::xmltok_h::XML_TOK_NAME
                } else if (*(enc as *const normal_encoding))
                    .isName2
                    .expect("non-null function pointer")(enc, ptr)
                    != 0
                {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    tok = crate::xmltok_h::XML_TOK_NMTOKEN
                } else {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                current_block_112 = 2222055338596505704;
            }
            6 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 3 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if (*(enc as *const normal_encoding))
                    .isNmstrt3
                    .expect("non-null function pointer")(enc, ptr)
                    != 0
                {
                    ptr = ptr.offset(3 as libc::c_int as isize);
                    tok = crate::xmltok_h::XML_TOK_NAME
                } else if (*(enc as *const normal_encoding))
                    .isName3
                    .expect("non-null function pointer")(enc, ptr)
                    != 0
                {
                    ptr = ptr.offset(3 as libc::c_int as isize);
                    tok = crate::xmltok_h::XML_TOK_NMTOKEN
                } else {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                current_block_112 = 2222055338596505704;
            }
            7 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                if (*(enc as *const normal_encoding))
                    .isNmstrt4
                    .expect("non-null function pointer")(enc, ptr)
                    != 0
                {
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    tok = crate::xmltok_h::XML_TOK_NAME
                } else if (*(enc as *const normal_encoding))
                    .isName4
                    .expect("non-null function pointer")(enc, ptr)
                    != 0
                {
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    tok = crate::xmltok_h::XML_TOK_NMTOKEN
                } else {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                current_block_112 = 2222055338596505704;
            }
            22 | 24 => {
                tok = crate::xmltok_h::XML_TOK_NAME;
                ptr = ptr.offset(1 as libc::c_int as isize);
                current_block_112 = 2222055338596505704;
            }
            25 | 26 | 27 | 23 => {
                tok = crate::xmltok_h::XML_TOK_NMTOKEN;
                ptr = ptr.offset(1 as libc::c_int as isize);
                current_block_112 = 2222055338596505704;
            }
            29 | _ => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
        }
        match current_block_112 {
            2222055338596505704 => {}
            _ => {
                loop {
                    ptr = ptr.offset(1 as libc::c_int as isize);
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                    {
                        break;
                    }
                    let mut current_block_32: u64;
                    match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                        as libc::c_int
                    {
                        21 | 10 => {
                            current_block_32 = 14072441030219150333;
                        }
                        9 => {
                            if ptr.offset(1 as libc::c_int as isize) != end {
                                current_block_32 = 14072441030219150333;
                            } else {
                                current_block_32 = 1184991590081026370;
                            }
                        }
                        _ => {
                            current_block_32 = 1184991590081026370;
                        }
                    }
                    match current_block_32 {
                        14072441030219150333 => {}
                        _ => {
                            *nextTokPtr = ptr;
                            return crate::src::lib::xmltok::XML_TOK_PROLOG_S;
                        }
                    }
                }
                *nextTokPtr = ptr;
                return crate::src::lib::xmltok::XML_TOK_PROLOG_S;
            }
        }
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long
        {
            let mut current_block_198: u64;
            match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                as libc::c_int
            {
                29 => {
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    current_block_198 = 17381770869190098083;
                }
                22 | 24 | 25 | 26 | 27 => {
                    current_block_198 = 17381770869190098083;
                }
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if (*(enc as *const normal_encoding))
                        .isName2
                        .expect("non-null function pointer")(enc, ptr)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    current_block_198 = 11165907417739823532;
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if (*(enc as *const normal_encoding))
                        .isName3
                        .expect("non-null function pointer")(enc, ptr)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize);
                    current_block_198 = 11165907417739823532;
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if (*(enc as *const normal_encoding))
                        .isName4
                        .expect("non-null function pointer")(enc, ptr)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    current_block_198 = 11165907417739823532;
                }
                11 | 32 | 35 | 36 | 20 | 30 | 21 | 9 | 10 => {
                    *nextTokPtr = ptr;
                    return tok;
                }
                23 => {
                    ptr = ptr.offset(1 as libc::c_int as isize);
                    match tok {
                        crate::xmltok_h::XML_TOK_NAME => {
                            if !(end.wrapping_offset_from(ptr) as libc::c_long
                                >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                            {
                                return crate::xmltok_h::XML_TOK_PARTIAL;
                            }
                            tok = crate::xmltok_h::XML_TOK_PREFIXED_NAME;
                            let mut current_block_175: u64;
                            match (*(enc as *mut normal_encoding)).type_0
                                [*ptr as libc::c_uchar as usize]
                                as libc::c_int
                            {
                                29 => {
                                    if 0 as libc::c_int == 0 {
                                        *nextTokPtr = ptr;
                                        return crate::xmltok_h::XML_TOK_INVALID;
                                    }
                                    current_block_175 = 8121321173029633297;
                                }
                                22 | 24 | 25 | 26 | 27 => {
                                    current_block_175 = 8121321173029633297;
                                }
                                5 => {
                                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                                        < 2 as libc::c_int as libc::c_long
                                    {
                                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                    }
                                    if (*(enc as *const normal_encoding))
                                        .isName2
                                        .expect("non-null function pointer")(
                                        enc, ptr
                                    ) == 0
                                    {
                                        *nextTokPtr = ptr;
                                        return crate::xmltok_h::XML_TOK_INVALID;
                                    }
                                    ptr = ptr.offset(2 as libc::c_int as isize);
                                    current_block_175 = 4755552050407867010;
                                }
                                6 => {
                                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                                        < 3 as libc::c_int as libc::c_long
                                    {
                                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                    }
                                    if (*(enc as *const normal_encoding))
                                        .isName3
                                        .expect("non-null function pointer")(
                                        enc, ptr
                                    ) == 0
                                    {
                                        *nextTokPtr = ptr;
                                        return crate::xmltok_h::XML_TOK_INVALID;
                                    }
                                    ptr = ptr.offset(3 as libc::c_int as isize);
                                    current_block_175 = 4755552050407867010;
                                }
                                7 => {
                                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                                        < 4 as libc::c_int as libc::c_long
                                    {
                                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                    }
                                    if (*(enc as *const normal_encoding))
                                        .isName4
                                        .expect("non-null function pointer")(
                                        enc, ptr
                                    ) == 0
                                    {
                                        *nextTokPtr = ptr;
                                        return crate::xmltok_h::XML_TOK_INVALID;
                                    }
                                    ptr = ptr.offset(4 as libc::c_int as isize);
                                    current_block_175 = 4755552050407867010;
                                }
                                _ => {
                                    tok = crate::xmltok_h::XML_TOK_NMTOKEN;
                                    current_block_175 = 4755552050407867010;
                                }
                            }
                            match current_block_175 {
                                8121321173029633297 => ptr = ptr.offset(1 as libc::c_int as isize),
                                _ => {}
                            }
                        }
                        crate::xmltok_h::XML_TOK_PREFIXED_NAME => {
                            tok = crate::xmltok_h::XML_TOK_NMTOKEN
                        }
                        _ => {}
                    }
                    current_block_198 = 11165907417739823532;
                }
                34 => {
                    if tok == crate::xmltok_h::XML_TOK_NMTOKEN {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    *nextTokPtr = ptr.offset(1 as libc::c_int as isize);
                    return crate::xmltok_h::XML_TOK_NAME_PLUS;
                }
                33 => {
                    if tok == crate::xmltok_h::XML_TOK_NMTOKEN {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    *nextTokPtr = ptr.offset(1 as libc::c_int as isize);
                    return crate::xmltok_h::XML_TOK_NAME_ASTERISK;
                }
                15 => {
                    if tok == crate::xmltok_h::XML_TOK_NMTOKEN {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    *nextTokPtr = ptr.offset(1 as libc::c_int as isize);
                    return crate::xmltok_h::XML_TOK_NAME_QUESTION;
                }
                _ => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
            }
            match current_block_198 {
                17381770869190098083 => ptr = ptr.offset(1 as libc::c_int as isize),
                _ => {}
            }
        }
        return -tok;
    }

    pub unsafe extern "C" fn big2_prologTok(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        let mut tok: libc::c_int = 0;
        if ptr >= end {
            return crate::xmltok_h::XML_TOK_NONE;
        }
        if 2 as libc::c_int > 1 as libc::c_int {
            let mut n: crate::stddef_h::size_t =
                end.wrapping_offset_from(ptr) as libc::c_long as crate::stddef_h::size_t;
            if n & (2 as libc::c_int - 1 as libc::c_int) as libc::c_ulong != 0 {
                n &= !(2 as libc::c_int - 1 as libc::c_int) as libc::c_ulong;
                if n == 0 as libc::c_int as libc::c_ulong {
                    return crate::xmltok_h::XML_TOK_PARTIAL;
                }
                end = ptr.offset(n as isize)
            }
        }
        let mut current_block_112: u64;
        match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
            (*(enc as *mut normal_encoding)).type_0
                [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                as libc::c_int
        } else {
            unicode_byte_type(
                *ptr.offset(0 as libc::c_int as isize),
                *ptr.offset(1 as libc::c_int as isize),
            )
        } {
            12 => {
                return big2_scanLit(
                    crate::xmltok_impl_h::BT_QUOT as libc::c_int,
                    enc,
                    ptr.offset(2 as libc::c_int as isize),
                    end,
                    nextTokPtr,
                )
            }
            13 => {
                return big2_scanLit(
                    crate::xmltok_impl_h::BT_APOS as libc::c_int,
                    enc,
                    ptr.offset(2 as libc::c_int as isize),
                    end,
                    nextTokPtr,
                )
            }
            2 => {
                ptr = ptr.offset(2 as libc::c_int as isize);
                if !(end.wrapping_offset_from(ptr) as libc::c_long
                    >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL;
                }
                match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                    (*(enc as *mut normal_encoding)).type_0
                        [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                        as libc::c_int
                } else {
                    unicode_byte_type(
                        *ptr.offset(0 as libc::c_int as isize),
                        *ptr.offset(1 as libc::c_int as isize),
                    )
                } {
                    16 => {
                        return big2_scanDecl(
                            enc,
                            ptr.offset(2 as libc::c_int as isize),
                            end,
                            nextTokPtr,
                        )
                    }
                    15 => {
                        return big2_scanPi(
                            enc,
                            ptr.offset(2 as libc::c_int as isize),
                            end,
                            nextTokPtr,
                        )
                    }
                    22 | 24 | 29 | 5 | 6 | 7 => {
                        *nextTokPtr = ptr.offset(-(2 as libc::c_int as isize));
                        return crate::src::lib::xmltok::XML_TOK_INSTANCE_START;
                    }
                    _ => {}
                }
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
            9 => {
                if ptr.offset(2 as libc::c_int as isize) == end {
                    *nextTokPtr = end;
                    return -crate::src::lib::xmltok::XML_TOK_PROLOG_S;
                }
                current_block_112 = 6797528435482537081;
            }
            21 | 10 => {
                current_block_112 = 6797528435482537081;
            }
            30 => {
                return big2_scanPercent(
                    enc,
                    ptr.offset(2 as libc::c_int as isize),
                    end,
                    nextTokPtr,
                )
            }
            35 => {
                *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                return crate::xmltok_h::XML_TOK_COMMA;
            }
            20 => {
                *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                return crate::xmltok_h::XML_TOK_OPEN_BRACKET;
            }
            4 => {
                ptr = ptr.offset(2 as libc::c_int as isize);
                if !(end.wrapping_offset_from(ptr) as libc::c_long
                    >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                {
                    return -crate::xmltok_h::XML_TOK_CLOSE_BRACKET;
                }
                if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                    && *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0x5d as libc::c_int
                {
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (2 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL;
                    }
                    if *ptr
                        .offset(2 as libc::c_int as isize)
                        .offset(0 as libc::c_int as isize) as libc::c_int
                        == 0 as libc::c_int
                        && *ptr
                            .offset(2 as libc::c_int as isize)
                            .offset(1 as libc::c_int as isize)
                            as libc::c_int
                            == 0x3e as libc::c_int
                    {
                        *nextTokPtr = ptr.offset((2 as libc::c_int * 2 as libc::c_int) as isize);
                        return crate::xmltok_h::XML_TOK_COND_SECT_CLOSE;
                    }
                }
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_CLOSE_BRACKET;
            }
            31 => {
                *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                return crate::xmltok_h::XML_TOK_OPEN_PAREN;
            }
            32 => {
                ptr = ptr.offset(2 as libc::c_int as isize);
                if !(end.wrapping_offset_from(ptr) as libc::c_long
                    >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                {
                    return -crate::xmltok_h::XML_TOK_CLOSE_PAREN;
                }
                match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                    (*(enc as *mut normal_encoding)).type_0
                        [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                        as libc::c_int
                } else {
                    unicode_byte_type(
                        *ptr.offset(0 as libc::c_int as isize),
                        *ptr.offset(1 as libc::c_int as isize),
                    )
                } {
                    33 => {
                        *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                        return crate::xmltok_h::XML_TOK_CLOSE_PAREN_ASTERISK;
                    }
                    15 => {
                        *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                        return crate::xmltok_h::XML_TOK_CLOSE_PAREN_QUESTION;
                    }
                    34 => {
                        *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                        return crate::xmltok_h::XML_TOK_CLOSE_PAREN_PLUS;
                    }
                    9 | 10 | 21 | 11 | 35 | 36 | 32 => {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_CLOSE_PAREN;
                    }
                    _ => {}
                }
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
            36 => {
                *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                return crate::xmltok_h::XML_TOK_OR;
            }
            11 => {
                *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                return crate::xmltok_h::XML_TOK_DECL_CLOSE;
            }
            19 => {
                return big2_scanPoundName(
                    enc,
                    ptr.offset(2 as libc::c_int as isize),
                    end,
                    nextTokPtr,
                )
            }
            5 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 2 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
            6 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 3 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
            7 => {
                if (end.wrapping_offset_from(ptr) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                }
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
            22 | 24 => {
                tok = crate::xmltok_h::XML_TOK_NAME;
                ptr = ptr.offset(2 as libc::c_int as isize);
                current_block_112 = 2222055338596505704;
            }
            25 | 26 | 27 | 23 => {
                tok = crate::xmltok_h::XML_TOK_NMTOKEN;
                ptr = ptr.offset(2 as libc::c_int as isize);
                current_block_112 = 2222055338596505704;
            }
            29 => {
                if namingBitmap[(((nmstrtPages
                    [*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int)
                    << 3 as libc::c_int)
                    + (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                        >> 5 as libc::c_int)) as usize]
                    & (1 as libc::c_uint)
                        << (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            & 0x1f as libc::c_int)
                    != 0
                {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    tok = crate::xmltok_h::XML_TOK_NAME;
                    current_block_112 = 2222055338596505704;
                } else if namingBitmap[(((namePages
                    [*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int)
                    << 3 as libc::c_int)
                    + (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                        >> 5 as libc::c_int)) as usize]
                    & (1 as libc::c_uint)
                        << (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            & 0x1f as libc::c_int)
                    != 0
                {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    tok = crate::xmltok_h::XML_TOK_NMTOKEN;
                    current_block_112 = 2222055338596505704;
                } else {
                    current_block_112 = 9687627612024382126;
                }
            }
            _ => {
                current_block_112 = 9687627612024382126;
            }
        }
        match current_block_112 {
            2222055338596505704 => {}
            6797528435482537081 => {
                loop {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                    {
                        break;
                    }
                    let mut current_block_32: u64;
                    match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                        == 0 as libc::c_int
                    {
                        (*(enc as *mut normal_encoding)).type_0
                            [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                            as libc::c_int
                    } else {
                        unicode_byte_type(
                            *ptr.offset(0 as libc::c_int as isize),
                            *ptr.offset(1 as libc::c_int as isize),
                        )
                    } {
                        21 | 10 => {
                            current_block_32 = 14072441030219150333;
                        }
                        9 => {
                            if ptr.offset(2 as libc::c_int as isize) != end {
                                current_block_32 = 14072441030219150333;
                            } else {
                                current_block_32 = 13880765133914978832;
                            }
                        }
                        _ => {
                            current_block_32 = 13880765133914978832;
                        }
                    }
                    match current_block_32 {
                        14072441030219150333 => {}
                        _ => {
                            *nextTokPtr = ptr;
                            return crate::src::lib::xmltok::XML_TOK_PROLOG_S;
                        }
                    }
                }
                *nextTokPtr = ptr;
                return crate::src::lib::xmltok::XML_TOK_PROLOG_S;
            }
            _ => {
                *nextTokPtr = ptr;
                return crate::xmltok_h::XML_TOK_INVALID;
            }
        }
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            let mut current_block_198: u64;
            match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0
                    [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(0 as libc::c_int as isize),
                    *ptr.offset(1 as libc::c_int as isize),
                )
            } {
                29 => {
                    if namingBitmap[(((namePages
                        [*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as usize]
                        as libc::c_int)
                        << 3 as libc::c_int)
                        + (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            >> 5 as libc::c_int)) as usize]
                        & (1 as libc::c_uint)
                            << (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar
                                as libc::c_int
                                & 0x1f as libc::c_int)
                        == 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    current_block_198 = 14255987127689470057;
                }
                22 | 24 | 25 | 26 | 27 => {
                    current_block_198 = 14255987127689470057;
                }
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    current_block_198 = 11165907417739823532;
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize);
                    current_block_198 = 11165907417739823532;
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if 0 as libc::c_int == 0 {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize);
                    current_block_198 = 11165907417739823532;
                }
                11 | 32 | 35 | 36 | 20 | 30 | 21 | 9 | 10 => {
                    *nextTokPtr = ptr;
                    return tok;
                }
                23 => {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    match tok {
                        crate::xmltok_h::XML_TOK_NAME => {
                            if !(end.wrapping_offset_from(ptr) as libc::c_long
                                >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                            {
                                return crate::xmltok_h::XML_TOK_PARTIAL;
                            }
                            tok = crate::xmltok_h::XML_TOK_PREFIXED_NAME;
                            let mut current_block_175: u64;
                            match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                                == 0 as libc::c_int
                            {
                                (*(enc as *mut normal_encoding)).type_0[*ptr
                                    .offset(1 as libc::c_int as isize)
                                    as libc::c_uchar
                                    as usize] as libc::c_int
                            } else {
                                unicode_byte_type(
                                    *ptr.offset(0 as libc::c_int as isize),
                                    *ptr.offset(1 as libc::c_int as isize),
                                )
                            } {
                                29 => {
                                    if namingBitmap[(((namePages[*ptr
                                        .offset(0 as libc::c_int as isize)
                                        as libc::c_uchar
                                        as usize]
                                        as libc::c_int)
                                        << 3 as libc::c_int)
                                        + (*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar
                                            as libc::c_int
                                            >> 5 as libc::c_int))
                                        as usize]
                                        & (1 as libc::c_uint)
                                            << (*ptr.offset(1 as libc::c_int as isize)
                                                as libc::c_uchar
                                                as libc::c_int
                                                & 0x1f as libc::c_int)
                                        == 0
                                    {
                                        *nextTokPtr = ptr;
                                        return crate::xmltok_h::XML_TOK_INVALID;
                                    }
                                    current_block_175 = 17746292690483154078;
                                }
                                22 | 24 | 25 | 26 | 27 => {
                                    current_block_175 = 17746292690483154078;
                                }
                                5 => {
                                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                                        < 2 as libc::c_int as libc::c_long
                                    {
                                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                    }
                                    if 0 as libc::c_int == 0 {
                                        *nextTokPtr = ptr;
                                        return crate::xmltok_h::XML_TOK_INVALID;
                                    }
                                    ptr = ptr.offset(2 as libc::c_int as isize);
                                    current_block_175 = 4755552050407867010;
                                }
                                6 => {
                                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                                        < 3 as libc::c_int as libc::c_long
                                    {
                                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                    }
                                    if 0 as libc::c_int == 0 {
                                        *nextTokPtr = ptr;
                                        return crate::xmltok_h::XML_TOK_INVALID;
                                    }
                                    ptr = ptr.offset(3 as libc::c_int as isize);
                                    current_block_175 = 4755552050407867010;
                                }
                                7 => {
                                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                                        < 4 as libc::c_int as libc::c_long
                                    {
                                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                                    }
                                    if 0 as libc::c_int == 0 {
                                        *nextTokPtr = ptr;
                                        return crate::xmltok_h::XML_TOK_INVALID;
                                    }
                                    ptr = ptr.offset(4 as libc::c_int as isize);
                                    current_block_175 = 4755552050407867010;
                                }
                                _ => {
                                    tok = crate::xmltok_h::XML_TOK_NMTOKEN;
                                    current_block_175 = 4755552050407867010;
                                }
                            }
                            match current_block_175 {
                                17746292690483154078 => ptr = ptr.offset(2 as libc::c_int as isize),
                                _ => {}
                            }
                        }
                        crate::xmltok_h::XML_TOK_PREFIXED_NAME => {
                            tok = crate::xmltok_h::XML_TOK_NMTOKEN
                        }
                        _ => {}
                    }
                    current_block_198 = 11165907417739823532;
                }
                34 => {
                    if tok == crate::xmltok_h::XML_TOK_NMTOKEN {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                    return crate::xmltok_h::XML_TOK_NAME_PLUS;
                }
                33 => {
                    if tok == crate::xmltok_h::XML_TOK_NMTOKEN {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                    return crate::xmltok_h::XML_TOK_NAME_ASTERISK;
                }
                15 => {
                    if tok == crate::xmltok_h::XML_TOK_NMTOKEN {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                    return crate::xmltok_h::XML_TOK_NAME_QUESTION;
                }
                _ => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
            }
            match current_block_198 {
                14255987127689470057 => ptr = ptr.offset(2 as libc::c_int as isize),
                _ => {}
            }
        }
        return -tok;
    }

    pub unsafe extern "C" fn normal_attributeValueTok(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        let mut start: *const libc::c_char = 0 as *const libc::c_char;
        if ptr >= end {
            return crate::xmltok_h::XML_TOK_NONE;
        } else {
            if !(end.wrapping_offset_from(ptr) as libc::c_long
                >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
            {
                /* This line cannot be executed.  The incoming data has already
                 * been tokenized once, so incomplete characters like this have
                 * already been eliminated from the input.  Retaining the paranoia
                 * check is still valuable, however.
                 */
                /* This line cannot be executed.  The incoming data has already
                 * been tokenized once, so incomplete characters like this have
                 * already been eliminated from the input.  Retaining the paranoia
                 * check is still valuable, however.
                 */
                /* This line cannot be executed.  The incoming data has already
                 * been tokenized once, so incomplete characters like this have
                 * already been eliminated from the input.  Retaining the paranoia
                 * check is still valuable, however.
                 */
                return crate::xmltok_h::XML_TOK_PARTIAL;
                /* LCOV_EXCL_LINE */
                /* LCOV_EXCL_LINE */
                /* LCOV_EXCL_LINE */
            }
        }
        start = ptr;
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long
        {
            match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                as libc::c_int
            {
                5 => ptr = ptr.offset(2 as libc::c_int as isize),
                6 => ptr = ptr.offset(3 as libc::c_int as isize),
                7 => ptr = ptr.offset(4 as libc::c_int as isize),
                3 => {
                    if ptr == start {
                        return normal_scanRef(
                            enc,
                            ptr.offset(1 as libc::c_int as isize),
                            end,
                            nextTokPtr,
                        );
                    }
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_DATA_CHARS;
                }
                2 => {
                    /* this is for inside entity references */
                    /* this is for inside entity references */
                    /* this is for inside entity references */
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                10 => {
                    if ptr == start {
                        *nextTokPtr = ptr.offset(1 as libc::c_int as isize);
                        return crate::xmltok_h::XML_TOK_DATA_NEWLINE;
                    }
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_DATA_CHARS;
                }
                9 => {
                    if ptr == start {
                        ptr = ptr.offset(1 as libc::c_int as isize);
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                        {
                            return crate::xmltok_h::XML_TOK_TRAILING_CR;
                        }
                        if (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                            as libc::c_int
                            == crate::xmltok_impl_h::BT_LF as libc::c_int
                        {
                            ptr = ptr.offset(1 as libc::c_int as isize)
                        }
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_DATA_NEWLINE;
                    }
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_DATA_CHARS;
                }
                21 => {
                    if ptr == start {
                        *nextTokPtr = ptr.offset(1 as libc::c_int as isize);
                        return crate::xmltok_h::XML_TOK_ATTRIBUTE_VALUE_S;
                    }
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_DATA_CHARS;
                }
                _ => ptr = ptr.offset(1 as libc::c_int as isize),
            }
        }
        *nextTokPtr = ptr;
        return crate::xmltok_h::XML_TOK_DATA_CHARS;
    }

    pub unsafe extern "C" fn big2_attributeValueTok(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        let mut start: *const libc::c_char = 0 as *const libc::c_char;
        if ptr >= end {
            return crate::xmltok_h::XML_TOK_NONE;
        } else {
            if !(end.wrapping_offset_from(ptr) as libc::c_long
                >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
            {
                return crate::xmltok_h::XML_TOK_PARTIAL;
            }
        }
        start = ptr;
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0
                    [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(0 as libc::c_int as isize),
                    *ptr.offset(1 as libc::c_int as isize),
                )
            } {
                5 => ptr = ptr.offset(2 as libc::c_int as isize),
                6 => ptr = ptr.offset(3 as libc::c_int as isize),
                7 => ptr = ptr.offset(4 as libc::c_int as isize),
                3 => {
                    if ptr == start {
                        return big2_scanRef(
                            enc,
                            ptr.offset(2 as libc::c_int as isize),
                            end,
                            nextTokPtr,
                        );
                    }
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_DATA_CHARS;
                }
                2 => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                10 => {
                    if ptr == start {
                        *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                        return crate::xmltok_h::XML_TOK_DATA_NEWLINE;
                    }
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_DATA_CHARS;
                }
                9 => {
                    if ptr == start {
                        ptr = ptr.offset(2 as libc::c_int as isize);
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                        {
                            return crate::xmltok_h::XML_TOK_TRAILING_CR;
                        }
                        if (if *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                            == 0 as libc::c_int
                        {
                            (*(enc as *mut normal_encoding)).type_0
                                [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                                as libc::c_int
                        } else {
                            unicode_byte_type(
                                *ptr.offset(0 as libc::c_int as isize),
                                *ptr.offset(1 as libc::c_int as isize),
                            )
                        }) == crate::xmltok_impl_h::BT_LF as libc::c_int
                        {
                            ptr = ptr.offset(2 as libc::c_int as isize)
                        }
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_DATA_NEWLINE;
                    }
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_DATA_CHARS;
                }
                21 => {
                    if ptr == start {
                        *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                        return crate::xmltok_h::XML_TOK_ATTRIBUTE_VALUE_S;
                    }
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_DATA_CHARS;
                }
                _ => ptr = ptr.offset(2 as libc::c_int as isize),
            }
        }
        *nextTokPtr = ptr;
        return crate::xmltok_h::XML_TOK_DATA_CHARS;
    }

    pub unsafe extern "C" fn little2_attributeValueTok(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        let mut start: *const libc::c_char = 0 as *const libc::c_char;
        if ptr >= end {
            return crate::xmltok_h::XML_TOK_NONE;
        } else {
            if !(end.wrapping_offset_from(ptr) as libc::c_long
                >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
            {
                return crate::xmltok_h::XML_TOK_PARTIAL;
            }
        }
        start = ptr;
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(1 as libc::c_int as isize),
                    *ptr.offset(0 as libc::c_int as isize),
                )
            } {
                5 => ptr = ptr.offset(2 as libc::c_int as isize),
                6 => ptr = ptr.offset(3 as libc::c_int as isize),
                7 => ptr = ptr.offset(4 as libc::c_int as isize),
                3 => {
                    if ptr == start {
                        return little2_scanRef(
                            enc,
                            ptr.offset(2 as libc::c_int as isize),
                            end,
                            nextTokPtr,
                        );
                    }
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_DATA_CHARS;
                }
                2 => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                10 => {
                    if ptr == start {
                        *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                        return crate::xmltok_h::XML_TOK_DATA_NEWLINE;
                    }
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_DATA_CHARS;
                }
                9 => {
                    if ptr == start {
                        ptr = ptr.offset(2 as libc::c_int as isize);
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                        {
                            return crate::xmltok_h::XML_TOK_TRAILING_CR;
                        }
                        if (if *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                            == 0 as libc::c_int
                        {
                            (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                                as libc::c_int
                        } else {
                            unicode_byte_type(
                                *ptr.offset(1 as libc::c_int as isize),
                                *ptr.offset(0 as libc::c_int as isize),
                            )
                        }) == crate::xmltok_impl_h::BT_LF as libc::c_int
                        {
                            ptr = ptr.offset(2 as libc::c_int as isize)
                        }
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_DATA_NEWLINE;
                    }
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_DATA_CHARS;
                }
                21 => {
                    if ptr == start {
                        *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                        return crate::xmltok_h::XML_TOK_ATTRIBUTE_VALUE_S;
                    }
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_DATA_CHARS;
                }
                _ => ptr = ptr.offset(2 as libc::c_int as isize),
            }
        }
        *nextTokPtr = ptr;
        return crate::xmltok_h::XML_TOK_DATA_CHARS;
    }

    pub unsafe extern "C" fn big2_entityValueTok(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        let mut start: *const libc::c_char = 0 as *const libc::c_char;
        if ptr >= end {
            return crate::xmltok_h::XML_TOK_NONE;
        } else {
            if !(end.wrapping_offset_from(ptr) as libc::c_long
                >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
            {
                /* This line cannot be executed.  The incoming data has already
                 * been tokenized once, so incomplete characters like this have
                 * already been eliminated from the input.  Retaining the paranoia
                 * check is still valuable, however.
                 */
                /* This line cannot be executed.  The incoming data has already
                 * been tokenized once, so incomplete characters like this have
                 * already been eliminated from the input.  Retaining the paranoia
                 * check is still valuable, however.
                 */
                /* This line cannot be executed.  The incoming data has already
                 * been tokenized once, so incomplete characters like this have
                 * already been eliminated from the input.  Retaining the paranoia
                 * check is still valuable, however.
                 */
                return crate::xmltok_h::XML_TOK_PARTIAL;
                /* LCOV_EXCL_LINE */
                /* LCOV_EXCL_LINE */
                /* LCOV_EXCL_LINE */
            }
        }
        start = ptr;
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0
                    [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(0 as libc::c_int as isize),
                    *ptr.offset(1 as libc::c_int as isize),
                )
            } {
                5 => ptr = ptr.offset(2 as libc::c_int as isize),
                6 => ptr = ptr.offset(3 as libc::c_int as isize),
                7 => ptr = ptr.offset(4 as libc::c_int as isize),
                3 => {
                    if ptr == start {
                        return big2_scanRef(
                            enc,
                            ptr.offset(2 as libc::c_int as isize),
                            end,
                            nextTokPtr,
                        );
                    }
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_DATA_CHARS;
                }
                30 => {
                    if ptr == start {
                        let mut tok: libc::c_int = big2_scanPercent(
                            enc,
                            ptr.offset(2 as libc::c_int as isize),
                            end,
                            nextTokPtr,
                        );
                        return if tok == crate::xmltok_h::XML_TOK_PERCENT {
                            crate::xmltok_h::XML_TOK_INVALID
                        } else {
                            tok
                        };
                    }
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_DATA_CHARS;
                }
                10 => {
                    if ptr == start {
                        *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                        return crate::xmltok_h::XML_TOK_DATA_NEWLINE;
                    }
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_DATA_CHARS;
                }
                9 => {
                    if ptr == start {
                        ptr = ptr.offset(2 as libc::c_int as isize);
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                        {
                            return crate::xmltok_h::XML_TOK_TRAILING_CR;
                        }
                        if (if *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                            == 0 as libc::c_int
                        {
                            (*(enc as *mut normal_encoding)).type_0
                                [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                                as libc::c_int
                        } else {
                            unicode_byte_type(
                                *ptr.offset(0 as libc::c_int as isize),
                                *ptr.offset(1 as libc::c_int as isize),
                            )
                        }) == crate::xmltok_impl_h::BT_LF as libc::c_int
                        {
                            ptr = ptr.offset(2 as libc::c_int as isize)
                        }
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_DATA_NEWLINE;
                    }
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_DATA_CHARS;
                }
                _ => ptr = ptr.offset(2 as libc::c_int as isize),
            }
        }
        *nextTokPtr = ptr;
        return crate::xmltok_h::XML_TOK_DATA_CHARS;
    }

    pub unsafe extern "C" fn little2_entityValueTok(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        let mut start: *const libc::c_char = 0 as *const libc::c_char;
        if ptr >= end {
            return crate::xmltok_h::XML_TOK_NONE;
        } else {
            if !(end.wrapping_offset_from(ptr) as libc::c_long
                >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
            {
                return crate::xmltok_h::XML_TOK_PARTIAL;
            }
        }
        start = ptr;
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(1 as libc::c_int as isize),
                    *ptr.offset(0 as libc::c_int as isize),
                )
            } {
                5 => ptr = ptr.offset(2 as libc::c_int as isize),
                6 => ptr = ptr.offset(3 as libc::c_int as isize),
                7 => ptr = ptr.offset(4 as libc::c_int as isize),
                3 => {
                    if ptr == start {
                        return little2_scanRef(
                            enc,
                            ptr.offset(2 as libc::c_int as isize),
                            end,
                            nextTokPtr,
                        );
                    }
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_DATA_CHARS;
                }
                30 => {
                    if ptr == start {
                        let mut tok: libc::c_int = little2_scanPercent(
                            enc,
                            ptr.offset(2 as libc::c_int as isize),
                            end,
                            nextTokPtr,
                        );
                        return if tok == crate::xmltok_h::XML_TOK_PERCENT {
                            crate::xmltok_h::XML_TOK_INVALID
                        } else {
                            tok
                        };
                    }
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_DATA_CHARS;
                }
                10 => {
                    if ptr == start {
                        *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                        return crate::xmltok_h::XML_TOK_DATA_NEWLINE;
                    }
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_DATA_CHARS;
                }
                9 => {
                    if ptr == start {
                        ptr = ptr.offset(2 as libc::c_int as isize);
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                        {
                            return crate::xmltok_h::XML_TOK_TRAILING_CR;
                        }
                        if (if *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                            == 0 as libc::c_int
                        {
                            (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                                as libc::c_int
                        } else {
                            unicode_byte_type(
                                *ptr.offset(1 as libc::c_int as isize),
                                *ptr.offset(0 as libc::c_int as isize),
                            )
                        }) == crate::xmltok_impl_h::BT_LF as libc::c_int
                        {
                            ptr = ptr.offset(2 as libc::c_int as isize)
                        }
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_DATA_NEWLINE;
                    }
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_DATA_CHARS;
                }
                _ => ptr = ptr.offset(2 as libc::c_int as isize),
            }
        }
        *nextTokPtr = ptr;
        return crate::xmltok_h::XML_TOK_DATA_CHARS;
    }

    pub unsafe extern "C" fn normal_entityValueTok(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        let mut start: *const libc::c_char = 0 as *const libc::c_char;
        if ptr >= end {
            return crate::xmltok_h::XML_TOK_NONE;
        } else {
            if !(end.wrapping_offset_from(ptr) as libc::c_long
                >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
            {
                return crate::xmltok_h::XML_TOK_PARTIAL;
            }
        }
        start = ptr;
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long
        {
            match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                as libc::c_int
            {
                5 => ptr = ptr.offset(2 as libc::c_int as isize),
                6 => ptr = ptr.offset(3 as libc::c_int as isize),
                7 => ptr = ptr.offset(4 as libc::c_int as isize),
                3 => {
                    if ptr == start {
                        return normal_scanRef(
                            enc,
                            ptr.offset(1 as libc::c_int as isize),
                            end,
                            nextTokPtr,
                        );
                    }
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_DATA_CHARS;
                }
                30 => {
                    if ptr == start {
                        let mut tok: libc::c_int = normal_scanPercent(
                            enc,
                            ptr.offset(1 as libc::c_int as isize),
                            end,
                            nextTokPtr,
                        );
                        return if tok == crate::xmltok_h::XML_TOK_PERCENT {
                            crate::xmltok_h::XML_TOK_INVALID
                        } else {
                            tok
                        };
                    }
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_DATA_CHARS;
                }
                10 => {
                    if ptr == start {
                        *nextTokPtr = ptr.offset(1 as libc::c_int as isize);
                        return crate::xmltok_h::XML_TOK_DATA_NEWLINE;
                    }
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_DATA_CHARS;
                }
                9 => {
                    if ptr == start {
                        ptr = ptr.offset(1 as libc::c_int as isize);
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                        {
                            return crate::xmltok_h::XML_TOK_TRAILING_CR;
                        }
                        if (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                            as libc::c_int
                            == crate::xmltok_impl_h::BT_LF as libc::c_int
                        {
                            ptr = ptr.offset(1 as libc::c_int as isize)
                        }
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_DATA_NEWLINE;
                    }
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_DATA_CHARS;
                }
                _ => ptr = ptr.offset(1 as libc::c_int as isize),
            }
        }
        *nextTokPtr = ptr;
        return crate::xmltok_h::XML_TOK_DATA_CHARS;
    }

    pub unsafe extern "C" fn big2_ignoreSectionTok(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        let mut level: libc::c_int = 0 as libc::c_int;
        if 2 as libc::c_int > 1 as libc::c_int {
            let mut n: crate::stddef_h::size_t =
                end.wrapping_offset_from(ptr) as libc::c_long as crate::stddef_h::size_t;
            if n & (2 as libc::c_int - 1 as libc::c_int) as libc::c_ulong != 0 {
                n &= !(2 as libc::c_int - 1 as libc::c_int) as libc::c_ulong;
                end = ptr.offset(n as isize)
            }
        }
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0
                    [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(0 as libc::c_int as isize),
                    *ptr.offset(1 as libc::c_int as isize),
                )
            } {
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize)
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize)
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize)
                }
                0 | 1 | 8 => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                2 => {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL;
                    }
                    if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                        && *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                            == 0x21 as libc::c_int
                    {
                        ptr = ptr.offset(2 as libc::c_int as isize);
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                        {
                            return crate::xmltok_h::XML_TOK_PARTIAL;
                        }
                        if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                            && *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                                == 0x5b as libc::c_int
                        {
                            level += 1;
                            ptr = ptr.offset(2 as libc::c_int as isize)
                        }
                    }
                }
                4 => {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL;
                    }
                    if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                        && *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                            == 0x5d as libc::c_int
                    {
                        ptr = ptr.offset(2 as libc::c_int as isize);
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                        {
                            return crate::xmltok_h::XML_TOK_PARTIAL;
                        }
                        if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                            && *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                                == 0x3e as libc::c_int
                        {
                            ptr = ptr.offset(2 as libc::c_int as isize);
                            if level == 0 as libc::c_int {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_IGNORE_SECT;
                            }
                            level -= 1
                        }
                    }
                }
                _ => ptr = ptr.offset(2 as libc::c_int as isize),
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }

    pub unsafe extern "C" fn little2_ignoreSectionTok(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        let mut level: libc::c_int = 0 as libc::c_int;
        if 2 as libc::c_int > 1 as libc::c_int {
            let mut n: crate::stddef_h::size_t =
                end.wrapping_offset_from(ptr) as libc::c_long as crate::stddef_h::size_t;
            if n & (2 as libc::c_int - 1 as libc::c_int) as libc::c_ulong != 0 {
                n &= !(2 as libc::c_int - 1 as libc::c_int) as libc::c_ulong;
                end = ptr.offset(n as isize)
            }
        }
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(1 as libc::c_int as isize),
                    *ptr.offset(0 as libc::c_int as isize),
                )
            } {
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize)
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize)
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize)
                }
                0 | 1 | 8 => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                2 => {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL;
                    }
                    if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                        && *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                            == 0x21 as libc::c_int
                    {
                        ptr = ptr.offset(2 as libc::c_int as isize);
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                        {
                            return crate::xmltok_h::XML_TOK_PARTIAL;
                        }
                        if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                            && *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                                == 0x5b as libc::c_int
                        {
                            level += 1;
                            ptr = ptr.offset(2 as libc::c_int as isize)
                        }
                    }
                }
                4 => {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL;
                    }
                    if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                        && *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                            == 0x5d as libc::c_int
                    {
                        ptr = ptr.offset(2 as libc::c_int as isize);
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long)
                        {
                            return crate::xmltok_h::XML_TOK_PARTIAL;
                        }
                        if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                            && *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                                == 0x3e as libc::c_int
                        {
                            ptr = ptr.offset(2 as libc::c_int as isize);
                            if level == 0 as libc::c_int {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_IGNORE_SECT;
                            }
                            level -= 1
                        }
                    }
                }
                _ => ptr = ptr.offset(2 as libc::c_int as isize),
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }

    pub unsafe extern "C" fn normal_ignoreSectionTok(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        let mut level: libc::c_int = 0 as libc::c_int;
        if 1 as libc::c_int > 1 as libc::c_int {
            let mut n: crate::stddef_h::size_t =
                end.wrapping_offset_from(ptr) as libc::c_long as crate::stddef_h::size_t;
            if n & (1 as libc::c_int - 1 as libc::c_int) as libc::c_ulong != 0 {
                n &= !(1 as libc::c_int - 1 as libc::c_int) as libc::c_ulong;
                end = ptr.offset(n as isize)
            }
        }
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long
        {
            match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                as libc::c_int
            {
                5 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 2 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if (*(enc as *const normal_encoding))
                        .isInvalid2
                        .expect("non-null function pointer")(enc, ptr)
                        != 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize)
                }
                6 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 3 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if (*(enc as *const normal_encoding))
                        .isInvalid3
                        .expect("non-null function pointer")(enc, ptr)
                        != 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(3 as libc::c_int as isize)
                }
                7 => {
                    if (end.wrapping_offset_from(ptr) as libc::c_long)
                        < 4 as libc::c_int as libc::c_long
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL_CHAR;
                    }
                    if (*(enc as *const normal_encoding))
                        .isInvalid4
                        .expect("non-null function pointer")(enc, ptr)
                        != 0
                    {
                        *nextTokPtr = ptr;
                        return crate::xmltok_h::XML_TOK_INVALID;
                    }
                    ptr = ptr.offset(4 as libc::c_int as isize)
                }
                0 | 1 | 8 => {
                    *nextTokPtr = ptr;
                    return crate::xmltok_h::XML_TOK_INVALID;
                }
                2 => {
                    ptr = ptr.offset(1 as libc::c_int as isize);
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL;
                    }
                    if *ptr as libc::c_int == 0x21 as libc::c_int {
                        ptr = ptr.offset(1 as libc::c_int as isize);
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                        {
                            return crate::xmltok_h::XML_TOK_PARTIAL;
                        }
                        if *ptr as libc::c_int == 0x5b as libc::c_int {
                            level += 1;
                            ptr = ptr.offset(1 as libc::c_int as isize)
                        }
                    }
                }
                4 => {
                    ptr = ptr.offset(1 as libc::c_int as isize);
                    if !(end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                    {
                        return crate::xmltok_h::XML_TOK_PARTIAL;
                    }
                    if *ptr as libc::c_int == 0x5d as libc::c_int {
                        ptr = ptr.offset(1 as libc::c_int as isize);
                        if !(end.wrapping_offset_from(ptr) as libc::c_long
                            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long)
                        {
                            return crate::xmltok_h::XML_TOK_PARTIAL;
                        }
                        if *ptr as libc::c_int == 0x3e as libc::c_int {
                            ptr = ptr.offset(1 as libc::c_int as isize);
                            if level == 0 as libc::c_int {
                                *nextTokPtr = ptr;
                                return crate::xmltok_h::XML_TOK_IGNORE_SECT;
                            }
                            level -= 1
                        }
                    }
                }
                _ => ptr = ptr.offset(1 as libc::c_int as isize),
            }
        }
        return crate::xmltok_h::XML_TOK_PARTIAL;
    }
    /* XML_DTD */
    /* XML_DTD */
    /* XML_DTD */

    pub unsafe extern "C" fn big2_isPublicId(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut badPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        ptr = ptr.offset(2 as libc::c_int as isize);
        end = end.offset(-(2 as libc::c_int as isize));
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            let mut current_block_8: u64;
            match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0
                    [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(0 as libc::c_int as isize),
                    *ptr.offset(1 as libc::c_int as isize),
                )
            } {
                25 | 24 | 27 | 13 | 31 | 32 | 34 | 35 | 17 | 14 | 15 | 9 | 10 | 18 | 16 | 33
                | 30 | 19 | 23 => {
                    current_block_8 = 13242334135786603907;
                }
                21 => {
                    if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                        && *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                            == 0x9 as libc::c_int
                    {
                        *badPtr = ptr;
                        return 0 as libc::c_int;
                    }
                    current_block_8 = 13242334135786603907;
                }
                26 | 22 => {
                    if (if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                    {
                        *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                    } else {
                        -(1 as libc::c_int)
                    }) & !(0x7f as libc::c_int)
                        == 0
                    {
                        current_block_8 = 13242334135786603907;
                    } else {
                        current_block_8 = 1012613755837077285;
                    }
                }
                _ => {
                    current_block_8 = 1012613755837077285;
                }
            }
            match current_block_8 {
                1012613755837077285 =>
                /* fall through */
                /* fall through */
                /* fall through */
                {
                    match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                        == 0 as libc::c_int
                    {
                        *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                    } else {
                        -(1 as libc::c_int)
                    } {
                        36 => {}
                        64 => {}
                        _ => {
                            *badPtr = ptr;
                            return 0 as libc::c_int;
                        }
                    }
                }
                _ => {}
            }
            ptr = ptr.offset(2 as libc::c_int as isize)
        }
        return 1 as libc::c_int;
    }

    pub unsafe extern "C" fn little2_isPublicId(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut badPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        ptr = ptr.offset(2 as libc::c_int as isize);
        end = end.offset(-(2 as libc::c_int as isize));
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            let mut current_block_8: u64;
            match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(1 as libc::c_int as isize),
                    *ptr.offset(0 as libc::c_int as isize),
                )
            } {
                25 | 24 | 27 | 13 | 31 | 32 | 34 | 35 | 17 | 14 | 15 | 9 | 10 | 18 | 16 | 33
                | 30 | 19 | 23 => {
                    current_block_8 = 13242334135786603907;
                }
                21 => {
                    if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                        && *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                            == 0x9 as libc::c_int
                    {
                        *badPtr = ptr;
                        return 0 as libc::c_int;
                    }
                    current_block_8 = 13242334135786603907;
                }
                26 | 22 => {
                    if (if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                    {
                        *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                    } else {
                        -(1 as libc::c_int)
                    }) & !(0x7f as libc::c_int)
                        == 0
                    {
                        current_block_8 = 13242334135786603907;
                    } else {
                        current_block_8 = 8842977063429728986;
                    }
                }
                _ => {
                    current_block_8 = 8842977063429728986;
                }
            }
            match current_block_8 {
                8842977063429728986 => {
                    match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                        == 0 as libc::c_int
                    {
                        *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                    } else {
                        -(1 as libc::c_int)
                    } {
                        36 | 64 => {}
                        _ => {
                            *badPtr = ptr;
                            return 0 as libc::c_int;
                        }
                    }
                }
                _ => {}
            }
            ptr = ptr.offset(2 as libc::c_int as isize)
        }
        return 1 as libc::c_int;
    }

    pub unsafe extern "C" fn normal_isPublicId(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut badPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        ptr = ptr.offset(1 as libc::c_int as isize);
        end = end.offset(-(1 as libc::c_int as isize));
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long
        {
            let mut current_block_8: u64;
            match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                as libc::c_int
            {
                25 | 24 | 27 | 13 | 31 | 32 | 34 | 35 | 17 | 14 | 15 | 9 | 10 | 18 | 16 | 33
                | 30 | 19 | 23 => {
                    current_block_8 = 13242334135786603907;
                }
                21 => {
                    if *ptr as libc::c_int == 0x9 as libc::c_int {
                        *badPtr = ptr;
                        return 0 as libc::c_int;
                    }
                    current_block_8 = 13242334135786603907;
                }
                26 | 22 => {
                    if *ptr as libc::c_int & !(0x7f as libc::c_int) == 0 {
                        current_block_8 = 13242334135786603907;
                    } else {
                        current_block_8 = 4503056668119438195;
                    }
                }
                _ => {
                    current_block_8 = 4503056668119438195;
                }
            }
            match current_block_8 {
                4503056668119438195 => match *ptr as libc::c_int {
                    36 | 64 => {}
                    _ => {
                        *badPtr = ptr;
                        return 0 as libc::c_int;
                    }
                },
                _ => {}
            }
            ptr = ptr.offset(1 as libc::c_int as isize)
        }
        return 1 as libc::c_int;
    }
    /* This must only be called for a well-formed start-tag or empty
       element tag.  Returns the number of attributes.  Pointers to the
       first attsMax attributes are stored in atts.
    */
    /* This must only be called for a well-formed start-tag or empty
       element tag.  Returns the number of attributes.  Pointers to the
       first attsMax attributes are stored in atts.
    */
    /* This must only be called for a well-formed start-tag or empty
       element tag.  Returns the number of attributes.  Pointers to the
       first attsMax attributes are stored in atts.
    */

    pub unsafe extern "C" fn normal_getAtts(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut attsMax: libc::c_int,
        mut atts: *mut crate::src::lib::xmltok::ATTRIBUTE,
    ) -> libc::c_int {
        let mut state: crate::xmltok_impl_h::C2RustUnnamed_2 = crate::xmltok_impl_c::inName;
        let mut nAtts: libc::c_int = 0 as libc::c_int;
        let mut open: libc::c_int = 0 as libc::c_int;
        /* defined when state == inValue;
        initialization just to shut up compilers */
        /* defined when state == inValue;
        initialization just to shut up compilers */
        /* defined when state == inValue;
        initialization just to shut up compilers */
        ptr = ptr.offset(1 as libc::c_int as isize);
        loop {
            match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                as libc::c_int
            {
                5 => {
                    if state as libc::c_uint
                        == crate::xmltok_impl_c::other as libc::c_int as libc::c_uint
                    {
                        if nAtts < attsMax {
                            let ref mut fresh0 = (*atts.offset(nAtts as isize)).name;
                            *fresh0 = ptr;
                            (*atts.offset(nAtts as isize)).normalized =
                                1 as libc::c_int as libc::c_char
                        }
                        state = crate::xmltok_impl_c::inName
                    }
                    ptr = ptr.offset((2 as libc::c_int - 1 as libc::c_int) as isize)
                }
                6 => {
                    if state as libc::c_uint
                        == crate::xmltok_impl_c::other as libc::c_int as libc::c_uint
                    {
                        if nAtts < attsMax {
                            let ref mut fresh1 = (*atts.offset(nAtts as isize)).name;
                            *fresh1 = ptr;
                            (*atts.offset(nAtts as isize)).normalized =
                                1 as libc::c_int as libc::c_char
                        }
                        state = crate::xmltok_impl_c::inName
                    }
                    ptr = ptr.offset((3 as libc::c_int - 1 as libc::c_int) as isize)
                }
                7 => {
                    if state as libc::c_uint
                        == crate::xmltok_impl_c::other as libc::c_int as libc::c_uint
                    {
                        if nAtts < attsMax {
                            let ref mut fresh2 = (*atts.offset(nAtts as isize)).name;
                            *fresh2 = ptr;
                            (*atts.offset(nAtts as isize)).normalized =
                                1 as libc::c_int as libc::c_char
                        }
                        state = crate::xmltok_impl_c::inName
                    }
                    ptr = ptr.offset((4 as libc::c_int - 1 as libc::c_int) as isize)
                }
                29 | 22 | 24 => {
                    if state as libc::c_uint
                        == crate::xmltok_impl_c::other as libc::c_int as libc::c_uint
                    {
                        if nAtts < attsMax {
                            let ref mut fresh3 = (*atts.offset(nAtts as isize)).name;
                            *fresh3 = ptr;
                            (*atts.offset(nAtts as isize)).normalized =
                                1 as libc::c_int as libc::c_char
                        }
                        state = crate::xmltok_impl_c::inName
                    }
                }
                12 => {
                    if state as libc::c_uint
                        != crate::xmltok_impl_c::inValue as libc::c_int as libc::c_uint
                    {
                        if nAtts < attsMax {
                            let ref mut fresh4 = (*atts.offset(nAtts as isize)).valuePtr;
                            *fresh4 = ptr.offset(1 as libc::c_int as isize)
                        }
                        state = crate::xmltok_impl_c::inValue;
                        open = crate::xmltok_impl_h::BT_QUOT as libc::c_int
                    } else if open == crate::xmltok_impl_h::BT_QUOT as libc::c_int {
                        state = crate::xmltok_impl_c::other;
                        if nAtts < attsMax {
                            let ref mut fresh5 = (*atts.offset(nAtts as isize)).valueEnd;
                            *fresh5 = ptr
                        }
                        nAtts += 1
                    }
                }
                13 => {
                    if state as libc::c_uint
                        != crate::xmltok_impl_c::inValue as libc::c_int as libc::c_uint
                    {
                        if nAtts < attsMax {
                            let ref mut fresh6 = (*atts.offset(nAtts as isize)).valuePtr;
                            *fresh6 = ptr.offset(1 as libc::c_int as isize)
                        }
                        state = crate::xmltok_impl_c::inValue;
                        open = crate::xmltok_impl_h::BT_APOS as libc::c_int
                    } else if open == crate::xmltok_impl_h::BT_APOS as libc::c_int {
                        state = crate::xmltok_impl_c::other;
                        if nAtts < attsMax {
                            let ref mut fresh7 = (*atts.offset(nAtts as isize)).valueEnd;
                            *fresh7 = ptr
                        }
                        nAtts += 1
                    }
                }
                3 => {
                    if nAtts < attsMax {
                        (*atts.offset(nAtts as isize)).normalized = 0 as libc::c_int as libc::c_char
                    }
                }
                21 => {
                    if state as libc::c_uint
                        == crate::xmltok_impl_c::inName as libc::c_int as libc::c_uint
                    {
                        state = crate::xmltok_impl_c::other
                    } else if state as libc::c_uint
                        == crate::xmltok_impl_c::inValue as libc::c_int as libc::c_uint
                        && nAtts < attsMax
                        && (*atts.offset(nAtts as isize)).normalized as libc::c_int != 0
                        && (ptr == (*atts.offset(nAtts as isize)).valuePtr
                            || *ptr as libc::c_int != crate::ascii_h::ASCII_SPACE
                            || *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                                == crate::ascii_h::ASCII_SPACE
                            || (*(enc as *mut normal_encoding)).type_0
                                [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                                as libc::c_int
                                == open)
                    {
                        (*atts.offset(nAtts as isize)).normalized = 0 as libc::c_int as libc::c_char
                    }
                }
                9 | 10 => {
                    /* This case ensures that the first attribute name is counted
                    Apart from that we could just change state on the quote. */
                    /* This case ensures that the first attribute name is counted
                    Apart from that we could just change state on the quote. */
                    /* This case ensures that the first attribute name is counted
                    Apart from that we could just change state on the quote. */
                    if state as libc::c_uint
                        == crate::xmltok_impl_c::inName as libc::c_int as libc::c_uint
                    {
                        state = crate::xmltok_impl_c::other
                    } else if state as libc::c_uint
                        == crate::xmltok_impl_c::inValue as libc::c_int as libc::c_uint
                        && nAtts < attsMax
                    {
                        (*atts.offset(nAtts as isize)).normalized = 0 as libc::c_int as libc::c_char
                    }
                }
                11 | 17 => {
                    if state as libc::c_uint
                        != crate::xmltok_impl_c::inValue as libc::c_int as libc::c_uint
                    {
                        return nAtts;
                    }
                }
                _ => {}
            }
            ptr = ptr.offset(1 as libc::c_int as isize)
        }
        /* not reached */
        /* not reached */
        /* not reached */
    }

    pub unsafe extern "C" fn little2_getAtts(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut attsMax: libc::c_int,
        mut atts: *mut crate::src::lib::xmltok::ATTRIBUTE,
    ) -> libc::c_int {
        let mut state: crate::xmltok_impl_h::C2RustUnnamed_2 = crate::xmltok_impl_c::inName_0;
        let mut nAtts: libc::c_int = 0 as libc::c_int;
        let mut open: libc::c_int = 0 as libc::c_int;
        ptr = ptr.offset(2 as libc::c_int as isize);
        loop {
            match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(1 as libc::c_int as isize),
                    *ptr.offset(0 as libc::c_int as isize),
                )
            } {
                5 => {
                    if state as libc::c_uint
                        == crate::xmltok_impl_c::other_0 as libc::c_int as libc::c_uint
                    {
                        if nAtts < attsMax {
                            let ref mut fresh8 = (*atts.offset(nAtts as isize)).name;
                            *fresh8 = ptr;
                            (*atts.offset(nAtts as isize)).normalized =
                                1 as libc::c_int as libc::c_char
                        }
                        state = crate::xmltok_impl_c::inName_0
                    }
                    ptr = ptr.offset((2 as libc::c_int - 2 as libc::c_int) as isize)
                }
                6 => {
                    if state as libc::c_uint
                        == crate::xmltok_impl_c::other_0 as libc::c_int as libc::c_uint
                    {
                        if nAtts < attsMax {
                            let ref mut fresh9 = (*atts.offset(nAtts as isize)).name;
                            *fresh9 = ptr;
                            (*atts.offset(nAtts as isize)).normalized =
                                1 as libc::c_int as libc::c_char
                        }
                        state = crate::xmltok_impl_c::inName_0
                    }
                    ptr = ptr.offset((3 as libc::c_int - 2 as libc::c_int) as isize)
                }
                7 => {
                    if state as libc::c_uint
                        == crate::xmltok_impl_c::other_0 as libc::c_int as libc::c_uint
                    {
                        if nAtts < attsMax {
                            let ref mut fresh10 = (*atts.offset(nAtts as isize)).name;
                            *fresh10 = ptr;
                            (*atts.offset(nAtts as isize)).normalized =
                                1 as libc::c_int as libc::c_char
                        }
                        state = crate::xmltok_impl_c::inName_0
                    }
                    ptr = ptr.offset((4 as libc::c_int - 2 as libc::c_int) as isize)
                }
                29 | 22 | 24 => {
                    if state as libc::c_uint
                        == crate::xmltok_impl_c::other_0 as libc::c_int as libc::c_uint
                    {
                        if nAtts < attsMax {
                            let ref mut fresh11 = (*atts.offset(nAtts as isize)).name;
                            *fresh11 = ptr;
                            (*atts.offset(nAtts as isize)).normalized =
                                1 as libc::c_int as libc::c_char
                        }
                        state = crate::xmltok_impl_c::inName_0
                    }
                }
                12 => {
                    if state as libc::c_uint
                        != crate::xmltok_impl_c::inValue_0 as libc::c_int as libc::c_uint
                    {
                        if nAtts < attsMax {
                            let ref mut fresh12 = (*atts.offset(nAtts as isize)).valuePtr;
                            *fresh12 = ptr.offset(2 as libc::c_int as isize)
                        }
                        state = crate::xmltok_impl_c::inValue_0;
                        open = crate::xmltok_impl_h::BT_QUOT as libc::c_int
                    } else if open == crate::xmltok_impl_h::BT_QUOT as libc::c_int {
                        state = crate::xmltok_impl_c::other_0;
                        if nAtts < attsMax {
                            let ref mut fresh13 = (*atts.offset(nAtts as isize)).valueEnd;
                            *fresh13 = ptr
                        }
                        nAtts += 1
                    }
                }
                13 => {
                    if state as libc::c_uint
                        != crate::xmltok_impl_c::inValue_0 as libc::c_int as libc::c_uint
                    {
                        if nAtts < attsMax {
                            let ref mut fresh14 = (*atts.offset(nAtts as isize)).valuePtr;
                            *fresh14 = ptr.offset(2 as libc::c_int as isize)
                        }
                        state = crate::xmltok_impl_c::inValue_0;
                        open = crate::xmltok_impl_h::BT_APOS as libc::c_int
                    } else if open == crate::xmltok_impl_h::BT_APOS as libc::c_int {
                        state = crate::xmltok_impl_c::other_0;
                        if nAtts < attsMax {
                            let ref mut fresh15 = (*atts.offset(nAtts as isize)).valueEnd;
                            *fresh15 = ptr
                        }
                        nAtts += 1
                    }
                }
                3 => {
                    if nAtts < attsMax {
                        (*atts.offset(nAtts as isize)).normalized = 0 as libc::c_int as libc::c_char
                    }
                }
                21 => {
                    if state as libc::c_uint
                        == crate::xmltok_impl_c::inName_0 as libc::c_int as libc::c_uint
                    {
                        state = crate::xmltok_impl_c::other_0
                    } else if state as libc::c_uint
                        == crate::xmltok_impl_c::inValue_0 as libc::c_int as libc::c_uint
                        && nAtts < attsMax
                        && (*atts.offset(nAtts as isize)).normalized as libc::c_int != 0
                        && (ptr == (*atts.offset(nAtts as isize)).valuePtr
                            || (if *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                                == 0 as libc::c_int
                            {
                                *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                            } else {
                                -(1 as libc::c_int)
                            }) != crate::ascii_h::ASCII_SPACE
                            || (if *ptr
                                .offset(2 as libc::c_int as isize)
                                .offset(1 as libc::c_int as isize)
                                as libc::c_int
                                == 0 as libc::c_int
                            {
                                *ptr.offset(2 as libc::c_int as isize)
                                    .offset(0 as libc::c_int as isize)
                                    as libc::c_int
                            } else {
                                -(1 as libc::c_int)
                            }) == crate::ascii_h::ASCII_SPACE
                            || (if *ptr
                                .offset(2 as libc::c_int as isize)
                                .offset(1 as libc::c_int as isize)
                                as libc::c_int
                                == 0 as libc::c_int
                            {
                                (*(enc as *mut normal_encoding)).type_0[*ptr
                                    .offset(2 as libc::c_int as isize)
                                    as libc::c_uchar
                                    as usize] as libc::c_int
                            } else {
                                unicode_byte_type(
                                    *ptr.offset(2 as libc::c_int as isize)
                                        .offset(1 as libc::c_int as isize),
                                    *ptr.offset(2 as libc::c_int as isize)
                                        .offset(0 as libc::c_int as isize),
                                )
                            }) == open)
                    {
                        (*atts.offset(nAtts as isize)).normalized = 0 as libc::c_int as libc::c_char
                    }
                }
                9 | 10 => {
                    if state as libc::c_uint
                        == crate::xmltok_impl_c::inName_0 as libc::c_int as libc::c_uint
                    {
                        state = crate::xmltok_impl_c::other_0
                    } else if state as libc::c_uint
                        == crate::xmltok_impl_c::inValue_0 as libc::c_int as libc::c_uint
                        && nAtts < attsMax
                    {
                        (*atts.offset(nAtts as isize)).normalized = 0 as libc::c_int as libc::c_char
                    }
                }
                11 | 17 => {
                    if state as libc::c_uint
                        != crate::xmltok_impl_c::inValue_0 as libc::c_int as libc::c_uint
                    {
                        return nAtts;
                    }
                }
                _ => {}
            }
            ptr = ptr.offset(2 as libc::c_int as isize)
        }
    }

    pub unsafe extern "C" fn big2_getAtts(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut attsMax: libc::c_int,
        mut atts: *mut crate::src::lib::xmltok::ATTRIBUTE,
    ) -> libc::c_int {
        let mut state: crate::xmltok_impl_h::C2RustUnnamed_2 = crate::xmltok_impl_c::inName_1;
        let mut nAtts: libc::c_int = 0 as libc::c_int;
        let mut open: libc::c_int = 0 as libc::c_int;
        ptr = ptr.offset(2 as libc::c_int as isize);
        loop {
            match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0
                    [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(0 as libc::c_int as isize),
                    *ptr.offset(1 as libc::c_int as isize),
                )
            } {
                5 => {
                    if state as libc::c_uint
                        == crate::xmltok_impl_c::other_1 as libc::c_int as libc::c_uint
                    {
                        if nAtts < attsMax {
                            let ref mut fresh16 = (*atts.offset(nAtts as isize)).name;
                            *fresh16 = ptr;
                            (*atts.offset(nAtts as isize)).normalized =
                                1 as libc::c_int as libc::c_char
                        }
                        state = crate::xmltok_impl_c::inName_1
                    }
                    ptr = ptr.offset((2 as libc::c_int - 2 as libc::c_int) as isize)
                }
                6 => {
                    if state as libc::c_uint
                        == crate::xmltok_impl_c::other_1 as libc::c_int as libc::c_uint
                    {
                        if nAtts < attsMax {
                            let ref mut fresh17 = (*atts.offset(nAtts as isize)).name;
                            *fresh17 = ptr;
                            (*atts.offset(nAtts as isize)).normalized =
                                1 as libc::c_int as libc::c_char
                        }
                        state = crate::xmltok_impl_c::inName_1
                    }
                    ptr = ptr.offset((3 as libc::c_int - 2 as libc::c_int) as isize)
                }
                7 => {
                    if state as libc::c_uint
                        == crate::xmltok_impl_c::other_1 as libc::c_int as libc::c_uint
                    {
                        if nAtts < attsMax {
                            let ref mut fresh18 = (*atts.offset(nAtts as isize)).name;
                            *fresh18 = ptr;
                            (*atts.offset(nAtts as isize)).normalized =
                                1 as libc::c_int as libc::c_char
                        }
                        state = crate::xmltok_impl_c::inName_1
                    }
                    ptr = ptr.offset((4 as libc::c_int - 2 as libc::c_int) as isize)
                }
                29 | 22 | 24 => {
                    if state as libc::c_uint
                        == crate::xmltok_impl_c::other_1 as libc::c_int as libc::c_uint
                    {
                        if nAtts < attsMax {
                            let ref mut fresh19 = (*atts.offset(nAtts as isize)).name;
                            *fresh19 = ptr;
                            (*atts.offset(nAtts as isize)).normalized =
                                1 as libc::c_int as libc::c_char
                        }
                        state = crate::xmltok_impl_c::inName_1
                    }
                }
                12 => {
                    if state as libc::c_uint
                        != crate::xmltok_impl_c::inValue_1 as libc::c_int as libc::c_uint
                    {
                        if nAtts < attsMax {
                            let ref mut fresh20 = (*atts.offset(nAtts as isize)).valuePtr;
                            *fresh20 = ptr.offset(2 as libc::c_int as isize)
                        }
                        state = crate::xmltok_impl_c::inValue_1;
                        open = crate::xmltok_impl_h::BT_QUOT as libc::c_int
                    } else if open == crate::xmltok_impl_h::BT_QUOT as libc::c_int {
                        state = crate::xmltok_impl_c::other_1;
                        if nAtts < attsMax {
                            let ref mut fresh21 = (*atts.offset(nAtts as isize)).valueEnd;
                            *fresh21 = ptr
                        }
                        nAtts += 1
                    }
                }
                13 => {
                    if state as libc::c_uint
                        != crate::xmltok_impl_c::inValue_1 as libc::c_int as libc::c_uint
                    {
                        if nAtts < attsMax {
                            let ref mut fresh22 = (*atts.offset(nAtts as isize)).valuePtr;
                            *fresh22 = ptr.offset(2 as libc::c_int as isize)
                        }
                        state = crate::xmltok_impl_c::inValue_1;
                        open = crate::xmltok_impl_h::BT_APOS as libc::c_int
                    } else if open == crate::xmltok_impl_h::BT_APOS as libc::c_int {
                        state = crate::xmltok_impl_c::other_1;
                        if nAtts < attsMax {
                            let ref mut fresh23 = (*atts.offset(nAtts as isize)).valueEnd;
                            *fresh23 = ptr
                        }
                        nAtts += 1
                    }
                }
                3 => {
                    if nAtts < attsMax {
                        (*atts.offset(nAtts as isize)).normalized = 0 as libc::c_int as libc::c_char
                    }
                }
                21 => {
                    if state as libc::c_uint
                        == crate::xmltok_impl_c::inName_1 as libc::c_int as libc::c_uint
                    {
                        state = crate::xmltok_impl_c::other_1
                    } else if state as libc::c_uint
                        == crate::xmltok_impl_c::inValue_1 as libc::c_int as libc::c_uint
                        && nAtts < attsMax
                        && (*atts.offset(nAtts as isize)).normalized as libc::c_int != 0
                        && (ptr == (*atts.offset(nAtts as isize)).valuePtr
                            || (if *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                                == 0 as libc::c_int
                            {
                                *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                            } else {
                                -(1 as libc::c_int)
                            }) != crate::ascii_h::ASCII_SPACE
                            || (if *ptr
                                .offset(2 as libc::c_int as isize)
                                .offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == 0 as libc::c_int
                            {
                                *ptr.offset(2 as libc::c_int as isize)
                                    .offset(1 as libc::c_int as isize)
                                    as libc::c_int
                            } else {
                                -(1 as libc::c_int)
                            }) == crate::ascii_h::ASCII_SPACE
                            || (if *ptr
                                .offset(2 as libc::c_int as isize)
                                .offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == 0 as libc::c_int
                            {
                                (*(enc as *mut normal_encoding)).type_0[*ptr
                                    .offset(2 as libc::c_int as isize)
                                    .offset(1 as libc::c_int as isize)
                                    as libc::c_uchar
                                    as usize] as libc::c_int
                            } else {
                                unicode_byte_type(
                                    *ptr.offset(2 as libc::c_int as isize)
                                        .offset(0 as libc::c_int as isize),
                                    *ptr.offset(2 as libc::c_int as isize)
                                        .offset(1 as libc::c_int as isize),
                                )
                            }) == open)
                    {
                        (*atts.offset(nAtts as isize)).normalized = 0 as libc::c_int as libc::c_char
                    }
                }
                9 | 10 => {
                    if state as libc::c_uint
                        == crate::xmltok_impl_c::inName_1 as libc::c_int as libc::c_uint
                    {
                        state = crate::xmltok_impl_c::other_1
                    } else if state as libc::c_uint
                        == crate::xmltok_impl_c::inValue_1 as libc::c_int as libc::c_uint
                        && nAtts < attsMax
                    {
                        (*atts.offset(nAtts as isize)).normalized = 0 as libc::c_int as libc::c_char
                    }
                }
                11 | 17 => {
                    if state as libc::c_uint
                        != crate::xmltok_impl_c::inValue_1 as libc::c_int as libc::c_uint
                    {
                        return nAtts;
                    }
                }
                _ => {}
            }
            ptr = ptr.offset(2 as libc::c_int as isize)
        }
    }

    pub unsafe extern "C" fn little2_charRefNumber(
        mut _enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
    ) -> libc::c_int {
        let mut result: libc::c_int = 0 as libc::c_int;
        /* skip &# */
        /* skip &# */
        /* skip &# */
        ptr = ptr.offset((2 as libc::c_int * 2 as libc::c_int) as isize);
        if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
            && *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0x78 as libc::c_int
        {
            ptr = ptr.offset(2 as libc::c_int as isize);
            while !(*ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                && *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0x3b as libc::c_int)
            {
                let mut c: libc::c_int =
                    if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                        *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                    } else {
                        -(1 as libc::c_int)
                    };
                match c {
                    crate::ascii_h_0::ASCII_0
                    | crate::ascii_h_0::ASCII_1
                    | crate::ascii_h_0::ASCII_2
                    | crate::ascii_h_0::ASCII_3
                    | crate::ascii_h::ASCII_4
                    | crate::ascii_h::ASCII_5
                    | crate::ascii_h::ASCII_6
                    | crate::ascii_h::ASCII_7
                    | crate::ascii_h_0::ASCII_8
                    | crate::ascii_h_0::ASCII_9 => {
                        result <<= 4 as libc::c_int;
                        result |= c - crate::ascii_h_0::ASCII_0
                    }
                    crate::ascii_h::ASCII_A
                    | crate::ascii_h_0::ASCII_B
                    | crate::ascii_h::ASCII_C
                    | crate::ascii_h::ASCII_D
                    | crate::ascii_h_0::ASCII_E
                    | crate::ascii_h_0::ASCII_F => {
                        result <<= 4 as libc::c_int;
                        result += 10 as libc::c_int + (c - crate::ascii_h::ASCII_A)
                    }
                    crate::ascii_h_0::ASCII_a
                    | crate::ascii_h::ASCII_b
                    | crate::ascii_h_0::ASCII_c
                    | crate::ascii_h::ASCII_d
                    | crate::ascii_h_0::ASCII_e
                    | crate::ascii_h::ASCII_f => {
                        result <<= 4 as libc::c_int;
                        result += 10 as libc::c_int + (c - crate::ascii_h_0::ASCII_a)
                    }
                    _ => {}
                }
                if result >= 0x110000 as libc::c_int {
                    return -(1 as libc::c_int);
                }
                ptr = ptr.offset(2 as libc::c_int as isize)
            }
        } else {
            while !(*ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                && *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0x3b as libc::c_int)
            {
                let mut c_0: libc::c_int =
                    if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                        *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                    } else {
                        -(1 as libc::c_int)
                    };
                result *= 10 as libc::c_int;
                result += c_0 - crate::ascii_h_0::ASCII_0;
                if result >= 0x110000 as libc::c_int {
                    return -(1 as libc::c_int);
                }
                ptr = ptr.offset(2 as libc::c_int as isize)
            }
        }
        return checkCharRefNumber(result);
    }

    pub unsafe extern "C" fn normal_charRefNumber(
        mut _enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
    ) -> libc::c_int {
        let mut result: libc::c_int = 0 as libc::c_int;
        ptr = ptr.offset((2 as libc::c_int * 1 as libc::c_int) as isize);
        if *ptr as libc::c_int == 0x78 as libc::c_int {
            ptr = ptr.offset(1 as libc::c_int as isize);
            while !(*ptr as libc::c_int == 0x3b as libc::c_int) {
                let mut c: libc::c_int = *ptr as libc::c_int;
                match c {
                    crate::ascii_h_0::ASCII_0
                    | crate::ascii_h_0::ASCII_1
                    | crate::ascii_h_0::ASCII_2
                    | crate::ascii_h_0::ASCII_3
                    | crate::ascii_h::ASCII_4
                    | crate::ascii_h::ASCII_5
                    | crate::ascii_h::ASCII_6
                    | crate::ascii_h::ASCII_7
                    | crate::ascii_h_0::ASCII_8
                    | crate::ascii_h_0::ASCII_9 => {
                        result <<= 4 as libc::c_int;
                        result |= c - crate::ascii_h_0::ASCII_0
                    }
                    crate::ascii_h::ASCII_A
                    | crate::ascii_h_0::ASCII_B
                    | crate::ascii_h::ASCII_C
                    | crate::ascii_h::ASCII_D
                    | crate::ascii_h_0::ASCII_E
                    | crate::ascii_h_0::ASCII_F => {
                        result <<= 4 as libc::c_int;
                        result += 10 as libc::c_int + (c - crate::ascii_h::ASCII_A)
                    }
                    crate::ascii_h_0::ASCII_a
                    | crate::ascii_h::ASCII_b
                    | crate::ascii_h_0::ASCII_c
                    | crate::ascii_h::ASCII_d
                    | crate::ascii_h_0::ASCII_e
                    | crate::ascii_h::ASCII_f => {
                        result <<= 4 as libc::c_int;
                        result += 10 as libc::c_int + (c - crate::ascii_h_0::ASCII_a)
                    }
                    _ => {}
                }
                if result >= 0x110000 as libc::c_int {
                    return -(1 as libc::c_int);
                }
                ptr = ptr.offset(1 as libc::c_int as isize)
            }
        } else {
            while !(*ptr as libc::c_int == 0x3b as libc::c_int) {
                let mut c_0: libc::c_int = *ptr as libc::c_int;
                result *= 10 as libc::c_int;
                result += c_0 - crate::ascii_h_0::ASCII_0;
                if result >= 0x110000 as libc::c_int {
                    return -(1 as libc::c_int);
                }
                ptr = ptr.offset(1 as libc::c_int as isize)
            }
        }
        return checkCharRefNumber(result);
    }

    pub unsafe extern "C" fn big2_charRefNumber(
        mut _enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
    ) -> libc::c_int {
        let mut result: libc::c_int = 0 as libc::c_int;
        ptr = ptr.offset((2 as libc::c_int * 2 as libc::c_int) as isize);
        if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
            && *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0x78 as libc::c_int
        {
            ptr = ptr.offset(2 as libc::c_int as isize);
            while !(*ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                && *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0x3b as libc::c_int)
            {
                let mut c: libc::c_int =
                    if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                        *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                    } else {
                        -(1 as libc::c_int)
                    };
                match c {
                    crate::ascii_h_0::ASCII_0
                    | crate::ascii_h_0::ASCII_1
                    | crate::ascii_h_0::ASCII_2
                    | crate::ascii_h_0::ASCII_3
                    | crate::ascii_h::ASCII_4
                    | crate::ascii_h::ASCII_5
                    | crate::ascii_h::ASCII_6
                    | crate::ascii_h::ASCII_7
                    | crate::ascii_h_0::ASCII_8
                    | crate::ascii_h_0::ASCII_9 => {
                        result <<= 4 as libc::c_int;
                        result |= c - crate::ascii_h_0::ASCII_0
                    }
                    crate::ascii_h::ASCII_A
                    | crate::ascii_h_0::ASCII_B
                    | crate::ascii_h::ASCII_C
                    | crate::ascii_h::ASCII_D
                    | crate::ascii_h_0::ASCII_E
                    | crate::ascii_h_0::ASCII_F => {
                        result <<= 4 as libc::c_int;
                        result += 10 as libc::c_int + (c - crate::ascii_h::ASCII_A)
                    }
                    crate::ascii_h_0::ASCII_a
                    | crate::ascii_h::ASCII_b
                    | crate::ascii_h_0::ASCII_c
                    | crate::ascii_h::ASCII_d
                    | crate::ascii_h_0::ASCII_e
                    | crate::ascii_h::ASCII_f => {
                        result <<= 4 as libc::c_int;
                        result += 10 as libc::c_int + (c - crate::ascii_h_0::ASCII_a)
                    }
                    _ => {}
                }
                if result >= 0x110000 as libc::c_int {
                    return -(1 as libc::c_int);
                }
                ptr = ptr.offset(2 as libc::c_int as isize)
            }
        } else {
            while !(*ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                && *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0x3b as libc::c_int)
            {
                let mut c_0: libc::c_int =
                    if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                        *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                    } else {
                        -(1 as libc::c_int)
                    };
                result *= 10 as libc::c_int;
                result += c_0 - crate::ascii_h_0::ASCII_0;
                if result >= 0x110000 as libc::c_int {
                    return -(1 as libc::c_int);
                }
                ptr = ptr.offset(2 as libc::c_int as isize)
            }
        }
        return checkCharRefNumber(result);
    }

    pub unsafe extern "C" fn little2_predefinedEntityName(
        mut _enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
    ) -> libc::c_int {
        match end.wrapping_offset_from(ptr) as libc::c_long / 2 as libc::c_int as libc::c_long {
            2 => {
                if *ptr
                    .offset(2 as libc::c_int as isize)
                    .offset(1 as libc::c_int as isize) as libc::c_int
                    == 0 as libc::c_int
                    && *ptr
                        .offset(2 as libc::c_int as isize)
                        .offset(0 as libc::c_int as isize) as libc::c_int
                        == 0x74 as libc::c_int
                {
                    match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                        == 0 as libc::c_int
                    {
                        *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                    } else {
                        -(1 as libc::c_int)
                    } {
                        crate::ascii_h_0::ASCII_l => return crate::ascii_h::ASCII_LT,
                        crate::ascii_h_0::ASCII_g => return crate::ascii_h::ASCII_GT,
                        _ => {}
                    }
                }
            }
            3 => {
                if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                    && *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0x61 as libc::c_int
                {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                        && *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                            == 0x6d as libc::c_int
                    {
                        ptr = ptr.offset(2 as libc::c_int as isize);
                        if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                            && *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                                == 0x70 as libc::c_int
                        {
                            return crate::ascii_h::ASCII_AMP;
                        }
                    }
                }
            }
            4 => {
                match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                    *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                } else {
                    -(1 as libc::c_int)
                } {
                    crate::ascii_h::ASCII_q => {
                        ptr = ptr.offset(2 as libc::c_int as isize);
                        if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                            && *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                                == 0x75 as libc::c_int
                        {
                            ptr = ptr.offset(2 as libc::c_int as isize);
                            if *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                                == 0 as libc::c_int
                                && *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                                    == 0x6f as libc::c_int
                            {
                                ptr = ptr.offset(2 as libc::c_int as isize);
                                if *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                                    == 0 as libc::c_int
                                    && *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                                        == 0x74 as libc::c_int
                                {
                                    return crate::ascii_h::ASCII_QUOT;
                                }
                            }
                        }
                    }
                    crate::ascii_h_0::ASCII_a => {
                        ptr = ptr.offset(2 as libc::c_int as isize);
                        if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                            && *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                                == 0x70 as libc::c_int
                        {
                            ptr = ptr.offset(2 as libc::c_int as isize);
                            if *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                                == 0 as libc::c_int
                                && *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                                    == 0x6f as libc::c_int
                            {
                                ptr = ptr.offset(2 as libc::c_int as isize);
                                if *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                                    == 0 as libc::c_int
                                    && *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                                        == 0x73 as libc::c_int
                                {
                                    return crate::ascii_h::ASCII_APOS;
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
            _ => {}
        }
        return 0 as libc::c_int;
    }

    pub unsafe extern "C" fn normal_predefinedEntityName(
        mut _enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
    ) -> libc::c_int {
        match end.wrapping_offset_from(ptr) as libc::c_long / 1 as libc::c_int as libc::c_long {
            2 => {
                if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0x74 as libc::c_int {
                    match *ptr as libc::c_int {
                        crate::ascii_h_0::ASCII_l => return crate::ascii_h::ASCII_LT,
                        crate::ascii_h_0::ASCII_g => return crate::ascii_h::ASCII_GT,
                        _ => {}
                    }
                }
            }
            3 => {
                if *ptr as libc::c_int == 0x61 as libc::c_int {
                    ptr = ptr.offset(1 as libc::c_int as isize);
                    if *ptr as libc::c_int == 0x6d as libc::c_int {
                        ptr = ptr.offset(1 as libc::c_int as isize);
                        if *ptr as libc::c_int == 0x70 as libc::c_int {
                            return crate::ascii_h::ASCII_AMP;
                        }
                    }
                }
            }
            4 => match *ptr as libc::c_int {
                crate::ascii_h::ASCII_q => {
                    ptr = ptr.offset(1 as libc::c_int as isize);
                    if *ptr as libc::c_int == 0x75 as libc::c_int {
                        ptr = ptr.offset(1 as libc::c_int as isize);
                        if *ptr as libc::c_int == 0x6f as libc::c_int {
                            ptr = ptr.offset(1 as libc::c_int as isize);
                            if *ptr as libc::c_int == 0x74 as libc::c_int {
                                return crate::ascii_h::ASCII_QUOT;
                            }
                        }
                    }
                }
                crate::ascii_h_0::ASCII_a => {
                    ptr = ptr.offset(1 as libc::c_int as isize);
                    if *ptr as libc::c_int == 0x70 as libc::c_int {
                        ptr = ptr.offset(1 as libc::c_int as isize);
                        if *ptr as libc::c_int == 0x6f as libc::c_int {
                            ptr = ptr.offset(1 as libc::c_int as isize);
                            if *ptr as libc::c_int == 0x73 as libc::c_int {
                                return crate::ascii_h::ASCII_APOS;
                            }
                        }
                    }
                }
                _ => {}
            },
            _ => {}
        }
        return 0 as libc::c_int;
    }

    pub unsafe extern "C" fn big2_predefinedEntityName(
        mut _enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
    ) -> libc::c_int {
        match end.wrapping_offset_from(ptr) as libc::c_long / 2 as libc::c_int as libc::c_long {
            2 => {
                if *ptr
                    .offset(2 as libc::c_int as isize)
                    .offset(0 as libc::c_int as isize) as libc::c_int
                    == 0 as libc::c_int
                    && *ptr
                        .offset(2 as libc::c_int as isize)
                        .offset(1 as libc::c_int as isize) as libc::c_int
                        == 0x74 as libc::c_int
                {
                    match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                        == 0 as libc::c_int
                    {
                        *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                    } else {
                        -(1 as libc::c_int)
                    } {
                        crate::ascii_h_0::ASCII_l => return crate::ascii_h::ASCII_LT,
                        crate::ascii_h_0::ASCII_g => return crate::ascii_h::ASCII_GT,
                        _ => {}
                    }
                }
            }
            3 => {
                if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                    && *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0x61 as libc::c_int
                {
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                        && *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                            == 0x6d as libc::c_int
                    {
                        ptr = ptr.offset(2 as libc::c_int as isize);
                        if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                            && *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                                == 0x70 as libc::c_int
                        {
                            return crate::ascii_h::ASCII_AMP;
                        }
                    }
                }
            }
            4 => {
                match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                    *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                } else {
                    -(1 as libc::c_int)
                } {
                    crate::ascii_h::ASCII_q => {
                        ptr = ptr.offset(2 as libc::c_int as isize);
                        if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                            && *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                                == 0x75 as libc::c_int
                        {
                            ptr = ptr.offset(2 as libc::c_int as isize);
                            if *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                                == 0 as libc::c_int
                                && *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                                    == 0x6f as libc::c_int
                            {
                                ptr = ptr.offset(2 as libc::c_int as isize);
                                if *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                                    == 0 as libc::c_int
                                    && *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                                        == 0x74 as libc::c_int
                                {
                                    return crate::ascii_h::ASCII_QUOT;
                                }
                            }
                        }
                    }
                    crate::ascii_h_0::ASCII_a => {
                        ptr = ptr.offset(2 as libc::c_int as isize);
                        if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                            && *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                                == 0x70 as libc::c_int
                        {
                            ptr = ptr.offset(2 as libc::c_int as isize);
                            if *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                                == 0 as libc::c_int
                                && *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                                    == 0x6f as libc::c_int
                            {
                                ptr = ptr.offset(2 as libc::c_int as isize);
                                if *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                                    == 0 as libc::c_int
                                    && *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                                        == 0x73 as libc::c_int
                                {
                                    return crate::ascii_h::ASCII_APOS;
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
            _ => {}
        }
        return 0 as libc::c_int;
    }

    pub unsafe extern "C" fn normal_nameMatchesAscii(
        mut _enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr1: *const libc::c_char,
        mut end1: *const libc::c_char,
        mut ptr2: *const libc::c_char,
    ) -> libc::c_int {
        while *ptr2 != 0 {
            if (end1.wrapping_offset_from(ptr1) as libc::c_long) < 1 as libc::c_int as libc::c_long
            {
                /* This line cannot be executed.  The incoming data has already
                 * been tokenized once, so incomplete characters like this have
                 * already been eliminated from the input.  Retaining the
                 * paranoia check is still valuable, however.
                 */
                /* This line cannot be executed.  The incoming data has already
                 * been tokenized once, so incomplete characters like this have
                 * already been eliminated from the input.  Retaining the
                 * paranoia check is still valuable, however.
                 */
                /* This line cannot be executed.  The incoming data has already
                 * been tokenized once, so incomplete characters like this have
                 * already been eliminated from the input.  Retaining the
                 * paranoia check is still valuable, however.
                 */
                return 0 as libc::c_int;
                /* LCOV_EXCL_LINE */
                /* LCOV_EXCL_LINE */
                /* LCOV_EXCL_LINE */
            }
            if !(*ptr1 as libc::c_int == *ptr2 as libc::c_int) {
                return 0 as libc::c_int;
            }
            ptr1 = ptr1.offset(1 as libc::c_int as isize);
            ptr2 = ptr2.offset(1)
        }
        return (ptr1 == end1) as libc::c_int;
    }

    pub unsafe extern "C" fn big2_nameMatchesAscii(
        mut _enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr1: *const libc::c_char,
        mut end1: *const libc::c_char,
        mut ptr2: *const libc::c_char,
    ) -> libc::c_int {
        while *ptr2 != 0 {
            if (end1.wrapping_offset_from(ptr1) as libc::c_long) < 2 as libc::c_int as libc::c_long
            {
                return 0 as libc::c_int;
            }
            if !(*ptr1.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                && *ptr1.offset(1 as libc::c_int as isize) as libc::c_int == *ptr2 as libc::c_int)
            {
                return 0 as libc::c_int;
            }
            ptr1 = ptr1.offset(2 as libc::c_int as isize);
            ptr2 = ptr2.offset(1)
        }
        return (ptr1 == end1) as libc::c_int;
    }

    pub unsafe extern "C" fn little2_nameMatchesAscii(
        mut _enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr1: *const libc::c_char,
        mut end1: *const libc::c_char,
        mut ptr2: *const libc::c_char,
    ) -> libc::c_int {
        while *ptr2 != 0 {
            if (end1.wrapping_offset_from(ptr1) as libc::c_long) < 2 as libc::c_int as libc::c_long
            {
                return 0 as libc::c_int;
            }
            if !(*ptr1.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                && *ptr1.offset(0 as libc::c_int as isize) as libc::c_int == *ptr2 as libc::c_int)
            {
                return 0 as libc::c_int;
            }
            ptr1 = ptr1.offset(2 as libc::c_int as isize);
            ptr2 = ptr2.offset(1)
        }
        return (ptr1 == end1) as libc::c_int;
    }

    pub unsafe extern "C" fn normal_nameLength(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
    ) -> libc::c_int {
        let mut start: *const libc::c_char = ptr;
        loop {
            match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                as libc::c_int
            {
                5 => ptr = ptr.offset(2 as libc::c_int as isize),
                6 => ptr = ptr.offset(3 as libc::c_int as isize),
                7 => ptr = ptr.offset(4 as libc::c_int as isize),
                29 | 22 | 23 | 24 | 25 | 26 | 27 => ptr = ptr.offset(1 as libc::c_int as isize),
                _ => return ptr.wrapping_offset_from(start) as libc::c_long as libc::c_int,
            }
        }
    }

    pub unsafe extern "C" fn big2_nameLength(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
    ) -> libc::c_int {
        let mut start: *const libc::c_char = ptr;
        loop {
            match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0
                    [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(0 as libc::c_int as isize),
                    *ptr.offset(1 as libc::c_int as isize),
                )
            } {
                5 => ptr = ptr.offset(2 as libc::c_int as isize),
                6 => ptr = ptr.offset(3 as libc::c_int as isize),
                7 => ptr = ptr.offset(4 as libc::c_int as isize),
                29 | 22 | 23 | 24 | 25 | 26 | 27 => ptr = ptr.offset(2 as libc::c_int as isize),
                _ => return ptr.wrapping_offset_from(start) as libc::c_long as libc::c_int,
            }
        }
    }

    pub unsafe extern "C" fn little2_nameLength(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
    ) -> libc::c_int {
        let mut start: *const libc::c_char = ptr;
        loop {
            match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(1 as libc::c_int as isize),
                    *ptr.offset(0 as libc::c_int as isize),
                )
            } {
                5 => ptr = ptr.offset(2 as libc::c_int as isize),
                6 => ptr = ptr.offset(3 as libc::c_int as isize),
                7 => ptr = ptr.offset(4 as libc::c_int as isize),
                29 | 22 | 23 | 24 | 25 | 26 | 27 => ptr = ptr.offset(2 as libc::c_int as isize),
                _ => return ptr.wrapping_offset_from(start) as libc::c_long as libc::c_int,
            }
        }
    }

    pub unsafe extern "C" fn little2_skipS(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
    ) -> *const libc::c_char {
        loop {
            match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(1 as libc::c_int as isize),
                    *ptr.offset(0 as libc::c_int as isize),
                )
            } {
                10 | 9 | 21 => ptr = ptr.offset(2 as libc::c_int as isize),
                _ => return ptr,
            }
        }
    }

    pub unsafe extern "C" fn big2_skipS(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
    ) -> *const libc::c_char {
        loop {
            match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0
                    [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(0 as libc::c_int as isize),
                    *ptr.offset(1 as libc::c_int as isize),
                )
            } {
                10 | 9 | 21 => ptr = ptr.offset(2 as libc::c_int as isize),
                _ => return ptr,
            }
        }
    }

    pub unsafe extern "C" fn normal_skipS(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
    ) -> *const libc::c_char {
        loop {
            match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                as libc::c_int
            {
                10 | 9 | 21 => ptr = ptr.offset(1 as libc::c_int as isize),
                _ => return ptr,
            }
        }
    }

    pub unsafe extern "C" fn normal_updatePosition(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut pos: *mut crate::src::lib::xmltok::POSITION,
    ) {
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long
        {
            match (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                as libc::c_int
            {
                5 => ptr = ptr.offset(2 as libc::c_int as isize),
                6 => ptr = ptr.offset(3 as libc::c_int as isize),
                7 => ptr = ptr.offset(4 as libc::c_int as isize),
                10 => {
                    (*pos).columnNumber = -(1 as libc::c_int) as crate::expat_external_h::XML_Size;
                    (*pos).lineNumber = (*pos).lineNumber.wrapping_add(1);
                    ptr = ptr.offset(1 as libc::c_int as isize)
                }
                9 => {
                    (*pos).lineNumber = (*pos).lineNumber.wrapping_add(1);
                    ptr = ptr.offset(1 as libc::c_int as isize);
                    if end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 1 as libc::c_int) as libc::c_long
                        && (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                            as libc::c_int
                            == crate::xmltok_impl_h::BT_LF as libc::c_int
                    {
                        ptr = ptr.offset(1 as libc::c_int as isize)
                    }
                    (*pos).columnNumber = -(1 as libc::c_int) as crate::expat_external_h::XML_Size
                }
                _ => ptr = ptr.offset(1 as libc::c_int as isize),
            }
            (*pos).columnNumber = (*pos).columnNumber.wrapping_add(1)
        }
    }

    pub unsafe extern "C" fn big2_updatePosition(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut pos: *mut crate::src::lib::xmltok::POSITION,
    ) {
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            match if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0
                    [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(0 as libc::c_int as isize),
                    *ptr.offset(1 as libc::c_int as isize),
                )
            } {
                5 => ptr = ptr.offset(2 as libc::c_int as isize),
                6 => ptr = ptr.offset(3 as libc::c_int as isize),
                7 => ptr = ptr.offset(4 as libc::c_int as isize),
                10 => {
                    (*pos).columnNumber = -(1 as libc::c_int) as crate::expat_external_h::XML_Size;
                    (*pos).lineNumber = (*pos).lineNumber.wrapping_add(1);
                    ptr = ptr.offset(2 as libc::c_int as isize)
                }
                9 => {
                    (*pos).lineNumber = (*pos).lineNumber.wrapping_add(1);
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    if end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
                        && (if *ptr.offset(0 as libc::c_int as isize) as libc::c_int
                            == 0 as libc::c_int
                        {
                            (*(enc as *mut normal_encoding)).type_0
                                [*ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as usize]
                                as libc::c_int
                        } else {
                            unicode_byte_type(
                                *ptr.offset(0 as libc::c_int as isize),
                                *ptr.offset(1 as libc::c_int as isize),
                            )
                        }) == crate::xmltok_impl_h::BT_LF as libc::c_int
                    {
                        ptr = ptr.offset(2 as libc::c_int as isize)
                    }
                    (*pos).columnNumber = -(1 as libc::c_int) as crate::expat_external_h::XML_Size
                }
                _ => ptr = ptr.offset(2 as libc::c_int as isize),
            }
            (*pos).columnNumber = (*pos).columnNumber.wrapping_add(1)
        }
    }

    pub unsafe extern "C" fn little2_updatePosition(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut pos: *mut crate::src::lib::xmltok::POSITION,
    ) {
        while end.wrapping_offset_from(ptr) as libc::c_long
            >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
        {
            match if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
                (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                    as libc::c_int
            } else {
                unicode_byte_type(
                    *ptr.offset(1 as libc::c_int as isize),
                    *ptr.offset(0 as libc::c_int as isize),
                )
            } {
                5 => ptr = ptr.offset(2 as libc::c_int as isize),
                6 => ptr = ptr.offset(3 as libc::c_int as isize),
                7 => ptr = ptr.offset(4 as libc::c_int as isize),
                10 => {
                    (*pos).columnNumber = -(1 as libc::c_int) as crate::expat_external_h::XML_Size;
                    (*pos).lineNumber = (*pos).lineNumber.wrapping_add(1);
                    ptr = ptr.offset(2 as libc::c_int as isize)
                }
                9 => {
                    (*pos).lineNumber = (*pos).lineNumber.wrapping_add(1);
                    ptr = ptr.offset(2 as libc::c_int as isize);
                    if end.wrapping_offset_from(ptr) as libc::c_long
                        >= (1 as libc::c_int * 2 as libc::c_int) as libc::c_long
                        && (if *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                            == 0 as libc::c_int
                        {
                            (*(enc as *mut normal_encoding)).type_0[*ptr as libc::c_uchar as usize]
                                as libc::c_int
                        } else {
                            unicode_byte_type(
                                *ptr.offset(1 as libc::c_int as isize),
                                *ptr.offset(0 as libc::c_int as isize),
                            )
                        }) == crate::xmltok_impl_h::BT_LF as libc::c_int
                    {
                        ptr = ptr.offset(2 as libc::c_int as isize)
                    }
                    (*pos).columnNumber = -(1 as libc::c_int) as crate::expat_external_h::XML_Size
                }
                _ => ptr = ptr.offset(2 as libc::c_int as isize),
            }
            (*pos).columnNumber = (*pos).columnNumber.wrapping_add(1)
        }
    }

    use crate::src::lib::xmltok::nametab_h::{namePages, namingBitmap, nmstrtPages};
    use crate::src::lib::xmltok::{checkCharRefNumber, normal_encoding, unicode_byte_type};

    /* XML_TOK_IMPL_C */
    /* XML_TOK_IMPL_C */
    /* XML_TOK_IMPL_C */
}

pub mod nametab_h {
    /*
                                __  __            _
                             ___\ \/ /_ __   __ _| |_
                            / _ \\  /| '_ \ / _` | __|
                           |  __//  \| |_) | (_| | |_
                            \___/_/\_\ .__/ \__,_|\__|
                                     |_| XML parser

       Copyright (c) 1997-2000 Thai Open Source Software Center Ltd
       Copyright (c) 2000-2017 Expat development team
       Licensed under the MIT license:

       Permission is  hereby granted,  free of charge,  to any  person obtaining
       a  copy  of  this  software   and  associated  documentation  files  (the
       "Software"),  to  deal in  the  Software  without restriction,  including
       without  limitation the  rights  to use,  copy,  modify, merge,  publish,
       distribute, sublicense, and/or sell copies of the Software, and to permit
       persons  to whom  the Software  is  furnished to  do so,  subject to  the
       following conditions:

       The above copyright  notice and this permission notice  shall be included
       in all copies or substantial portions of the Software.

       THE  SOFTWARE  IS  PROVIDED  "AS  IS",  WITHOUT  WARRANTY  OF  ANY  KIND,
       EXPRESS  OR IMPLIED,  INCLUDING  BUT  NOT LIMITED  TO  THE WARRANTIES  OF
       MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
       NO EVENT SHALL THE AUTHORS OR  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
       DAMAGES OR  OTHER LIABILITY, WHETHER  IN AN  ACTION OF CONTRACT,  TORT OR
       OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
       USE OR OTHER DEALINGS IN THE SOFTWARE.
    */

    pub static mut namingBitmap: [libc::c_uint; 320] = [
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xffffffff as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0x4000000 as libc::c_int as libc::c_uint,
        0x87fffffe as libc::c_uint,
        0x7fffffe as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0xff7fffff as libc::c_uint,
        0xff7fffff as libc::c_uint,
        0xffffffff as libc::c_uint,
        0x7ff3ffff as libc::c_int as libc::c_uint,
        0xfffffdfe as libc::c_uint,
        0x7fffffff as libc::c_int as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xffffe00f as libc::c_uint,
        0xfc31ffff as libc::c_uint,
        0xffffff as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0xffff0000 as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xf80001ff as libc::c_uint,
        0x3 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0xffffd740 as libc::c_uint,
        0xfffffffb as libc::c_uint,
        0x547f7fff as libc::c_int as libc::c_uint,
        0xffffd as libc::c_int as libc::c_uint,
        0xffffdffe as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xdffeffff as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xffff0003 as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xffff199f as libc::c_uint,
        0x33fcfff as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0xfffe0000 as libc::c_uint,
        0x27fffff as libc::c_int as libc::c_uint,
        0xfffffffe as libc::c_uint,
        0x7f as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0xffff0000 as libc::c_uint,
        0x707ff as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0x7fffffe as libc::c_int as libc::c_uint,
        0x7fe as libc::c_int as libc::c_uint,
        0xfffe0000 as libc::c_uint,
        0xffffffff as libc::c_uint,
        0x7cffffff as libc::c_int as libc::c_uint,
        0x2f7fff as libc::c_int as libc::c_uint,
        0x60 as libc::c_int as libc::c_uint,
        0xffffffe0 as libc::c_uint,
        0x23ffffff as libc::c_int as libc::c_uint,
        0xff000000 as libc::c_uint,
        0x3 as libc::c_int as libc::c_uint,
        0xfff99fe0 as libc::c_uint,
        0x3c5fdff as libc::c_int as libc::c_uint,
        0xb0000000 as libc::c_uint,
        0x30003 as libc::c_int as libc::c_uint,
        0xfff987e0 as libc::c_uint,
        0x36dfdff as libc::c_int as libc::c_uint,
        0x5e000000 as libc::c_int as libc::c_uint,
        0x1c0000 as libc::c_int as libc::c_uint,
        0xfffbafe0 as libc::c_uint,
        0x23edfdff as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0x1 as libc::c_int as libc::c_uint,
        0xfff99fe0 as libc::c_uint,
        0x23cdfdff as libc::c_int as libc::c_uint,
        0xb0000000 as libc::c_uint,
        0x3 as libc::c_int as libc::c_uint,
        0xd63dc7e0 as libc::c_uint,
        0x3bfc718 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0xfffddfe0 as libc::c_uint,
        0x3effdff as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0x3 as libc::c_int as libc::c_uint,
        0xfffddfe0 as libc::c_uint,
        0x3effdff as libc::c_int as libc::c_uint,
        0x40000000 as libc::c_int as libc::c_uint,
        0x3 as libc::c_int as libc::c_uint,
        0xfffddfe0 as libc::c_uint,
        0x3fffdff as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0x3 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0xfffffffe as libc::c_uint,
        0xd7fff as libc::c_int as libc::c_uint,
        0x3f as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0xfef02596 as libc::c_uint,
        0x200d6cae as libc::c_int as libc::c_uint,
        0x1f as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0xfffffeff as libc::c_uint,
        0x3ff as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xffff003f as libc::c_uint,
        0x7fffff as libc::c_int as libc::c_uint,
        0x7daed as libc::c_int as libc::c_uint,
        0x50000000 as libc::c_int as libc::c_uint,
        0x82315001 as libc::c_uint,
        0x2c62ab as libc::c_int as libc::c_uint,
        0x40000000 as libc::c_int as libc::c_uint,
        0xf580c900 as libc::c_uint,
        0x7 as libc::c_int as libc::c_uint,
        0x2010800 as libc::c_int as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xfffffff as libc::c_int as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xffffffff as libc::c_uint,
        0x3ffffff as libc::c_int as libc::c_uint,
        0x3f3fffff as libc::c_int as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xaaff3f3f as libc::c_uint,
        0x3fffffff as libc::c_int as libc::c_uint,
        0xffffffff as libc::c_uint,
        0x5fdfffff as libc::c_int as libc::c_uint,
        0xfcf1fdc as libc::c_int as libc::c_uint,
        0x1fdc1fff as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0x4c40 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0x7 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0x80 as libc::c_int as libc::c_uint,
        0x3fe as libc::c_int as libc::c_uint,
        0xfffffffe as libc::c_uint,
        0xffffffff as libc::c_uint,
        0x1fffff as libc::c_int as libc::c_uint,
        0xfffffffe as libc::c_uint,
        0xffffffff as libc::c_uint,
        0x7ffffff as libc::c_int as libc::c_uint,
        0xffffffe0 as libc::c_uint,
        0x1fff as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xffffffff as libc::c_uint,
        0x3f as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xf as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0x7ff6000 as libc::c_int as libc::c_uint,
        0x87fffffe as libc::c_uint,
        0x7fffffe as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0x800000 as libc::c_int as libc::c_uint,
        0xff7fffff as libc::c_uint,
        0xff7fffff as libc::c_uint,
        0xffffff as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0xffff0000 as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xf80001ff as libc::c_uint,
        0x30003 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xffffffff as libc::c_uint,
        0x3f as libc::c_int as libc::c_uint,
        0x3 as libc::c_int as libc::c_uint,
        0xffffd7c0 as libc::c_uint,
        0xfffffffb as libc::c_uint,
        0x547f7fff as libc::c_int as libc::c_uint,
        0xffffd as libc::c_int as libc::c_uint,
        0xffffdffe as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xdffeffff as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xffff007b as libc::c_uint,
        0xffffffff as libc::c_uint,
        0xffff199f as libc::c_uint,
        0x33fcfff as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0xfffe0000 as libc::c_uint,
        0x27fffff as libc::c_int as libc::c_uint,
        0xfffffffe as libc::c_uint,
        0xfffe007f as libc::c_uint,
        0xbbfffffb as libc::c_uint,
        0xffff0016 as libc::c_uint,
        0x707ff as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0x7fffffe as libc::c_int as libc::c_uint,
        0x7ffff as libc::c_int as libc::c_uint,
        0xffff03ff as libc::c_uint,
        0xffffffff as libc::c_uint,
        0x7cffffff as libc::c_int as libc::c_uint,
        0xffef7fff as libc::c_uint,
        0x3ff3dff as libc::c_int as libc::c_uint,
        0xffffffee as libc::c_uint,
        0xf3ffffff as libc::c_uint,
        0xff1e3fff as libc::c_uint,
        0xffcf as libc::c_int as libc::c_uint,
        0xfff99fee as libc::c_uint,
        0xd3c5fdff as libc::c_uint,
        0xb080399f as libc::c_uint,
        0x3ffcf as libc::c_int as libc::c_uint,
        0xfff987e4 as libc::c_uint,
        0xd36dfdff as libc::c_uint,
        0x5e003987 as libc::c_int as libc::c_uint,
        0x1fffc0 as libc::c_int as libc::c_uint,
        0xfffbafee as libc::c_uint,
        0xf3edfdff as libc::c_uint,
        0x3bbf as libc::c_int as libc::c_uint,
        0xffc1 as libc::c_int as libc::c_uint,
        0xfff99fee as libc::c_uint,
        0xf3cdfdff as libc::c_uint,
        0xb0c0398f as libc::c_uint,
        0xffc3 as libc::c_int as libc::c_uint,
        0xd63dc7ec as libc::c_uint,
        0xc3bfc718 as libc::c_uint,
        0x803dc7 as libc::c_int as libc::c_uint,
        0xff80 as libc::c_int as libc::c_uint,
        0xfffddfee as libc::c_uint,
        0xc3effdff as libc::c_uint,
        0x603ddf as libc::c_int as libc::c_uint,
        0xffc3 as libc::c_int as libc::c_uint,
        0xfffddfec as libc::c_uint,
        0xc3effdff as libc::c_uint,
        0x40603ddf as libc::c_int as libc::c_uint,
        0xffc3 as libc::c_int as libc::c_uint,
        0xfffddfec as libc::c_uint,
        0xc3fffdff as libc::c_uint,
        0x803dcf as libc::c_int as libc::c_uint,
        0xffc3 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0xfffffffe as libc::c_uint,
        0x7ff7fff as libc::c_int as libc::c_uint,
        0x3ff7fff as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0xfef02596 as libc::c_uint,
        0x3bff6cae as libc::c_int as libc::c_uint,
        0x3ff3f5f as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0x3000000 as libc::c_int as libc::c_uint,
        0xc2a003ff as libc::c_uint,
        0xfffffeff as libc::c_uint,
        0xfffe03ff as libc::c_uint,
        0xfebf0fdf as libc::c_uint,
        0x2fe3fff as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0 as libc::c_int as libc::c_uint,
        0x1fff0000 as libc::c_int as libc::c_uint,
        0x2 as libc::c_int as libc::c_uint,
        0xa0 as libc::c_int as libc::c_uint,
        0x3efffe as libc::c_int as libc::c_uint,
        0xfffffffe as libc::c_uint,
        0xffffffff as libc::c_uint,
        0x661fffff as libc::c_int as libc::c_uint,
        0xfffffffe as libc::c_uint,
        0xffffffff as libc::c_uint,
        0x77ffffff as libc::c_int as libc::c_uint,
    ];

    pub static mut nmstrtPages: [libc::c_uchar; 256] = [
        0x2 as libc::c_int as libc::c_uchar,
        0x3 as libc::c_int as libc::c_uchar,
        0x4 as libc::c_int as libc::c_uchar,
        0x5 as libc::c_int as libc::c_uchar,
        0x6 as libc::c_int as libc::c_uchar,
        0x7 as libc::c_int as libc::c_uchar,
        0x8 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0x9 as libc::c_int as libc::c_uchar,
        0xa as libc::c_int as libc::c_uchar,
        0xb as libc::c_int as libc::c_uchar,
        0xc as libc::c_int as libc::c_uchar,
        0xd as libc::c_int as libc::c_uchar,
        0xe as libc::c_int as libc::c_uchar,
        0xf as libc::c_int as libc::c_uchar,
        0x10 as libc::c_int as libc::c_uchar,
        0x11 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0x12 as libc::c_int as libc::c_uchar,
        0x13 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0x14 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0x15 as libc::c_int as libc::c_uchar,
        0x16 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x17 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x18 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
    ];

    pub static mut namePages: [libc::c_uchar; 256] = [
        0x19 as libc::c_int as libc::c_uchar,
        0x3 as libc::c_int as libc::c_uchar,
        0x1a as libc::c_int as libc::c_uchar,
        0x1b as libc::c_int as libc::c_uchar,
        0x1c as libc::c_int as libc::c_uchar,
        0x1d as libc::c_int as libc::c_uchar,
        0x1e as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0x1f as libc::c_int as libc::c_uchar,
        0x20 as libc::c_int as libc::c_uchar,
        0x21 as libc::c_int as libc::c_uchar,
        0x22 as libc::c_int as libc::c_uchar,
        0x23 as libc::c_int as libc::c_uchar,
        0x24 as libc::c_int as libc::c_uchar,
        0x25 as libc::c_int as libc::c_uchar,
        0x10 as libc::c_int as libc::c_uchar,
        0x11 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0x12 as libc::c_int as libc::c_uchar,
        0x13 as libc::c_int as libc::c_uchar,
        0x26 as libc::c_int as libc::c_uchar,
        0x14 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0x27 as libc::c_int as libc::c_uchar,
        0x16 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x17 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        0x18 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
        0 as libc::c_int as libc::c_uchar,
    ];
}

pub mod xmltok_ns_c {
    /* This file is included!
                                __  __            _
                             ___\ \/ /_ __   __ _| |_
                            / _ \\  /| '_ \ / _` | __|
                           |  __//  \| |_) | (_| | |_
                            \___/_/\_\ .__/ \__,_|\__|
                                     |_| XML parser

       Copyright (c) 1997-2000 Thai Open Source Software Center Ltd
       Copyright (c) 2000-2017 Expat development team
       Licensed under the MIT license:

       Permission is  hereby granted,  free of charge,  to any  person obtaining
       a  copy  of  this  software   and  associated  documentation  files  (the
       "Software"),  to  deal in  the  Software  without restriction,  including
       without  limitation the  rights  to use,  copy,  modify, merge,  publish,
       distribute, sublicense, and/or sell copies of the Software, and to permit
       persons  to whom  the Software  is  furnished to  do so,  subject to  the
       following conditions:

       The above copyright  notice and this permission notice  shall be included
       in all copies or substantial portions of the Software.

       THE  SOFTWARE  IS  PROVIDED  "AS  IS",  WITHOUT  WARRANTY  OF  ANY  KIND,
       EXPRESS  OR IMPLIED,  INCLUDING  BUT  NOT LIMITED  TO  THE WARRANTIES  OF
       MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
       NO EVENT SHALL THE AUTHORS OR  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
       DAMAGES OR  OTHER LIABILITY, WHETHER  IN AN  ACTION OF CONTRACT,  TORT OR
       OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
       USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
    /* This file is included!
                                __  __            _
                             ___\ \/ /_ __   __ _| |_
                            / _ \\  /| '_ \ / _` | __|
                           |  __//  \| |_) | (_| | |_
                            \___/_/\_\ .__/ \__,_|\__|
                                     |_| XML parser

       Copyright (c) 1997-2000 Thai Open Source Software Center Ltd
       Copyright (c) 2000-2017 Expat development team
       Licensed under the MIT license:

       Permission is  hereby granted,  free of charge,  to any  person obtaining
       a  copy  of  this  software   and  associated  documentation  files  (the
       "Software"),  to  deal in  the  Software  without restriction,  including
       without  limitation the  rights  to use,  copy,  modify, merge,  publish,
       distribute, sublicense, and/or sell copies of the Software, and to permit
       persons  to whom  the Software  is  furnished to  do so,  subject to  the
       following conditions:

       The above copyright  notice and this permission notice  shall be included
       in all copies or substantial portions of the Software.

       THE  SOFTWARE  IS  PROVIDED  "AS  IS",  WITHOUT  WARRANTY  OF  ANY  KIND,
       EXPRESS  OR IMPLIED,  INCLUDING  BUT  NOT LIMITED  TO  THE WARRANTIES  OF
       MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
       NO EVENT SHALL THE AUTHORS OR  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
       DAMAGES OR  OTHER LIABILITY, WHETHER  IN AN  ACTION OF CONTRACT,  TORT OR
       OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
       USE OR OTHER DEALINGS IN THE SOFTWARE.
    */
    #[no_mangle]

    pub unsafe extern "C" fn XmlGetUtf8InternalEncodingNS(
    ) -> *const crate::src::lib::xmltok::ENCODING {
        return &internal_utf8_encoding_ns.enc;
    }
    #[no_mangle]

    pub unsafe extern "C" fn XmlGetUtf8InternalEncoding() -> *const crate::src::lib::xmltok::ENCODING
    {
        return &internal_utf8_encoding.enc;
    }
    #[no_mangle]

    pub unsafe extern "C" fn XmlGetUtf16InternalEncoding(
    ) -> *const crate::src::lib::xmltok::ENCODING {
        return &internal_little2_encoding.enc;
    }
    #[no_mangle]

    pub unsafe extern "C" fn XmlGetUtf16InternalEncodingNS(
    ) -> *const crate::src::lib::xmltok::ENCODING {
        return &internal_little2_encoding_ns.enc;
    }
    // Initialized in run_static_initializers

    pub static mut encodingsNS: [*const crate::src::lib::xmltok::ENCODING; 7] =
        [0 as *const crate::src::lib::xmltok::ENCODING; 7];
    // Initialized in run_static_initializers

    pub static mut encodings: [*const crate::src::lib::xmltok::ENCODING; 7] =
        [0 as *const crate::src::lib::xmltok::ENCODING; 7];

    pub unsafe extern "C" fn initScanProlog(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        return initScan(
            encodings.as_ptr(),
            enc as *const crate::src::lib::xmltok::INIT_ENCODING,
            crate::src::lib::xmltok::XML_PROLOG_STATE,
            ptr,
            end,
            nextTokPtr,
        );
    }

    pub unsafe extern "C" fn initScanPrologNS(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        return initScan(
            encodingsNS.as_ptr(),
            enc as *const crate::src::lib::xmltok::INIT_ENCODING,
            crate::src::lib::xmltok::XML_PROLOG_STATE,
            ptr,
            end,
            nextTokPtr,
        );
    }

    pub unsafe extern "C" fn initScanContentNS(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        return initScan(
            encodingsNS.as_ptr(),
            enc as *const crate::src::lib::xmltok::INIT_ENCODING,
            crate::src::lib::xmltok::XML_CONTENT_STATE,
            ptr,
            end,
            nextTokPtr,
        );
    }

    pub unsafe extern "C" fn initScanContent(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut nextTokPtr: *mut *const libc::c_char,
    ) -> libc::c_int {
        return initScan(
            encodings.as_ptr(),
            enc as *const crate::src::lib::xmltok::INIT_ENCODING,
            crate::src::lib::xmltok::XML_CONTENT_STATE,
            ptr,
            end,
            nextTokPtr,
        );
    }
    #[no_mangle]

    pub unsafe extern "C" fn XmlInitEncodingNS(
        mut p: *mut crate::src::lib::xmltok::INIT_ENCODING,
        mut encPtr: *mut *const crate::src::lib::xmltok::ENCODING,
        mut name: *const libc::c_char,
    ) -> libc::c_int {
        let mut i: libc::c_int = getEncodingIndex(name);
        if i == UNKNOWN_ENC as libc::c_int {
            return 0 as libc::c_int;
        }
        (*p).initEnc.isUtf16 = i as libc::c_char;
        (*p).initEnc.scanners[crate::src::lib::xmltok::XML_PROLOG_STATE as usize] = Some(
            initScanPrologNS
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                    _: *const libc::c_char,
                    _: *mut *const libc::c_char,
                ) -> libc::c_int,
        );
        (*p).initEnc.scanners[crate::src::lib::xmltok::XML_CONTENT_STATE as usize] = Some(
            initScanContentNS
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                    _: *const libc::c_char,
                    _: *mut *const libc::c_char,
                ) -> libc::c_int,
        );
        (*p).initEnc.updatePosition = Some(
            initUpdatePosition
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                    _: *const libc::c_char,
                    _: *mut crate::src::lib::xmltok::POSITION,
                ) -> (),
        );
        (*p).encPtr = encPtr;
        *encPtr = &mut (*p).initEnc;
        return 1 as libc::c_int;
    }
    #[no_mangle]

    pub unsafe extern "C" fn XmlInitEncoding(
        mut p: *mut crate::src::lib::xmltok::INIT_ENCODING,
        mut encPtr: *mut *const crate::src::lib::xmltok::ENCODING,
        mut name: *const libc::c_char,
    ) -> libc::c_int {
        let mut i: libc::c_int = getEncodingIndex(name);
        if i == UNKNOWN_ENC as libc::c_int {
            return 0 as libc::c_int;
        }
        (*p).initEnc.isUtf16 = i as libc::c_char;
        (*p).initEnc.scanners[crate::src::lib::xmltok::XML_PROLOG_STATE as usize] = Some(
            initScanProlog
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                    _: *const libc::c_char,
                    _: *mut *const libc::c_char,
                ) -> libc::c_int,
        );
        (*p).initEnc.scanners[crate::src::lib::xmltok::XML_CONTENT_STATE as usize] = Some(
            initScanContent
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                    _: *const libc::c_char,
                    _: *mut *const libc::c_char,
                ) -> libc::c_int,
        );
        (*p).initEnc.updatePosition = Some(
            initUpdatePosition
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                    _: *const libc::c_char,
                    _: *mut crate::src::lib::xmltok::POSITION,
                ) -> (),
        );
        (*p).encPtr = encPtr;
        *encPtr = &mut (*p).initEnc;
        return 1 as libc::c_int;
    }

    pub unsafe extern "C" fn findEncoding(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
    ) -> *const crate::src::lib::xmltok::ENCODING {
        let mut buf: [libc::c_char; 128] = [0; 128];
        let mut p: *mut libc::c_char = buf.as_mut_ptr();
        let mut i: libc::c_int = 0;
        (*enc).utf8Convert.expect("non-null function pointer")(
            enc,
            &mut ptr,
            end,
            &mut p,
            p.offset(128 as libc::c_int as isize)
                .offset(-(1 as libc::c_int as isize)),
        );
        if ptr != end {
            return 0 as *const crate::src::lib::xmltok::ENCODING;
        }
        *p = 0 as libc::c_int as libc::c_char;
        if streqci(buf.as_mut_ptr(), KW_UTF_16.as_ptr()) != 0
            && (*enc).minBytesPerChar == 2 as libc::c_int
        {
            return enc;
        }
        i = getEncodingIndex(buf.as_mut_ptr());
        if i == UNKNOWN_ENC as libc::c_int {
            return 0 as *const crate::src::lib::xmltok::ENCODING;
        }
        return encodings[i as usize];
    }

    pub unsafe extern "C" fn findEncodingNS(
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
    ) -> *const crate::src::lib::xmltok::ENCODING {
        let mut buf: [libc::c_char; 128] = [0; 128];
        let mut p: *mut libc::c_char = buf.as_mut_ptr();
        let mut i: libc::c_int = 0;
        (*enc).utf8Convert.expect("non-null function pointer")(
            enc,
            &mut ptr,
            end,
            &mut p,
            p.offset(128 as libc::c_int as isize)
                .offset(-(1 as libc::c_int as isize)),
        );
        if ptr != end {
            return 0 as *const crate::src::lib::xmltok::ENCODING;
        }
        *p = 0 as libc::c_int as libc::c_char;
        if streqci(buf.as_mut_ptr(), KW_UTF_16.as_ptr()) != 0
            && (*enc).minBytesPerChar == 2 as libc::c_int
        {
            return enc;
        }
        i = getEncodingIndex(buf.as_mut_ptr());
        if i == UNKNOWN_ENC as libc::c_int {
            return 0 as *const crate::src::lib::xmltok::ENCODING;
        }
        return encodingsNS[i as usize];
    }
    #[no_mangle]

    pub unsafe extern "C" fn XmlParseXmlDeclNS(
        mut isGeneralTextEntity: libc::c_int,
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut badPtr: *mut *const libc::c_char,
        mut versionPtr: *mut *const libc::c_char,
        mut versionEndPtr: *mut *const libc::c_char,
        mut encodingName: *mut *const libc::c_char,
        mut encoding: *mut *const crate::src::lib::xmltok::ENCODING,
        mut standalone: *mut libc::c_int,
    ) -> libc::c_int {
        return doParseXmlDecl(
            Some(
                findEncodingNS
                    as unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                        _: *const libc::c_char,
                    )
                        -> *const crate::src::lib::xmltok::ENCODING,
            ),
            isGeneralTextEntity,
            enc,
            ptr,
            end,
            badPtr,
            versionPtr,
            versionEndPtr,
            encodingName,
            encoding,
            standalone,
        );
    }
    #[no_mangle]

    pub unsafe extern "C" fn XmlParseXmlDecl(
        mut isGeneralTextEntity: libc::c_int,
        mut enc: *const crate::src::lib::xmltok::ENCODING,
        mut ptr: *const libc::c_char,
        mut end: *const libc::c_char,
        mut badPtr: *mut *const libc::c_char,
        mut versionPtr: *mut *const libc::c_char,
        mut versionEndPtr: *mut *const libc::c_char,
        mut encodingName: *mut *const libc::c_char,
        mut encoding: *mut *const crate::src::lib::xmltok::ENCODING,
        mut standalone: *mut libc::c_int,
    ) -> libc::c_int {
        return doParseXmlDecl(
            Some(
                findEncoding
                    as unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                        _: *const libc::c_char,
                    )
                        -> *const crate::src::lib::xmltok::ENCODING,
            ),
            isGeneralTextEntity,
            enc,
            ptr,
            end,
            badPtr,
            versionPtr,
            versionEndPtr,
            encodingName,
            encoding,
            standalone,
        );
    }

    use crate::src::lib::xmltok::{
        doParseXmlDecl, getEncodingIndex, initScan, initUpdatePosition, internal_little2_encoding,
        internal_little2_encoding_ns, internal_utf8_encoding, internal_utf8_encoding_ns, streqci,
        ENCODING, INIT_ENCODING, KW_UTF_16, POSITION, UNKNOWN_ENC, XML_CONTENT_STATE,
        XML_PROLOG_STATE,
    };
    /* XML_TOK_NS_C */
    /* XML_TOK_NS_C */
}

pub use crate::ascii_h::{
    ASCII_b, ASCII_d, ASCII_f, ASCII_i, ASCII_n, ASCII_o, ASCII_q, ASCII_r, ASCII_s, ASCII_t,
    ASCII_v, ASCII_y, ASCII_z, ASCII_4, ASCII_5, ASCII_6, ASCII_7, ASCII_A, ASCII_AMP, ASCII_APOS,
    ASCII_C, ASCII_COLON, ASCII_D, ASCII_EQUALS, ASCII_GT, ASCII_I, ASCII_LSQB, ASCII_LT,
    ASCII_MINUS, ASCII_O, ASCII_PERIOD, ASCII_QUOT, ASCII_S, ASCII_SPACE, ASCII_T, ASCII_U,
    ASCII_UNDERSCORE, ASCII_Z,
};
pub use crate::ascii_h_0::{
    ASCII_a, ASCII_c, ASCII_e, ASCII_g, ASCII_l, ASCII_m, ASCII_x, ASCII_0, ASCII_1, ASCII_2,
    ASCII_3, ASCII_8, ASCII_9, ASCII_B, ASCII_E, ASCII_F, ASCII_L, ASCII_M, ASCII_X,
};
pub use crate::expat_external_h::XML_Size;
pub use crate::src::lib::xmltok::nametab_h::{namePages, namingBitmap, nmstrtPages};
pub use crate::src::lib::xmltok::xmltok_impl_c::{
    big2_attributeValueTok, big2_cdataSectionTok, big2_charRefNumber, big2_checkPiTarget,
    big2_contentTok, big2_entityValueTok, big2_getAtts, big2_ignoreSectionTok, big2_isPublicId,
    big2_nameLength, big2_nameMatchesAscii, big2_predefinedEntityName, big2_prologTok,
    big2_scanAtts, big2_scanCdataSection, big2_scanCharRef, big2_scanComment, big2_scanDecl,
    big2_scanEndTag, big2_scanHexCharRef, big2_scanLit, big2_scanLt, big2_scanPercent, big2_scanPi,
    big2_scanPoundName, big2_scanRef, big2_skipS, big2_updatePosition, little2_attributeValueTok,
    little2_cdataSectionTok, little2_charRefNumber, little2_checkPiTarget, little2_contentTok,
    little2_entityValueTok, little2_getAtts, little2_ignoreSectionTok, little2_isPublicId,
    little2_nameLength, little2_nameMatchesAscii, little2_predefinedEntityName, little2_prologTok,
    little2_scanAtts, little2_scanCdataSection, little2_scanCharRef, little2_scanComment,
    little2_scanDecl, little2_scanEndTag, little2_scanHexCharRef, little2_scanLit, little2_scanLt,
    little2_scanPercent, little2_scanPi, little2_scanPoundName, little2_scanRef, little2_skipS,
    little2_updatePosition, normal_attributeValueTok, normal_cdataSectionTok, normal_charRefNumber,
    normal_checkPiTarget, normal_contentTok, normal_entityValueTok, normal_getAtts,
    normal_ignoreSectionTok, normal_isPublicId, normal_nameLength, normal_nameMatchesAscii,
    normal_predefinedEntityName, normal_prologTok, normal_scanAtts, normal_scanCdataSection,
    normal_scanCharRef, normal_scanComment, normal_scanDecl, normal_scanEndTag,
    normal_scanHexCharRef, normal_scanLit, normal_scanLt, normal_scanPercent, normal_scanPi,
    normal_scanPoundName, normal_scanRef, normal_skipS, normal_updatePosition,
};
pub use crate::src::lib::xmltok::xmltok_ns_c::{
    encodings, encodingsNS, findEncoding, findEncodingNS, initScanContent, initScanContentNS,
    initScanProlog, initScanPrologNS, XmlGetUtf16InternalEncoding, XmlGetUtf16InternalEncodingNS,
    XmlGetUtf8InternalEncoding, XmlGetUtf8InternalEncodingNS, XmlInitEncoding, XmlInitEncodingNS,
    XmlParseXmlDecl, XmlParseXmlDeclNS,
};
pub use crate::stdbool_h::{false_0, true_0};
pub use crate::stddef_h::{ptrdiff_t, size_t, NULL};

pub use crate::xmltok_impl_c::{
    inName, inName_0, inName_1, inValue, inValue_0, inValue_1, other, other_0, other_1,
};
pub use crate::xmltok_impl_h::{
    C2RustUnnamed_2, BT_AMP, BT_APOS, BT_AST, BT_COLON_0, BT_COMMA, BT_CR, BT_DIGIT, BT_EQUALS,
    BT_EXCL, BT_GT, BT_HEX, BT_LEAD2, BT_LEAD3, BT_LEAD4, BT_LF, BT_LPAR, BT_LSQB, BT_LT,
    BT_MALFORM, BT_MINUS, BT_NAME, BT_NMSTRT, BT_NONASCII, BT_NONXML, BT_NUM, BT_OTHER, BT_PERCNT,
    BT_PLUS, BT_QUEST, BT_QUOT, BT_RPAR, BT_RSQB, BT_S, BT_SEMI, BT_SOL, BT_TRAIL, BT_VERBAR,
};

#[repr(C)]
#[derive(Copy, Clone)]
pub struct normal_encoding {
    pub enc: crate::src::lib::xmltok::ENCODING,
    pub type_0: [libc::c_uchar; 256],
    pub isName2: Option<
        unsafe extern "C" fn(
            _: *const crate::src::lib::xmltok::ENCODING,
            _: *const libc::c_char,
        ) -> libc::c_int,
    >,
    pub isName3: Option<
        unsafe extern "C" fn(
            _: *const crate::src::lib::xmltok::ENCODING,
            _: *const libc::c_char,
        ) -> libc::c_int,
    >,
    pub isName4: Option<
        unsafe extern "C" fn(
            _: *const crate::src::lib::xmltok::ENCODING,
            _: *const libc::c_char,
        ) -> libc::c_int,
    >,
    pub isNmstrt2: Option<
        unsafe extern "C" fn(
            _: *const crate::src::lib::xmltok::ENCODING,
            _: *const libc::c_char,
        ) -> libc::c_int,
    >,
    pub isNmstrt3: Option<
        unsafe extern "C" fn(
            _: *const crate::src::lib::xmltok::ENCODING,
            _: *const libc::c_char,
        ) -> libc::c_int,
    >,
    pub isNmstrt4: Option<
        unsafe extern "C" fn(
            _: *const crate::src::lib::xmltok::ENCODING,
            _: *const libc::c_char,
        ) -> libc::c_int,
    >,
    pub isInvalid2: Option<
        unsafe extern "C" fn(
            _: *const crate::src::lib::xmltok::ENCODING,
            _: *const libc::c_char,
        ) -> libc::c_int,
    >,
    pub isInvalid3: Option<
        unsafe extern "C" fn(
            _: *const crate::src::lib::xmltok::ENCODING,
            _: *const libc::c_char,
        ) -> libc::c_int,
    >,
    pub isInvalid4: Option<
        unsafe extern "C" fn(
            _: *const crate::src::lib::xmltok::ENCODING,
            _: *const libc::c_char,
        ) -> libc::c_int,
    >,
}

pub const UTF8_cval2: C2RustUnnamed_7 = 192;

pub const UTF8_cval4: C2RustUnnamed_7 = 240;

pub const UTF8_cval3: C2RustUnnamed_7 = 224;

pub const UNKNOWN_ENC: C2RustUnnamed_8 = -1;
/* must match encodingNames up to here */

pub const NO_ENC: C2RustUnnamed_8 = 6;

pub const UTF_16LE_ENC: C2RustUnnamed_8 = 5;

pub const UTF_16BE_ENC: C2RustUnnamed_8 = 4;

pub const UTF_8_ENC: C2RustUnnamed_8 = 2;

pub const UTF_16_ENC: C2RustUnnamed_8 = 3;

pub const ISO_8859_1_ENC: C2RustUnnamed_8 = 0;

pub const min4: C2RustUnnamed_6 = 65536;

pub const min3: C2RustUnnamed_6 = 2048;
/* UTF8_cvalN is value of masked first byte of N byte sequence */

pub const UTF8_cval1: C2RustUnnamed_7 = 0;
/* minN is minimum legal resulting value for N byte sequence */

pub const min2: C2RustUnnamed_6 = 128;

pub type C2RustUnnamed_6 = libc::c_uint;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct unknown_encoding {
    pub normal: normal_encoding,
    pub convert: crate::src::lib::xmltok::CONVERTER,
    pub userData: *mut libc::c_void,
    pub utf16: [libc::c_ushort; 256],
    pub utf8: [[libc::c_char; 4]; 256],
}
/* minimum bytes per character */
/* c is an ASCII character */

pub type C2RustUnnamed_7 = libc::c_uint;
/* If this enumeration is changed, getEncodingIndex and encodings
must also be changed. */

pub type C2RustUnnamed_8 = libc::c_int;

pub const US_ASCII_ENC: C2RustUnnamed_8 = 1;
/*
                            __  __            _
                         ___\ \/ /_ __   __ _| |_
                        / _ \\  /| '_ \ / _` | __|
                       |  __//  \| |_) | (_| | |_
                        \___/_/\_\ .__/ \__,_|\__|
                                 |_| XML parser

   Copyright (c) 1997-2000 Thai Open Source Software Center Ltd
   Copyright (c) 2000-2017 Expat development team
   Licensed under the MIT license:

   Permission is  hereby granted,  free of charge,  to any  person obtaining
   a  copy  of  this  software   and  associated  documentation  files  (the
   "Software"),  to  deal in  the  Software  without restriction,  including
   without  limitation the  rights  to use,  copy,  modify, merge,  publish,
   distribute, sublicense, and/or sell copies of the Software, and to permit
   persons  to whom  the Software  is  furnished to  do so,  subject to  the
   following conditions:

   The above copyright  notice and this permission notice  shall be included
   in all copies or substantial portions of the Software.

   THE  SOFTWARE  IS  PROVIDED  "AS  IS",  WITHOUT  WARRANTY  OF  ANY  KIND,
   EXPRESS  OR IMPLIED,  INCLUDING  BUT  NOT LIMITED  TO  THE WARRANTIES  OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
   NO EVENT SHALL THE AUTHORS OR  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
   DAMAGES OR  OTHER LIABILITY, WHETHER  IN AN  ACTION OF CONTRACT,  TORT OR
   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
   USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
/* memcpy */
/* ndef _WIN32 */
/* A 2 byte UTF-8 representation splits the characters 11 bits between
   the bottom 5 and 6 bits of the bytes.  We need 8 bits to index into
   pages, 3 bits to add to that index and 5 bits to generate the mask.
*/
/* A 3 byte UTF-8 representation splits the characters 16 bits between
   the bottom 4, 6 and 6 bits of the bytes.  We need 8 bits to index
   into pages, 3 bits to add to that index and 5 bits to generate the
   mask.
*/
/* Detection of invalid UTF-8 sequences is based on Table 3.1B
   of Unicode 3.2: http://www.unicode.org/unicode/reports/tr28/
   with the additional restriction of not allowing the Unicode
   code points 0xFFFF and 0xFFFE (sequences EF,BF,BF and EF,BF,BE).
   Implementation details:
     (A & 0x80) == 0     means A < 0x80
   and
     (A & 0xC0) == 0xC0  means A > 0xBF
*/

unsafe extern "C" fn isNever(
    mut _enc: *const crate::src::lib::xmltok::ENCODING,
    mut _p: *const libc::c_char,
) -> libc::c_int {
    return 0 as libc::c_int;
}

unsafe extern "C" fn utf8_isName2(
    mut _enc: *const crate::src::lib::xmltok::ENCODING,
    mut p: *const libc::c_char,
) -> libc::c_int {
    return (namingBitmap[(((namePages[(*(p as *const libc::c_uchar)
        .offset(0 as libc::c_int as isize) as libc::c_int
        >> 2 as libc::c_int
        & 7 as libc::c_int) as usize] as libc::c_int)
        << 3 as libc::c_int)
        + ((*(p as *const libc::c_uchar).offset(0 as libc::c_int as isize) as libc::c_int
            & 3 as libc::c_int)
            << 1 as libc::c_int)
        + (*(p as *const libc::c_uchar).offset(1 as libc::c_int as isize) as libc::c_int
            >> 5 as libc::c_int
            & 1 as libc::c_int)) as usize]
        & (1 as libc::c_uint)
            << (*(p as *const libc::c_uchar).offset(1 as libc::c_int as isize) as libc::c_int
                & 0x1f as libc::c_int)) as libc::c_int;
}

unsafe extern "C" fn utf8_isName3(
    mut _enc: *const crate::src::lib::xmltok::ENCODING,
    mut p: *const libc::c_char,
) -> libc::c_int {
    return (namingBitmap[(((namePages[(((*(p as *const libc::c_uchar)
        .offset(0 as libc::c_int as isize)
        as libc::c_int
        & 0xf as libc::c_int)
        << 4 as libc::c_int)
        + (*(p as *const libc::c_uchar).offset(1 as libc::c_int as isize) as libc::c_int
            >> 2 as libc::c_int
            & 0xf as libc::c_int)) as usize] as libc::c_int)
        << 3 as libc::c_int)
        + ((*(p as *const libc::c_uchar).offset(1 as libc::c_int as isize) as libc::c_int
            & 3 as libc::c_int)
            << 1 as libc::c_int)
        + (*(p as *const libc::c_uchar).offset(2 as libc::c_int as isize) as libc::c_int
            >> 5 as libc::c_int
            & 1 as libc::c_int)) as usize]
        & (1 as libc::c_uint)
            << (*(p as *const libc::c_uchar).offset(2 as libc::c_int as isize) as libc::c_int
                & 0x1f as libc::c_int)) as libc::c_int;
}

pub const utf8_isName4: unsafe extern "C" fn(
    _: *const crate::src::lib::xmltok::ENCODING,
    _: *const libc::c_char,
) -> libc::c_int = isNever;

unsafe extern "C" fn utf8_isNmstrt2(
    mut _enc: *const crate::src::lib::xmltok::ENCODING,
    mut p: *const libc::c_char,
) -> libc::c_int {
    return (namingBitmap[(((nmstrtPages[(*(p as *const libc::c_uchar)
        .offset(0 as libc::c_int as isize) as libc::c_int
        >> 2 as libc::c_int
        & 7 as libc::c_int) as usize] as libc::c_int)
        << 3 as libc::c_int)
        + ((*(p as *const libc::c_uchar).offset(0 as libc::c_int as isize) as libc::c_int
            & 3 as libc::c_int)
            << 1 as libc::c_int)
        + (*(p as *const libc::c_uchar).offset(1 as libc::c_int as isize) as libc::c_int
            >> 5 as libc::c_int
            & 1 as libc::c_int)) as usize]
        & (1 as libc::c_uint)
            << (*(p as *const libc::c_uchar).offset(1 as libc::c_int as isize) as libc::c_int
                & 0x1f as libc::c_int)) as libc::c_int;
}

unsafe extern "C" fn utf8_isNmstrt3(
    mut _enc: *const crate::src::lib::xmltok::ENCODING,
    mut p: *const libc::c_char,
) -> libc::c_int {
    return (namingBitmap[(((nmstrtPages[(((*(p as *const libc::c_uchar)
        .offset(0 as libc::c_int as isize)
        as libc::c_int
        & 0xf as libc::c_int)
        << 4 as libc::c_int)
        + (*(p as *const libc::c_uchar).offset(1 as libc::c_int as isize) as libc::c_int
            >> 2 as libc::c_int
            & 0xf as libc::c_int)) as usize] as libc::c_int)
        << 3 as libc::c_int)
        + ((*(p as *const libc::c_uchar).offset(1 as libc::c_int as isize) as libc::c_int
            & 3 as libc::c_int)
            << 1 as libc::c_int)
        + (*(p as *const libc::c_uchar).offset(2 as libc::c_int as isize) as libc::c_int
            >> 5 as libc::c_int
            & 1 as libc::c_int)) as usize]
        & (1 as libc::c_uint)
            << (*(p as *const libc::c_uchar).offset(2 as libc::c_int as isize) as libc::c_int
                & 0x1f as libc::c_int)) as libc::c_int;
}

pub const utf8_isNmstrt4: unsafe extern "C" fn(
    _: *const crate::src::lib::xmltok::ENCODING,
    _: *const libc::c_char,
) -> libc::c_int = isNever;

unsafe extern "C" fn utf8_isInvalid2(
    mut _enc: *const crate::src::lib::xmltok::ENCODING,
    mut p: *const libc::c_char,
) -> libc::c_int {
    return ((*(p as *const libc::c_uchar) as libc::c_int) < 0xc2 as libc::c_int
        || *(p as *const libc::c_uchar).offset(1 as libc::c_int as isize) as libc::c_int
            & 0x80 as libc::c_int
            == 0 as libc::c_int
        || *(p as *const libc::c_uchar).offset(1 as libc::c_int as isize) as libc::c_int
            & 0xc0 as libc::c_int
            == 0xc0 as libc::c_int) as libc::c_int;
}

unsafe extern "C" fn utf8_isInvalid3(
    mut _enc: *const crate::src::lib::xmltok::ENCODING,
    mut p: *const libc::c_char,
) -> libc::c_int {
    return (*(p as *const libc::c_uchar).offset(2 as libc::c_int as isize) as libc::c_int
        & 0x80 as libc::c_int
        == 0 as libc::c_int
        || (if *(p as *const libc::c_uchar) as libc::c_int == 0xef as libc::c_int
            && *(p as *const libc::c_uchar).offset(1 as libc::c_int as isize) as libc::c_int
                == 0xbf as libc::c_int
        {
            (*(p as *const libc::c_uchar).offset(2 as libc::c_int as isize) as libc::c_int
                > 0xbd as libc::c_int) as libc::c_int
        } else {
            (*(p as *const libc::c_uchar).offset(2 as libc::c_int as isize) as libc::c_int
                & 0xc0 as libc::c_int
                == 0xc0 as libc::c_int) as libc::c_int
        }) != 0
        || (if *(p as *const libc::c_uchar) as libc::c_int == 0xe0 as libc::c_int {
            ((*(p as *const libc::c_uchar).offset(1 as libc::c_int as isize) as libc::c_int)
                < 0xa0 as libc::c_int
                || *(p as *const libc::c_uchar).offset(1 as libc::c_int as isize) as libc::c_int
                    & 0xc0 as libc::c_int
                    == 0xc0 as libc::c_int) as libc::c_int
        } else {
            (*(p as *const libc::c_uchar).offset(1 as libc::c_int as isize) as libc::c_int
                & 0x80 as libc::c_int
                == 0 as libc::c_int
                || (if *(p as *const libc::c_uchar) as libc::c_int == 0xed as libc::c_int {
                    (*(p as *const libc::c_uchar).offset(1 as libc::c_int as isize) as libc::c_int
                        > 0x9f as libc::c_int) as libc::c_int
                } else {
                    (*(p as *const libc::c_uchar).offset(1 as libc::c_int as isize) as libc::c_int
                        & 0xc0 as libc::c_int
                        == 0xc0 as libc::c_int) as libc::c_int
                }) != 0) as libc::c_int
        }) != 0) as libc::c_int;
}

unsafe extern "C" fn utf8_isInvalid4(
    mut _enc: *const crate::src::lib::xmltok::ENCODING,
    mut p: *const libc::c_char,
) -> libc::c_int {
    return (*(p as *const libc::c_uchar).offset(3 as libc::c_int as isize) as libc::c_int
        & 0x80 as libc::c_int
        == 0 as libc::c_int
        || *(p as *const libc::c_uchar).offset(3 as libc::c_int as isize) as libc::c_int
            & 0xc0 as libc::c_int
            == 0xc0 as libc::c_int
        || *(p as *const libc::c_uchar).offset(2 as libc::c_int as isize) as libc::c_int
            & 0x80 as libc::c_int
            == 0 as libc::c_int
        || *(p as *const libc::c_uchar).offset(2 as libc::c_int as isize) as libc::c_int
            & 0xc0 as libc::c_int
            == 0xc0 as libc::c_int
        || (if *(p as *const libc::c_uchar) as libc::c_int == 0xf0 as libc::c_int {
            ((*(p as *const libc::c_uchar).offset(1 as libc::c_int as isize) as libc::c_int)
                < 0x90 as libc::c_int
                || *(p as *const libc::c_uchar).offset(1 as libc::c_int as isize) as libc::c_int
                    & 0xc0 as libc::c_int
                    == 0xc0 as libc::c_int) as libc::c_int
        } else {
            (*(p as *const libc::c_uchar).offset(1 as libc::c_int as isize) as libc::c_int
                & 0x80 as libc::c_int
                == 0 as libc::c_int
                || (if *(p as *const libc::c_uchar) as libc::c_int == 0xf4 as libc::c_int {
                    (*(p as *const libc::c_uchar).offset(1 as libc::c_int as isize) as libc::c_int
                        > 0x8f as libc::c_int) as libc::c_int
                } else {
                    (*(p as *const libc::c_uchar).offset(1 as libc::c_int as isize) as libc::c_int
                        & 0xc0 as libc::c_int
                        == 0xc0 as libc::c_int) as libc::c_int
                }) != 0) as libc::c_int
        }) != 0) as libc::c_int;
}
/* internal.h

   Internal definitions used by Expat.  This is not needed to compile
   client code.

   The following calling convention macros are defined for frequently
   called functions:

   FASTCALL    - Used for those internal functions that have a simple
                 body and a low number of arguments and local variables.

   PTRCALL     - Used for functions called though function pointers.

   PTRFASTCALL - Like PTRCALL, but for low number of arguments.

   inline      - Used for selected internal functions for which inlining
                 may improve performance on some platforms.

   Note: Use of these macros is based on judgement, not hard rules,
         and therefore subject to change.
                            __  __            _
                         ___\ \/ /_ __   __ _| |_
                        / _ \\  /| '_ \ / _` | __|
                       |  __//  \| |_) | (_| | |_
                        \___/_/\_\ .__/ \__,_|\__|
                                 |_| XML parser

   Copyright (c) 1997-2000 Thai Open Source Software Center Ltd
   Copyright (c) 2000-2017 Expat development team
   Licensed under the MIT license:

   Permission is  hereby granted,  free of charge,  to any  person obtaining
   a  copy  of  this  software   and  associated  documentation  files  (the
   "Software"),  to  deal in  the  Software  without restriction,  including
   without  limitation the  rights  to use,  copy,  modify, merge,  publish,
   distribute, sublicense, and/or sell copies of the Software, and to permit
   persons  to whom  the Software  is  furnished to  do so,  subject to  the
   following conditions:

   The above copyright  notice and this permission notice  shall be included
   in all copies or substantial portions of the Software.

   THE  SOFTWARE  IS  PROVIDED  "AS  IS",  WITHOUT  WARRANTY  OF  ANY  KIND,
   EXPRESS  OR IMPLIED,  INCLUDING  BUT  NOT LIMITED  TO  THE WARRANTIES  OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
   NO EVENT SHALL THE AUTHORS OR  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
   DAMAGES OR  OTHER LIABILITY, WHETHER  IN AN  ACTION OF CONTRACT,  TORT OR
   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
   USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
/* Using __fastcall seems to have an unexpected negative effect under
   MS VC++, especially for function pointers, so we won't use it for
   now on that platform. It may be reconsidered for a future release
   if it can be made more effective.
   Likely reason: __fastcall on Windows is like stdcall, therefore
   the compiler cannot perform stack optimizations for call clusters.
*/
/* Make sure all of these are defined if they aren't already. */
/* __GNUC__ */
/* XML_MIN_SIZE */
#[no_mangle]

pub unsafe extern "C" fn _INTERNAL_trim_to_complete_utf8_characters(
    mut from: *const libc::c_char,
    mut fromLimRef: *mut *const libc::c_char,
) {
    let mut fromLim: *const libc::c_char = *fromLimRef;
    let mut walked: crate::stddef_h::size_t = 0 as libc::c_int as crate::stddef_h::size_t;
    while fromLim > from {
        let prev: libc::c_uchar = *fromLim.offset(-(1 as libc::c_int) as isize) as libc::c_uchar;
        if prev as libc::c_uint & 0xf8 as libc::c_uint == 0xf0 as libc::c_uint {
            /* 4-byte character, lead by 0b11110xxx byte */
            if walked.wrapping_add(1 as libc::c_int as libc::c_ulong)
                >= 4 as libc::c_int as libc::c_ulong
            {
                fromLim = fromLim.offset((4 as libc::c_int - 1 as libc::c_int) as isize);
                break;
            } else {
                walked = 0 as libc::c_int as crate::stddef_h::size_t
            }
        } else if prev as libc::c_uint & 0xf0 as libc::c_uint == 0xe0 as libc::c_uint {
            /* 3-byte character, lead by 0b1110xxxx byte */
            if walked.wrapping_add(1 as libc::c_int as libc::c_ulong)
                >= 3 as libc::c_int as libc::c_ulong
            {
                fromLim = fromLim.offset((3 as libc::c_int - 1 as libc::c_int) as isize);
                break;
            } else {
                walked = 0 as libc::c_int as crate::stddef_h::size_t
            }
        } else if prev as libc::c_uint & 0xe0 as libc::c_uint == 0xc0 as libc::c_uint {
            /* 2-byte character, lead by 0b110xxxxx byte */
            if walked.wrapping_add(1 as libc::c_int as libc::c_ulong)
                >= 2 as libc::c_int as libc::c_ulong
            {
                fromLim = fromLim.offset((2 as libc::c_int - 1 as libc::c_int) as isize);
                break;
            } else {
                walked = 0 as libc::c_int as crate::stddef_h::size_t
            }
        } else if prev as libc::c_uint & 0x80 as libc::c_uint == 0 as libc::c_uint {
            break;
        }
        fromLim = fromLim.offset(-1);
        walked = walked.wrapping_add(1)
    }
    *fromLimRef = fromLim;
}

unsafe extern "C" fn utf8_toUtf8(
    mut _enc: *const crate::src::lib::xmltok::ENCODING,
    mut fromP: *mut *const libc::c_char,
    mut fromLim: *const libc::c_char,
    mut toP: *mut *mut libc::c_char,
    mut toLim: *const libc::c_char,
) -> crate::src::lib::xmltok::XML_Convert_Result {
    let mut input_incomplete: bool = crate::stdbool_h::false_0 != 0;
    let mut output_exhausted: bool = crate::stdbool_h::false_0 != 0;
    /* Avoid copying partial characters (due to limited space). */
    let bytesAvailable: crate::stddef_h::ptrdiff_t =
        fromLim.wrapping_offset_from(*fromP) as libc::c_long;
    let bytesStorable: crate::stddef_h::ptrdiff_t =
        toLim.wrapping_offset_from(*toP) as libc::c_long;
    if bytesAvailable > bytesStorable {
        fromLim = (*fromP).offset(bytesStorable as isize);
        output_exhausted = crate::stdbool_h::true_0 != 0
    }
    /* Avoid copying partial characters (from incomplete input). */
    let fromLimBefore: *const libc::c_char = fromLim;
    _INTERNAL_trim_to_complete_utf8_characters(*fromP, &mut fromLim);
    if fromLim < fromLimBefore {
        input_incomplete = crate::stdbool_h::true_0 != 0
    }
    let bytesToCopy: crate::stddef_h::ptrdiff_t =
        fromLim.wrapping_offset_from(*fromP) as libc::c_long;
    crate::stdlib::memcpy(
        *toP as *mut libc::c_void,
        *fromP as *const libc::c_void,
        bytesToCopy as libc::c_ulong,
    );
    *fromP = (*fromP).offset(bytesToCopy as isize);
    *toP = (*toP).offset(bytesToCopy as isize);
    if output_exhausted {
        /* needs to go first */
        return crate::src::lib::xmltok::XML_CONVERT_OUTPUT_EXHAUSTED;
    } else if input_incomplete {
        return crate::src::lib::xmltok::XML_CONVERT_INPUT_INCOMPLETE;
    } else {
        return crate::src::lib::xmltok::XML_CONVERT_COMPLETED;
    };
}

unsafe extern "C" fn utf8_toUtf16(
    mut enc: *const crate::src::lib::xmltok::ENCODING,
    mut fromP: *mut *const libc::c_char,
    mut fromLim: *const libc::c_char,
    mut toP: *mut *mut libc::c_ushort,
    mut toLim: *const libc::c_ushort,
) -> crate::src::lib::xmltok::XML_Convert_Result {
    let mut current_block: u64;
    let mut res: crate::src::lib::xmltok::XML_Convert_Result =
        crate::src::lib::xmltok::XML_CONVERT_COMPLETED;
    let mut to: *mut libc::c_ushort = *toP;
    let mut from: *const libc::c_char = *fromP;
    loop {
        if !(from < fromLim && to < toLim as *mut libc::c_ushort) {
            current_block = 1608152415753874203;
            break;
        }
        match (*(enc as *mut normal_encoding)).type_0[*from as libc::c_uchar as usize]
            as libc::c_int
        {
            5 => {
                if (fromLim.wrapping_offset_from(from) as libc::c_long)
                    < 2 as libc::c_int as libc::c_long
                {
                    res = crate::src::lib::xmltok::XML_CONVERT_INPUT_INCOMPLETE;
                    current_block = 10086016483950629671;
                    break;
                } else {
                    let fresh24 = to;
                    to = to.offset(1);
                    *fresh24 = ((*from.offset(0 as libc::c_int as isize) as libc::c_int
                        & 0x1f as libc::c_int)
                        << 6 as libc::c_int
                        | *from.offset(1 as libc::c_int as isize) as libc::c_int
                            & 0x3f as libc::c_int) as libc::c_ushort;
                    from = from.offset(2 as libc::c_int as isize)
                }
            }
            6 => {
                if (fromLim.wrapping_offset_from(from) as libc::c_long)
                    < 3 as libc::c_int as libc::c_long
                {
                    res = crate::src::lib::xmltok::XML_CONVERT_INPUT_INCOMPLETE;
                    current_block = 10086016483950629671;
                    break;
                } else {
                    let fresh25 = to;
                    to = to.offset(1);
                    *fresh25 = ((*from.offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xf as libc::c_int)
                        << 12 as libc::c_int
                        | (*from.offset(1 as libc::c_int as isize) as libc::c_int
                            & 0x3f as libc::c_int)
                            << 6 as libc::c_int
                        | *from.offset(2 as libc::c_int as isize) as libc::c_int
                            & 0x3f as libc::c_int) as libc::c_ushort;
                    from = from.offset(3 as libc::c_int as isize)
                }
            }
            7 => {
                let mut n: libc::c_ulong = 0;
                if (toLim.wrapping_offset_from(to) as libc::c_long)
                    < 2 as libc::c_int as libc::c_long
                {
                    res = crate::src::lib::xmltok::XML_CONVERT_OUTPUT_EXHAUSTED;
                    current_block = 10086016483950629671;
                    break;
                } else if (fromLim.wrapping_offset_from(from) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    res = crate::src::lib::xmltok::XML_CONVERT_INPUT_INCOMPLETE;
                    current_block = 10086016483950629671;
                    break;
                } else {
                    n = ((*from.offset(0 as libc::c_int as isize) as libc::c_int
                        & 0x7 as libc::c_int)
                        << 18 as libc::c_int
                        | (*from.offset(1 as libc::c_int as isize) as libc::c_int
                            & 0x3f as libc::c_int)
                            << 12 as libc::c_int
                        | (*from.offset(2 as libc::c_int as isize) as libc::c_int
                            & 0x3f as libc::c_int)
                            << 6 as libc::c_int
                        | *from.offset(3 as libc::c_int as isize) as libc::c_int
                            & 0x3f as libc::c_int) as libc::c_ulong;
                    n = n.wrapping_sub(0x10000 as libc::c_int as libc::c_ulong);
                    *to.offset(0 as libc::c_int as isize) = (n >> 10 as libc::c_int
                        | 0xd800 as libc::c_int as libc::c_ulong)
                        as libc::c_ushort;
                    *to.offset(1 as libc::c_int as isize) = (n & 0x3ff as libc::c_int
                        as libc::c_ulong
                        | 0xdc00 as libc::c_int as libc::c_ulong)
                        as libc::c_ushort;
                    to = to.offset(2 as libc::c_int as isize);
                    from = from.offset(4 as libc::c_int as isize)
                }
            }
            _ => {
                let fresh26 = from;
                from = from.offset(1);
                let fresh27 = to;
                to = to.offset(1);
                *fresh27 = *fresh26 as libc::c_ushort
            }
        }
    }
    match current_block {
        1608152415753874203 => {
            if from < fromLim {
                res = crate::src::lib::xmltok::XML_CONVERT_OUTPUT_EXHAUSTED
            }
        }
        _ => {}
    }
    *fromP = from;
    *toP = to;
    return res;
}

static mut utf8_encoding_ns: normal_encoding = {
    let mut init = normal_encoding {
        enc: {
            let mut init = crate::src::lib::xmltok::encoding {
                scanners: [
                    Some(
                        normal_prologTok
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    Some(
                        normal_contentTok
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    Some(
                        normal_cdataSectionTok
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    Some(
                        normal_ignoreSectionTok
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                ],
                literalScanners: [
                    Some(
                        normal_attributeValueTok
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    Some(
                        normal_entityValueTok
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                ],
                nameMatchesAscii: Some(
                    normal_nameMatchesAscii
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                            _: *const libc::c_char,
                            _: *const libc::c_char,
                        ) -> libc::c_int,
                ),
                nameLength: Some(
                    normal_nameLength
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                        ) -> libc::c_int,
                ),
                skipS: Some(
                    normal_skipS
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                        ) -> *const libc::c_char,
                ),
                getAtts: Some(
                    normal_getAtts
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                            _: libc::c_int,
                            _: *mut crate::src::lib::xmltok::ATTRIBUTE,
                        ) -> libc::c_int,
                ),
                charRefNumber: Some(
                    normal_charRefNumber
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                        ) -> libc::c_int,
                ),
                predefinedEntityName: Some(
                    normal_predefinedEntityName
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                            _: *const libc::c_char,
                        ) -> libc::c_int,
                ),
                updatePosition: Some(
                    normal_updatePosition
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                            _: *const libc::c_char,
                            _: *mut crate::src::lib::xmltok::POSITION,
                        ) -> (),
                ),
                isPublicId: Some(
                    normal_isPublicId
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                            _: *const libc::c_char,
                            _: *mut *const libc::c_char,
                        ) -> libc::c_int,
                ),
                utf8Convert: Some(
                    utf8_toUtf8
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *mut *const libc::c_char,
                            _: *const libc::c_char,
                            _: *mut *mut libc::c_char,
                            _: *const libc::c_char,
                        )
                            -> crate::src::lib::xmltok::XML_Convert_Result,
                ),
                utf16Convert: Some(
                    utf8_toUtf16
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *mut *const libc::c_char,
                            _: *const libc::c_char,
                            _: *mut *mut libc::c_ushort,
                            _: *const libc::c_ushort,
                        )
                            -> crate::src::lib::xmltok::XML_Convert_Result,
                ),
                minBytesPerChar: 1 as libc::c_int,
                isUtf8: 1 as libc::c_int as libc::c_char,
                isUtf16: 0 as libc::c_int as libc::c_char,
            };
            init
        },
        type_0: [
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LF as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_CR as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_EXCL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_QUOT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NUM as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_PERCNT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_AMP as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_APOS as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LPAR as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_RPAR as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_AST as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_PLUS as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_COMMA as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_MINUS as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NAME as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_SOL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_COLON_0 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_SEMI as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_EQUALS as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_GT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_QUEST as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LSQB as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_RSQB as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_VERBAR as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD4 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD4 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD4 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD4 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD4 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_MALFORM as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_MALFORM as libc::c_int as libc::c_uchar,
        ],
        isName2: Some(
            utf8_isName2
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        ),
        isName3: Some(
            utf8_isName3
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        ),
        isName4: Some(utf8_isName4),
        isNmstrt2: Some(
            utf8_isNmstrt2
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        ),
        isNmstrt3: Some(
            utf8_isNmstrt3
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        ),
        isNmstrt4: Some(utf8_isNmstrt4),
        isInvalid2: Some(
            utf8_isInvalid2
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        ),
        isInvalid3: Some(
            utf8_isInvalid3
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        ),
        isInvalid4: Some(
            utf8_isInvalid4
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        ),
    };
    init
};

static mut utf8_encoding: normal_encoding = {
    let mut init = normal_encoding {
        enc: {
            let mut init = crate::src::lib::xmltok::encoding {
                scanners: [
                    Some(
                        normal_prologTok
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    Some(
                        normal_contentTok
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    Some(
                        normal_cdataSectionTok
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    Some(
                        normal_ignoreSectionTok
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                ],
                literalScanners: [
                    Some(
                        normal_attributeValueTok
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    Some(
                        normal_entityValueTok
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                ],
                nameMatchesAscii: Some(
                    normal_nameMatchesAscii
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                            _: *const libc::c_char,
                            _: *const libc::c_char,
                        ) -> libc::c_int,
                ),
                nameLength: Some(
                    normal_nameLength
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                        ) -> libc::c_int,
                ),
                skipS: Some(
                    normal_skipS
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                        ) -> *const libc::c_char,
                ),
                getAtts: Some(
                    normal_getAtts
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                            _: libc::c_int,
                            _: *mut crate::src::lib::xmltok::ATTRIBUTE,
                        ) -> libc::c_int,
                ),
                charRefNumber: Some(
                    normal_charRefNumber
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                        ) -> libc::c_int,
                ),
                predefinedEntityName: Some(
                    normal_predefinedEntityName
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                            _: *const libc::c_char,
                        ) -> libc::c_int,
                ),
                updatePosition: Some(
                    normal_updatePosition
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                            _: *const libc::c_char,
                            _: *mut crate::src::lib::xmltok::POSITION,
                        ) -> (),
                ),
                isPublicId: Some(
                    normal_isPublicId
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                            _: *const libc::c_char,
                            _: *mut *const libc::c_char,
                        ) -> libc::c_int,
                ),
                utf8Convert: Some(
                    utf8_toUtf8
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *mut *const libc::c_char,
                            _: *const libc::c_char,
                            _: *mut *mut libc::c_char,
                            _: *const libc::c_char,
                        )
                            -> crate::src::lib::xmltok::XML_Convert_Result,
                ),
                utf16Convert: Some(
                    utf8_toUtf16
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *mut *const libc::c_char,
                            _: *const libc::c_char,
                            _: *mut *mut libc::c_ushort,
                            _: *const libc::c_ushort,
                        )
                            -> crate::src::lib::xmltok::XML_Convert_Result,
                ),
                minBytesPerChar: 1 as libc::c_int,
                isUtf8: 1 as libc::c_int as libc::c_char,
                isUtf16: 0 as libc::c_int as libc::c_char,
            };
            init
        },
        type_0: [
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LF as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_CR as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_EXCL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_QUOT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NUM as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_PERCNT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_AMP as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_APOS as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LPAR as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_RPAR as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_AST as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_PLUS as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_COMMA as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_MINUS as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NAME as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_SOL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            BT_COLON as libc::c_uchar,
            crate::xmltok_impl_h::BT_SEMI as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_EQUALS as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_GT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_QUEST as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LSQB as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_RSQB as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_VERBAR as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD4 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD4 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD4 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD4 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD4 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_MALFORM as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_MALFORM as libc::c_int as libc::c_uchar,
        ],
        isName2: Some(
            utf8_isName2
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        ),
        isName3: Some(
            utf8_isName3
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        ),
        isName4: Some(utf8_isName4),
        isNmstrt2: Some(
            utf8_isNmstrt2
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        ),
        isNmstrt3: Some(
            utf8_isNmstrt3
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        ),
        isNmstrt4: Some(utf8_isNmstrt4),
        isInvalid2: Some(
            utf8_isInvalid2
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        ),
        isInvalid3: Some(
            utf8_isInvalid3
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        ),
        isInvalid4: Some(
            utf8_isInvalid4
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        ),
    };
    init
};

pub const BT_COLON: libc::c_int = crate::xmltok_impl_h::BT_NMSTRT as libc::c_int;

static mut internal_utf8_encoding_ns: normal_encoding = {
    let mut init = normal_encoding {
        enc: {
            let mut init = crate::src::lib::xmltok::encoding {
                scanners: [
                    Some(
                        normal_prologTok
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    Some(
                        normal_contentTok
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    Some(
                        normal_cdataSectionTok
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    Some(
                        normal_ignoreSectionTok
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                ],
                literalScanners: [
                    Some(
                        normal_attributeValueTok
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    Some(
                        normal_entityValueTok
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                ],
                nameMatchesAscii: Some(
                    normal_nameMatchesAscii
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                            _: *const libc::c_char,
                            _: *const libc::c_char,
                        ) -> libc::c_int,
                ),
                nameLength: Some(
                    normal_nameLength
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                        ) -> libc::c_int,
                ),
                skipS: Some(
                    normal_skipS
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                        ) -> *const libc::c_char,
                ),
                getAtts: Some(
                    normal_getAtts
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                            _: libc::c_int,
                            _: *mut crate::src::lib::xmltok::ATTRIBUTE,
                        ) -> libc::c_int,
                ),
                charRefNumber: Some(
                    normal_charRefNumber
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                        ) -> libc::c_int,
                ),
                predefinedEntityName: Some(
                    normal_predefinedEntityName
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                            _: *const libc::c_char,
                        ) -> libc::c_int,
                ),
                updatePosition: Some(
                    normal_updatePosition
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                            _: *const libc::c_char,
                            _: *mut crate::src::lib::xmltok::POSITION,
                        ) -> (),
                ),
                isPublicId: Some(
                    normal_isPublicId
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                            _: *const libc::c_char,
                            _: *mut *const libc::c_char,
                        ) -> libc::c_int,
                ),
                utf8Convert: Some(
                    utf8_toUtf8
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *mut *const libc::c_char,
                            _: *const libc::c_char,
                            _: *mut *mut libc::c_char,
                            _: *const libc::c_char,
                        )
                            -> crate::src::lib::xmltok::XML_Convert_Result,
                ),
                utf16Convert: Some(
                    utf8_toUtf16
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *mut *const libc::c_char,
                            _: *const libc::c_char,
                            _: *mut *mut libc::c_ushort,
                            _: *const libc::c_ushort,
                        )
                            -> crate::src::lib::xmltok::XML_Convert_Result,
                ),
                minBytesPerChar: 1 as libc::c_int,
                isUtf8: 1 as libc::c_int as libc::c_char,
                isUtf16: 0 as libc::c_int as libc::c_char,
            };
            init
        },
        type_0: [
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LF as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_EXCL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_QUOT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NUM as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_PERCNT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_AMP as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_APOS as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LPAR as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_RPAR as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_AST as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_PLUS as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_COMMA as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_MINUS as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NAME as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_SOL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_COLON_0 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_SEMI as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_EQUALS as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_GT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_QUEST as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LSQB as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_RSQB as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_VERBAR as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD4 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD4 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD4 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD4 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD4 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_MALFORM as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_MALFORM as libc::c_int as libc::c_uchar,
        ],
        isName2: Some(
            utf8_isName2
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        ),
        isName3: Some(
            utf8_isName3
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        ),
        isName4: Some(utf8_isName4),
        isNmstrt2: Some(
            utf8_isNmstrt2
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        ),
        isNmstrt3: Some(
            utf8_isNmstrt3
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        ),
        isNmstrt4: Some(utf8_isNmstrt4),
        isInvalid2: Some(
            utf8_isInvalid2
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        ),
        isInvalid3: Some(
            utf8_isInvalid3
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        ),
        isInvalid4: Some(
            utf8_isInvalid4
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        ),
    };
    init
};

static mut internal_utf8_encoding: normal_encoding = {
    let mut init = normal_encoding {
        enc: {
            let mut init = crate::src::lib::xmltok::encoding {
                scanners: [
                    Some(
                        normal_prologTok
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    Some(
                        normal_contentTok
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    Some(
                        normal_cdataSectionTok
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    Some(
                        normal_ignoreSectionTok
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                ],
                literalScanners: [
                    Some(
                        normal_attributeValueTok
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    Some(
                        normal_entityValueTok
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                ],
                nameMatchesAscii: Some(
                    normal_nameMatchesAscii
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                            _: *const libc::c_char,
                            _: *const libc::c_char,
                        ) -> libc::c_int,
                ),
                nameLength: Some(
                    normal_nameLength
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                        ) -> libc::c_int,
                ),
                skipS: Some(
                    normal_skipS
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                        ) -> *const libc::c_char,
                ),
                getAtts: Some(
                    normal_getAtts
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                            _: libc::c_int,
                            _: *mut crate::src::lib::xmltok::ATTRIBUTE,
                        ) -> libc::c_int,
                ),
                charRefNumber: Some(
                    normal_charRefNumber
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                        ) -> libc::c_int,
                ),
                predefinedEntityName: Some(
                    normal_predefinedEntityName
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                            _: *const libc::c_char,
                        ) -> libc::c_int,
                ),
                updatePosition: Some(
                    normal_updatePosition
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                            _: *const libc::c_char,
                            _: *mut crate::src::lib::xmltok::POSITION,
                        ) -> (),
                ),
                isPublicId: Some(
                    normal_isPublicId
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *const libc::c_char,
                            _: *const libc::c_char,
                            _: *mut *const libc::c_char,
                        ) -> libc::c_int,
                ),
                utf8Convert: Some(
                    utf8_toUtf8
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *mut *const libc::c_char,
                            _: *const libc::c_char,
                            _: *mut *mut libc::c_char,
                            _: *const libc::c_char,
                        )
                            -> crate::src::lib::xmltok::XML_Convert_Result,
                ),
                utf16Convert: Some(
                    utf8_toUtf16
                        as unsafe extern "C" fn(
                            _: *const crate::src::lib::xmltok::ENCODING,
                            _: *mut *const libc::c_char,
                            _: *const libc::c_char,
                            _: *mut *mut libc::c_ushort,
                            _: *const libc::c_ushort,
                        )
                            -> crate::src::lib::xmltok::XML_Convert_Result,
                ),
                minBytesPerChar: 1 as libc::c_int,
                isUtf8: 1 as libc::c_int as libc::c_char,
                isUtf16: 0 as libc::c_int as libc::c_char,
            };
            init
        },
        type_0: [
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LF as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_EXCL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_QUOT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NUM as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_PERCNT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_AMP as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_APOS as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LPAR as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_RPAR as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_AST as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_PLUS as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_COMMA as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_MINUS as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NAME as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_SOL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
            BT_COLON_5 as libc::c_uchar,
            crate::xmltok_impl_h::BT_SEMI as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_EQUALS as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_GT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_QUEST as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LSQB as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_RSQB as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_VERBAR as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_TRAIL as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD2 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD3 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD4 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD4 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD4 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD4 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_LEAD4 as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_MALFORM as libc::c_int as libc::c_uchar,
            crate::xmltok_impl_h::BT_MALFORM as libc::c_int as libc::c_uchar,
        ],
        isName2: Some(
            utf8_isName2
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        ),
        isName3: Some(
            utf8_isName3
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        ),
        isName4: Some(utf8_isName4),
        isNmstrt2: Some(
            utf8_isNmstrt2
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        ),
        isNmstrt3: Some(
            utf8_isNmstrt3
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        ),
        isNmstrt4: Some(utf8_isNmstrt4),
        isInvalid2: Some(
            utf8_isInvalid2
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        ),
        isInvalid3: Some(
            utf8_isInvalid3
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        ),
        isInvalid4: Some(
            utf8_isInvalid4
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        ),
    };
    init
};

pub const BT_COLON_5: libc::c_int = crate::xmltok_impl_h::BT_NMSTRT as libc::c_int;

unsafe extern "C" fn latin1_toUtf8(
    mut _enc: *const crate::src::lib::xmltok::ENCODING,
    mut fromP: *mut *const libc::c_char,
    mut fromLim: *const libc::c_char,
    mut toP: *mut *mut libc::c_char,
    mut toLim: *const libc::c_char,
) -> crate::src::lib::xmltok::XML_Convert_Result {
    loop {
        let mut c: libc::c_uchar = 0;
        if *fromP == fromLim {
            return crate::src::lib::xmltok::XML_CONVERT_COMPLETED;
        }
        c = **fromP as libc::c_uchar;
        if c as libc::c_int & 0x80 as libc::c_int != 0 {
            if (toLim.wrapping_offset_from(*toP) as libc::c_long) < 2 as libc::c_int as libc::c_long
            {
                return crate::src::lib::xmltok::XML_CONVERT_OUTPUT_EXHAUSTED;
            }
            let fresh28 = *toP;
            *toP = (*toP).offset(1);
            *fresh28 =
                (c as libc::c_int >> 6 as libc::c_int | UTF8_cval2 as libc::c_int) as libc::c_char;
            let fresh29 = *toP;
            *toP = (*toP).offset(1);
            *fresh29 =
                (c as libc::c_int & 0x3f as libc::c_int | 0x80 as libc::c_int) as libc::c_char;
            *fromP = (*fromP).offset(1)
        } else {
            if *toP == toLim as *mut libc::c_char {
                return crate::src::lib::xmltok::XML_CONVERT_OUTPUT_EXHAUSTED;
            }
            let fresh30 = *fromP;
            *fromP = (*fromP).offset(1);
            let fresh31 = *toP;
            *toP = (*toP).offset(1);
            *fresh31 = *fresh30
        }
    }
}

unsafe extern "C" fn latin1_toUtf16(
    mut _enc: *const crate::src::lib::xmltok::ENCODING,
    mut fromP: *mut *const libc::c_char,
    mut fromLim: *const libc::c_char,
    mut toP: *mut *mut libc::c_ushort,
    mut toLim: *const libc::c_ushort,
) -> crate::src::lib::xmltok::XML_Convert_Result {
    while *fromP < fromLim && *toP < toLim as *mut libc::c_ushort {
        let fresh32 = *fromP;
        *fromP = (*fromP).offset(1);
        let fresh33 = *toP;
        *toP = (*toP).offset(1);
        *fresh33 = *fresh32 as libc::c_uchar as libc::c_ushort
    }
    if *toP == toLim as *mut libc::c_ushort && *fromP < fromLim {
        return crate::src::lib::xmltok::XML_CONVERT_OUTPUT_EXHAUSTED;
    } else {
        return crate::src::lib::xmltok::XML_CONVERT_COMPLETED;
    };
}

static mut latin1_encoding_ns: normal_encoding = unsafe {
    {
        let mut init = normal_encoding {
            enc: {
                let mut init = crate::src::lib::xmltok::encoding {
                    scanners: [
                        Some(
                            normal_prologTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            normal_contentTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            normal_cdataSectionTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            normal_ignoreSectionTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                    ],
                    literalScanners: [
                        Some(
                            normal_attributeValueTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            normal_entityValueTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                    ],
                    nameMatchesAscii: Some(
                        normal_nameMatchesAscii
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    nameLength: Some(
                        normal_nameLength
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    skipS: Some(
                        normal_skipS
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                            )
                                -> *const libc::c_char,
                    ),
                    getAtts: Some(
                        normal_getAtts
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: libc::c_int,
                                _: *mut crate::src::lib::xmltok::ATTRIBUTE,
                            ) -> libc::c_int,
                    ),
                    charRefNumber: Some(
                        normal_charRefNumber
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    predefinedEntityName: Some(
                        normal_predefinedEntityName
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    updatePosition: Some(
                        normal_updatePosition
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut crate::src::lib::xmltok::POSITION,
                            ) -> (),
                    ),
                    isPublicId: Some(
                        normal_isPublicId
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    utf8Convert: Some(
                        latin1_toUtf8
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *mut *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *mut libc::c_char,
                                _: *const libc::c_char,
                            )
                                -> crate::src::lib::xmltok::XML_Convert_Result,
                    ),
                    utf16Convert: Some(
                        latin1_toUtf16
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *mut *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *mut libc::c_ushort,
                                _: *const libc::c_ushort,
                            )
                                -> crate::src::lib::xmltok::XML_Convert_Result,
                    ),
                    minBytesPerChar: 1 as libc::c_int,
                    isUtf8: 0 as libc::c_int as libc::c_char,
                    isUtf16: 0 as libc::c_int as libc::c_char,
                };
                init
            },
            type_0: [
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LF as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_CR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_EXCL as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_QUOT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NUM as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_PERCNT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_AMP as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_APOS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LPAR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_RPAR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_AST as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_PLUS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_COMMA as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_MINUS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NAME as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_SOL as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_COLON_0 as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_SEMI as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_EQUALS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_GT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_QUEST as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LSQB as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_RSQB as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_VERBAR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NAME as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            ],
            isName2: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isName3: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isName4: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isNmstrt2: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isNmstrt3: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isNmstrt4: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isInvalid2: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isInvalid3: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isInvalid4: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
        };
        init
    }
};

static mut latin1_encoding: normal_encoding = unsafe {
    {
        let mut init = normal_encoding {
            enc: {
                let mut init = crate::src::lib::xmltok::encoding {
                    scanners: [
                        Some(
                            normal_prologTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            normal_contentTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            normal_cdataSectionTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            normal_ignoreSectionTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                    ],
                    literalScanners: [
                        Some(
                            normal_attributeValueTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            normal_entityValueTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                    ],
                    nameMatchesAscii: Some(
                        normal_nameMatchesAscii
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    nameLength: Some(
                        normal_nameLength
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    skipS: Some(
                        normal_skipS
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                            )
                                -> *const libc::c_char,
                    ),
                    getAtts: Some(
                        normal_getAtts
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: libc::c_int,
                                _: *mut crate::src::lib::xmltok::ATTRIBUTE,
                            ) -> libc::c_int,
                    ),
                    charRefNumber: Some(
                        normal_charRefNumber
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    predefinedEntityName: Some(
                        normal_predefinedEntityName
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    updatePosition: Some(
                        normal_updatePosition
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut crate::src::lib::xmltok::POSITION,
                            ) -> (),
                    ),
                    isPublicId: Some(
                        normal_isPublicId
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    utf8Convert: Some(
                        latin1_toUtf8
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *mut *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *mut libc::c_char,
                                _: *const libc::c_char,
                            )
                                -> crate::src::lib::xmltok::XML_Convert_Result,
                    ),
                    utf16Convert: Some(
                        latin1_toUtf16
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *mut *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *mut libc::c_ushort,
                                _: *const libc::c_ushort,
                            )
                                -> crate::src::lib::xmltok::XML_Convert_Result,
                    ),
                    minBytesPerChar: 1 as libc::c_int,
                    isUtf8: 0 as libc::c_int as libc::c_char,
                    isUtf16: 0 as libc::c_int as libc::c_char,
                };
                init
            },
            type_0: [
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LF as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_CR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_EXCL as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_QUOT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NUM as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_PERCNT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_AMP as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_APOS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LPAR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_RPAR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_AST as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_PLUS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_COMMA as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_MINUS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NAME as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_SOL as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                BT_COLON_1 as libc::c_uchar,
                crate::xmltok_impl_h::BT_SEMI as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_EQUALS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_GT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_QUEST as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LSQB as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_RSQB as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_VERBAR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NAME as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            ],
            isName2: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isName3: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isName4: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isNmstrt2: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isNmstrt3: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isNmstrt4: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isInvalid2: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isInvalid3: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isInvalid4: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
        };
        init
    }
};

pub const BT_COLON_1: libc::c_int = crate::xmltok_impl_h::BT_NMSTRT as libc::c_int;

unsafe extern "C" fn ascii_toUtf8(
    mut _enc: *const crate::src::lib::xmltok::ENCODING,
    mut fromP: *mut *const libc::c_char,
    mut fromLim: *const libc::c_char,
    mut toP: *mut *mut libc::c_char,
    mut toLim: *const libc::c_char,
) -> crate::src::lib::xmltok::XML_Convert_Result {
    while *fromP < fromLim && *toP < toLim as *mut libc::c_char {
        let fresh34 = *fromP;
        *fromP = (*fromP).offset(1);
        let fresh35 = *toP;
        *toP = (*toP).offset(1);
        *fresh35 = *fresh34
    }
    if *toP == toLim as *mut libc::c_char && *fromP < fromLim {
        return crate::src::lib::xmltok::XML_CONVERT_OUTPUT_EXHAUSTED;
    } else {
        return crate::src::lib::xmltok::XML_CONVERT_COMPLETED;
    };
}

static mut ascii_encoding_ns: normal_encoding = unsafe {
    {
        let mut init = normal_encoding {
            enc: {
                let mut init = crate::src::lib::xmltok::encoding {
                    scanners: [
                        Some(
                            normal_prologTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            normal_contentTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            normal_cdataSectionTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            normal_ignoreSectionTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                    ],
                    literalScanners: [
                        Some(
                            normal_attributeValueTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            normal_entityValueTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                    ],
                    nameMatchesAscii: Some(
                        normal_nameMatchesAscii
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    nameLength: Some(
                        normal_nameLength
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    skipS: Some(
                        normal_skipS
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                            )
                                -> *const libc::c_char,
                    ),
                    getAtts: Some(
                        normal_getAtts
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: libc::c_int,
                                _: *mut crate::src::lib::xmltok::ATTRIBUTE,
                            ) -> libc::c_int,
                    ),
                    charRefNumber: Some(
                        normal_charRefNumber
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    predefinedEntityName: Some(
                        normal_predefinedEntityName
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    updatePosition: Some(
                        normal_updatePosition
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut crate::src::lib::xmltok::POSITION,
                            ) -> (),
                    ),
                    isPublicId: Some(
                        normal_isPublicId
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    utf8Convert: Some(
                        ascii_toUtf8
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *mut *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *mut libc::c_char,
                                _: *const libc::c_char,
                            )
                                -> crate::src::lib::xmltok::XML_Convert_Result,
                    ),
                    utf16Convert: Some(
                        latin1_toUtf16
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *mut *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *mut libc::c_ushort,
                                _: *const libc::c_ushort,
                            )
                                -> crate::src::lib::xmltok::XML_Convert_Result,
                    ),
                    minBytesPerChar: 1 as libc::c_int,
                    isUtf8: 1 as libc::c_int as libc::c_char,
                    isUtf16: 0 as libc::c_int as libc::c_char,
                };
                init
            },
            type_0: [
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LF as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_CR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_EXCL as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_QUOT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NUM as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_PERCNT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_AMP as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_APOS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LPAR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_RPAR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_AST as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_PLUS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_COMMA as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_MINUS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NAME as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_SOL as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_COLON_0 as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_SEMI as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_EQUALS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_GT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_QUEST as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LSQB as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_RSQB as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_VERBAR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
            ],
            isName2: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isName3: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isName4: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isNmstrt2: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isNmstrt3: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isNmstrt4: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isInvalid2: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isInvalid3: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isInvalid4: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
        };
        init
    }
};

static mut ascii_encoding: normal_encoding = unsafe {
    {
        let mut init = normal_encoding {
            enc: {
                let mut init = crate::src::lib::xmltok::encoding {
                    scanners: [
                        Some(
                            normal_prologTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            normal_contentTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            normal_cdataSectionTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            normal_ignoreSectionTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                    ],
                    literalScanners: [
                        Some(
                            normal_attributeValueTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            normal_entityValueTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                    ],
                    nameMatchesAscii: Some(
                        normal_nameMatchesAscii
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    nameLength: Some(
                        normal_nameLength
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    skipS: Some(
                        normal_skipS
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                            )
                                -> *const libc::c_char,
                    ),
                    getAtts: Some(
                        normal_getAtts
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: libc::c_int,
                                _: *mut crate::src::lib::xmltok::ATTRIBUTE,
                            ) -> libc::c_int,
                    ),
                    charRefNumber: Some(
                        normal_charRefNumber
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    predefinedEntityName: Some(
                        normal_predefinedEntityName
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    updatePosition: Some(
                        normal_updatePosition
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut crate::src::lib::xmltok::POSITION,
                            ) -> (),
                    ),
                    isPublicId: Some(
                        normal_isPublicId
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    utf8Convert: Some(
                        ascii_toUtf8
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *mut *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *mut libc::c_char,
                                _: *const libc::c_char,
                            )
                                -> crate::src::lib::xmltok::XML_Convert_Result,
                    ),
                    utf16Convert: Some(
                        latin1_toUtf16
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *mut *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *mut libc::c_ushort,
                                _: *const libc::c_ushort,
                            )
                                -> crate::src::lib::xmltok::XML_Convert_Result,
                    ),
                    minBytesPerChar: 1 as libc::c_int,
                    isUtf8: 1 as libc::c_int as libc::c_char,
                    isUtf16: 0 as libc::c_int as libc::c_char,
                };
                init
            },
            type_0: [
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LF as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_CR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_EXCL as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_QUOT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NUM as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_PERCNT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_AMP as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_APOS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LPAR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_RPAR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_AST as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_PLUS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_COMMA as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_MINUS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NAME as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_SOL as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                BT_COLON_4 as libc::c_uchar,
                crate::xmltok_impl_h::BT_SEMI as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_EQUALS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_GT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_QUEST as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LSQB as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_RSQB as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_VERBAR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
            ],
            isName2: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isName3: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isName4: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isNmstrt2: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isNmstrt3: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isNmstrt4: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isInvalid2: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isInvalid3: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isInvalid4: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
        };
        init
    }
};

pub const BT_COLON_4: libc::c_int = crate::xmltok_impl_h::BT_NMSTRT as libc::c_int;

unsafe extern "C" fn unicode_byte_type(mut hi: libc::c_char, mut lo: libc::c_char) -> libc::c_int {
    match hi as libc::c_uchar as libc::c_int {
        216 | 217 | 218 | 219 => {
            /* 0xD8000xDBFF first 16-bit code unit or high surrogate (W1) */
            return crate::xmltok_impl_h::BT_LEAD4 as libc::c_int;
        }
        220 | 221 | 222 | 223 => {
            /* 0xDC000xDFFF second 16-bit code unit or low surrogate (W2) */
            return crate::xmltok_impl_h::BT_TRAIL as libc::c_int;
        }
        255 => {
            match lo as libc::c_uchar as libc::c_int {
                255 | 254 => {
                    /* noncharacter-FFFF */
                    /* noncharacter-FFFE */
                    return crate::xmltok_impl_h::BT_NONXML as libc::c_int;
                }
                _ => {}
            }
        }
        _ => {}
    }
    return crate::xmltok_impl_h::BT_NONASCII as libc::c_int;
}
/* shrink to even */
/* fall through */
/* 16 bits divided 4, 6, 6 amongst 3 bytes */
/* shrink to even */
/* Avoid copying first half only of surrogate */

unsafe extern "C" fn little2_toUtf8(
    mut _enc: *const crate::src::lib::xmltok::ENCODING,
    mut fromP: *mut *const libc::c_char,
    mut fromLim: *const libc::c_char,
    mut toP: *mut *mut libc::c_char,
    mut toLim: *const libc::c_char,
) -> crate::src::lib::xmltok::XML_Convert_Result {
    let mut from: *const libc::c_char = *fromP;
    fromLim = from.offset(
        ((fromLim.wrapping_offset_from(from) as libc::c_long >> 1 as libc::c_int)
            << 1 as libc::c_int) as isize,
    );
    while from < fromLim {
        let mut plane: libc::c_int = 0;
        let mut lo2: libc::c_uchar = 0;
        let mut lo: libc::c_uchar = *from.offset(0 as libc::c_int as isize) as libc::c_uchar;
        let mut hi: libc::c_uchar = *from.offset(1 as libc::c_int as isize) as libc::c_uchar;
        let mut current_block_34: u64;
        match hi as libc::c_int {
            0 => {
                if (lo as libc::c_int) < 0x80 as libc::c_int {
                    if *toP == toLim as *mut libc::c_char {
                        *fromP = from;
                        return crate::src::lib::xmltok::XML_CONVERT_OUTPUT_EXHAUSTED;
                    }
                    let fresh36 = *toP;
                    *toP = (*toP).offset(1);
                    *fresh36 = lo as libc::c_char;
                    current_block_34 = 18435049525520518667;
                } else {
                    current_block_34 = 11412679543673842523;
                }
            }
            1 | 2 | 3 | 4 | 5 | 6 | 7 => {
                current_block_34 = 11412679543673842523;
            }
            216 | 217 | 218 | 219 => {
                if (toLim.wrapping_offset_from(*toP) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    *fromP = from;
                    return crate::src::lib::xmltok::XML_CONVERT_OUTPUT_EXHAUSTED;
                }
                if (fromLim.wrapping_offset_from(from) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    *fromP = from;
                    return crate::src::lib::xmltok::XML_CONVERT_INPUT_INCOMPLETE;
                }
                plane = ((hi as libc::c_int & 0x3 as libc::c_int) << 2 as libc::c_int
                    | lo as libc::c_int >> 6 as libc::c_int & 0x3 as libc::c_int)
                    + 1 as libc::c_int;
                let fresh42 = *toP;
                *toP = (*toP).offset(1);
                *fresh42 = (plane >> 2 as libc::c_int | UTF8_cval4 as libc::c_int) as libc::c_char;
                let fresh43 = *toP;
                *toP = (*toP).offset(1);
                *fresh43 = (lo as libc::c_int >> 2 as libc::c_int & 0xf as libc::c_int
                    | (plane & 0x3 as libc::c_int) << 4 as libc::c_int
                    | 0x80 as libc::c_int) as libc::c_char;
                from = from.offset(2 as libc::c_int as isize);
                lo2 = *from.offset(0 as libc::c_int as isize) as libc::c_uchar;
                let fresh44 = *toP;
                *toP = (*toP).offset(1);
                *fresh44 = ((lo as libc::c_int & 0x3 as libc::c_int) << 4 as libc::c_int
                    | (*from.offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                        & 0x3 as libc::c_int)
                        << 2 as libc::c_int
                    | lo2 as libc::c_int >> 6 as libc::c_int
                    | 0x80 as libc::c_int) as libc::c_char;
                let fresh45 = *toP;
                *toP = (*toP).offset(1);
                *fresh45 = (lo2 as libc::c_int & 0x3f as libc::c_int | 0x80 as libc::c_int)
                    as libc::c_char;
                current_block_34 = 18435049525520518667;
            }
            _ => {
                if (toLim.wrapping_offset_from(*toP) as libc::c_long)
                    < 3 as libc::c_int as libc::c_long
                {
                    *fromP = from;
                    return crate::src::lib::xmltok::XML_CONVERT_OUTPUT_EXHAUSTED;
                }
                let fresh39 = *toP;
                *toP = (*toP).offset(1);
                *fresh39 = (hi as libc::c_int >> 4 as libc::c_int | UTF8_cval3 as libc::c_int)
                    as libc::c_char;
                let fresh40 = *toP;
                *toP = (*toP).offset(1);
                *fresh40 = ((hi as libc::c_int & 0xf as libc::c_int) << 2 as libc::c_int
                    | lo as libc::c_int >> 6 as libc::c_int
                    | 0x80 as libc::c_int) as libc::c_char;
                let fresh41 = *toP;
                *toP = (*toP).offset(1);
                *fresh41 =
                    (lo as libc::c_int & 0x3f as libc::c_int | 0x80 as libc::c_int) as libc::c_char;
                current_block_34 = 18435049525520518667;
            }
        }
        match current_block_34 {
            11412679543673842523 => {
                if (toLim.wrapping_offset_from(*toP) as libc::c_long)
                    < 2 as libc::c_int as libc::c_long
                {
                    *fromP = from;
                    return crate::src::lib::xmltok::XML_CONVERT_OUTPUT_EXHAUSTED;
                }
                let fresh37 = *toP;
                *toP = (*toP).offset(1);
                *fresh37 = (lo as libc::c_int >> 6 as libc::c_int
                    | (hi as libc::c_int) << 2 as libc::c_int
                    | UTF8_cval2 as libc::c_int) as libc::c_char;
                let fresh38 = *toP;
                *toP = (*toP).offset(1);
                *fresh38 =
                    (lo as libc::c_int & 0x3f as libc::c_int | 0x80 as libc::c_int) as libc::c_char
            }
            _ => {}
        }
        from = from.offset(2 as libc::c_int as isize)
    }
    *fromP = from;
    if from < fromLim {
        return crate::src::lib::xmltok::XML_CONVERT_INPUT_INCOMPLETE;
    } else {
        return crate::src::lib::xmltok::XML_CONVERT_COMPLETED;
    };
}

unsafe extern "C" fn little2_toUtf16(
    mut _enc: *const crate::src::lib::xmltok::ENCODING,
    mut fromP: *mut *const libc::c_char,
    mut fromLim: *const libc::c_char,
    mut toP: *mut *mut libc::c_ushort,
    mut toLim: *const libc::c_ushort,
) -> crate::src::lib::xmltok::XML_Convert_Result {
    let mut res: crate::src::lib::xmltok::XML_Convert_Result =
        crate::src::lib::xmltok::XML_CONVERT_COMPLETED;
    fromLim = (*fromP).offset(
        ((fromLim.wrapping_offset_from(*fromP) as libc::c_long >> 1 as libc::c_int)
            << 1 as libc::c_int) as isize,
    );
    if fromLim.wrapping_offset_from(*fromP) as libc::c_long
        > (toLim.wrapping_offset_from(*toP) as libc::c_long) << 1 as libc::c_int
        && *fromLim
            .offset(-(2 as libc::c_int as isize))
            .offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int
            & 0xf8 as libc::c_int
            == 0xd8 as libc::c_int
    {
        fromLim = fromLim.offset(-(2 as libc::c_int as isize));
        res = crate::src::lib::xmltok::XML_CONVERT_INPUT_INCOMPLETE
    }
    while *fromP < fromLim && *toP < toLim as *mut libc::c_ushort {
        let fresh46 = *toP;
        *toP = (*toP).offset(1);
        *fresh46 = ((*(*fromP).offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int)
            << 8 as libc::c_int
            | *(*fromP).offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int)
            as libc::c_ushort;
        *fromP = (*fromP).offset(2 as libc::c_int as isize)
    }
    if *toP == toLim as *mut libc::c_ushort && *fromP < fromLim {
        return crate::src::lib::xmltok::XML_CONVERT_OUTPUT_EXHAUSTED;
    } else {
        return res;
    };
}

unsafe extern "C" fn big2_toUtf8(
    mut _enc: *const crate::src::lib::xmltok::ENCODING,
    mut fromP: *mut *const libc::c_char,
    mut fromLim: *const libc::c_char,
    mut toP: *mut *mut libc::c_char,
    mut toLim: *const libc::c_char,
) -> crate::src::lib::xmltok::XML_Convert_Result {
    let mut from: *const libc::c_char = *fromP;
    fromLim = from.offset(
        ((fromLim.wrapping_offset_from(from) as libc::c_long >> 1 as libc::c_int)
            << 1 as libc::c_int) as isize,
    );
    while from < fromLim {
        let mut plane: libc::c_int = 0;
        let mut lo2: libc::c_uchar = 0;
        let mut lo: libc::c_uchar = *from.offset(1 as libc::c_int as isize) as libc::c_uchar;
        let mut hi: libc::c_uchar = *from.offset(0 as libc::c_int as isize) as libc::c_uchar;
        let mut current_block_34: u64;
        match hi as libc::c_int {
            0 => {
                if (lo as libc::c_int) < 0x80 as libc::c_int {
                    if *toP == toLim as *mut libc::c_char {
                        *fromP = from;
                        return crate::src::lib::xmltok::XML_CONVERT_OUTPUT_EXHAUSTED;
                    }
                    let fresh47 = *toP;
                    *toP = (*toP).offset(1);
                    *fresh47 = lo as libc::c_char;
                    current_block_34 = 18435049525520518667;
                } else {
                    current_block_34 = 6790550795307076813;
                }
            }
            1 | 2 | 3 | 4 | 5 | 6 | 7 => {
                current_block_34 = 6790550795307076813;
            }
            216 | 217 | 218 | 219 => {
                if (toLim.wrapping_offset_from(*toP) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    *fromP = from;
                    return crate::src::lib::xmltok::XML_CONVERT_OUTPUT_EXHAUSTED;
                }
                if (fromLim.wrapping_offset_from(from) as libc::c_long)
                    < 4 as libc::c_int as libc::c_long
                {
                    *fromP = from;
                    return crate::src::lib::xmltok::XML_CONVERT_INPUT_INCOMPLETE;
                }
                plane = ((hi as libc::c_int & 0x3 as libc::c_int) << 2 as libc::c_int
                    | lo as libc::c_int >> 6 as libc::c_int & 0x3 as libc::c_int)
                    + 1 as libc::c_int;
                let fresh53 = *toP;
                *toP = (*toP).offset(1);
                *fresh53 = (plane >> 2 as libc::c_int | UTF8_cval4 as libc::c_int) as libc::c_char;
                let fresh54 = *toP;
                *toP = (*toP).offset(1);
                *fresh54 = (lo as libc::c_int >> 2 as libc::c_int & 0xf as libc::c_int
                    | (plane & 0x3 as libc::c_int) << 4 as libc::c_int
                    | 0x80 as libc::c_int) as libc::c_char;
                from = from.offset(2 as libc::c_int as isize);
                lo2 = *from.offset(1 as libc::c_int as isize) as libc::c_uchar;
                let fresh55 = *toP;
                *toP = (*toP).offset(1);
                *fresh55 = ((lo as libc::c_int & 0x3 as libc::c_int) << 4 as libc::c_int
                    | (*from.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                        & 0x3 as libc::c_int)
                        << 2 as libc::c_int
                    | lo2 as libc::c_int >> 6 as libc::c_int
                    | 0x80 as libc::c_int) as libc::c_char;
                let fresh56 = *toP;
                *toP = (*toP).offset(1);
                *fresh56 = (lo2 as libc::c_int & 0x3f as libc::c_int | 0x80 as libc::c_int)
                    as libc::c_char;
                current_block_34 = 18435049525520518667;
            }
            _ => {
                if (toLim.wrapping_offset_from(*toP) as libc::c_long)
                    < 3 as libc::c_int as libc::c_long
                {
                    *fromP = from;
                    return crate::src::lib::xmltok::XML_CONVERT_OUTPUT_EXHAUSTED;
                }
                let fresh50 = *toP;
                *toP = (*toP).offset(1);
                *fresh50 = (hi as libc::c_int >> 4 as libc::c_int | UTF8_cval3 as libc::c_int)
                    as libc::c_char;
                let fresh51 = *toP;
                *toP = (*toP).offset(1);
                *fresh51 = ((hi as libc::c_int & 0xf as libc::c_int) << 2 as libc::c_int
                    | lo as libc::c_int >> 6 as libc::c_int
                    | 0x80 as libc::c_int) as libc::c_char;
                let fresh52 = *toP;
                *toP = (*toP).offset(1);
                *fresh52 =
                    (lo as libc::c_int & 0x3f as libc::c_int | 0x80 as libc::c_int) as libc::c_char;
                current_block_34 = 18435049525520518667;
            }
        }
        match current_block_34 {
            6790550795307076813 => {
                if (toLim.wrapping_offset_from(*toP) as libc::c_long)
                    < 2 as libc::c_int as libc::c_long
                {
                    *fromP = from;
                    return crate::src::lib::xmltok::XML_CONVERT_OUTPUT_EXHAUSTED;
                }
                let fresh48 = *toP;
                *toP = (*toP).offset(1);
                *fresh48 = (lo as libc::c_int >> 6 as libc::c_int
                    | (hi as libc::c_int) << 2 as libc::c_int
                    | UTF8_cval2 as libc::c_int) as libc::c_char;
                let fresh49 = *toP;
                *toP = (*toP).offset(1);
                *fresh49 =
                    (lo as libc::c_int & 0x3f as libc::c_int | 0x80 as libc::c_int) as libc::c_char
            }
            _ => {}
        }
        from = from.offset(2 as libc::c_int as isize)
    }
    *fromP = from;
    if from < fromLim {
        return crate::src::lib::xmltok::XML_CONVERT_INPUT_INCOMPLETE;
    } else {
        return crate::src::lib::xmltok::XML_CONVERT_COMPLETED;
    };
}

unsafe extern "C" fn big2_toUtf16(
    mut _enc: *const crate::src::lib::xmltok::ENCODING,
    mut fromP: *mut *const libc::c_char,
    mut fromLim: *const libc::c_char,
    mut toP: *mut *mut libc::c_ushort,
    mut toLim: *const libc::c_ushort,
) -> crate::src::lib::xmltok::XML_Convert_Result {
    let mut res: crate::src::lib::xmltok::XML_Convert_Result =
        crate::src::lib::xmltok::XML_CONVERT_COMPLETED;
    fromLim = (*fromP).offset(
        ((fromLim.wrapping_offset_from(*fromP) as libc::c_long >> 1 as libc::c_int)
            << 1 as libc::c_int) as isize,
    );
    if fromLim.wrapping_offset_from(*fromP) as libc::c_long
        > (toLim.wrapping_offset_from(*toP) as libc::c_long) << 1 as libc::c_int
        && *fromLim
            .offset(-(2 as libc::c_int as isize))
            .offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
            & 0xf8 as libc::c_int
            == 0xd8 as libc::c_int
    {
        fromLim = fromLim.offset(-(2 as libc::c_int as isize));
        res = crate::src::lib::xmltok::XML_CONVERT_INPUT_INCOMPLETE
    }
    while *fromP < fromLim && *toP < toLim as *mut libc::c_ushort {
        let fresh57 = *toP;
        *toP = (*toP).offset(1);
        *fresh57 = ((*(*fromP).offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int)
            << 8 as libc::c_int
            | *(*fromP).offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int)
            as libc::c_ushort;
        *fromP = (*fromP).offset(2 as libc::c_int as isize)
    }
    if *toP == toLim as *mut libc::c_ushort && *fromP < fromLim {
        return crate::src::lib::xmltok::XML_CONVERT_OUTPUT_EXHAUSTED;
    } else {
        return res;
    };
}
/* not XML_MIN_SIZE */
/* CHAR_MATCHES is guaranteed to have MINBPC bytes available. */
/* not XML_MIN_SIZE */

static mut little2_encoding_ns: normal_encoding = unsafe {
    {
        let mut init = normal_encoding {
            enc: {
                let mut init = crate::src::lib::xmltok::encoding {
                    scanners: [
                        Some(
                            little2_prologTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            little2_contentTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            little2_cdataSectionTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            little2_ignoreSectionTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                    ],
                    literalScanners: [
                        Some(
                            little2_attributeValueTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            little2_entityValueTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                    ],
                    nameMatchesAscii: Some(
                        little2_nameMatchesAscii
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    nameLength: Some(
                        little2_nameLength
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    skipS: Some(
                        little2_skipS
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                            )
                                -> *const libc::c_char,
                    ),
                    getAtts: Some(
                        little2_getAtts
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: libc::c_int,
                                _: *mut crate::src::lib::xmltok::ATTRIBUTE,
                            ) -> libc::c_int,
                    ),
                    charRefNumber: Some(
                        little2_charRefNumber
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    predefinedEntityName: Some(
                        little2_predefinedEntityName
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    updatePosition: Some(
                        little2_updatePosition
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut crate::src::lib::xmltok::POSITION,
                            ) -> (),
                    ),
                    isPublicId: Some(
                        little2_isPublicId
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    utf8Convert: Some(
                        little2_toUtf8
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *mut *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *mut libc::c_char,
                                _: *const libc::c_char,
                            )
                                -> crate::src::lib::xmltok::XML_Convert_Result,
                    ),
                    utf16Convert: Some(
                        little2_toUtf16
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *mut *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *mut libc::c_ushort,
                                _: *const libc::c_ushort,
                            )
                                -> crate::src::lib::xmltok::XML_Convert_Result,
                    ),
                    minBytesPerChar: 2 as libc::c_int,
                    isUtf8: 0 as libc::c_int as libc::c_char,
                    isUtf16: 1 as libc::c_int as libc::c_char,
                };
                init
            },
            type_0: [
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LF as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_CR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_EXCL as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_QUOT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NUM as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_PERCNT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_AMP as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_APOS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LPAR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_RPAR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_AST as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_PLUS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_COMMA as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_MINUS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NAME as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_SOL as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_COLON_0 as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_SEMI as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_EQUALS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_GT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_QUEST as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LSQB as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_RSQB as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_VERBAR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NAME as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            ],
            isName2: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isName3: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isName4: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isNmstrt2: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isNmstrt3: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isNmstrt4: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isInvalid2: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isInvalid3: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isInvalid4: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
        };
        init
    }
};

static mut little2_encoding: normal_encoding = unsafe {
    {
        let mut init = normal_encoding {
            enc: {
                let mut init = crate::src::lib::xmltok::encoding {
                    scanners: [
                        Some(
                            little2_prologTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            little2_contentTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            little2_cdataSectionTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            little2_ignoreSectionTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                    ],
                    literalScanners: [
                        Some(
                            little2_attributeValueTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            little2_entityValueTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                    ],
                    nameMatchesAscii: Some(
                        little2_nameMatchesAscii
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    nameLength: Some(
                        little2_nameLength
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    skipS: Some(
                        little2_skipS
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                            )
                                -> *const libc::c_char,
                    ),
                    getAtts: Some(
                        little2_getAtts
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: libc::c_int,
                                _: *mut crate::src::lib::xmltok::ATTRIBUTE,
                            ) -> libc::c_int,
                    ),
                    charRefNumber: Some(
                        little2_charRefNumber
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    predefinedEntityName: Some(
                        little2_predefinedEntityName
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    updatePosition: Some(
                        little2_updatePosition
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut crate::src::lib::xmltok::POSITION,
                            ) -> (),
                    ),
                    isPublicId: Some(
                        little2_isPublicId
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    utf8Convert: Some(
                        little2_toUtf8
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *mut *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *mut libc::c_char,
                                _: *const libc::c_char,
                            )
                                -> crate::src::lib::xmltok::XML_Convert_Result,
                    ),
                    utf16Convert: Some(
                        little2_toUtf16
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *mut *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *mut libc::c_ushort,
                                _: *const libc::c_ushort,
                            )
                                -> crate::src::lib::xmltok::XML_Convert_Result,
                    ),
                    minBytesPerChar: 2 as libc::c_int,
                    isUtf8: 0 as libc::c_int as libc::c_char,
                    isUtf16: 1 as libc::c_int as libc::c_char,
                };
                init
            },
            type_0: [
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LF as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_CR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_EXCL as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_QUOT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NUM as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_PERCNT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_AMP as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_APOS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LPAR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_RPAR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_AST as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_PLUS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_COMMA as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_MINUS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NAME as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_SOL as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                BT_COLON_2 as libc::c_uchar,
                crate::xmltok_impl_h::BT_SEMI as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_EQUALS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_GT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_QUEST as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LSQB as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_RSQB as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_VERBAR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NAME as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            ],
            isName2: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isName3: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isName4: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isNmstrt2: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isNmstrt3: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isNmstrt4: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isInvalid2: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isInvalid3: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isInvalid4: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
        };
        init
    }
};

pub const BT_COLON_2: libc::c_int = crate::xmltok_impl_h::BT_NMSTRT as libc::c_int;

static mut internal_little2_encoding_ns: normal_encoding = unsafe {
    {
        let mut init = normal_encoding {
            enc: {
                let mut init = crate::src::lib::xmltok::encoding {
                    scanners: [
                        Some(
                            little2_prologTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            little2_contentTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            little2_cdataSectionTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            little2_ignoreSectionTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                    ],
                    literalScanners: [
                        Some(
                            little2_attributeValueTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            little2_entityValueTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                    ],
                    nameMatchesAscii: Some(
                        little2_nameMatchesAscii
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    nameLength: Some(
                        little2_nameLength
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    skipS: Some(
                        little2_skipS
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                            )
                                -> *const libc::c_char,
                    ),
                    getAtts: Some(
                        little2_getAtts
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: libc::c_int,
                                _: *mut crate::src::lib::xmltok::ATTRIBUTE,
                            ) -> libc::c_int,
                    ),
                    charRefNumber: Some(
                        little2_charRefNumber
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    predefinedEntityName: Some(
                        little2_predefinedEntityName
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    updatePosition: Some(
                        little2_updatePosition
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut crate::src::lib::xmltok::POSITION,
                            ) -> (),
                    ),
                    isPublicId: Some(
                        little2_isPublicId
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    utf8Convert: Some(
                        little2_toUtf8
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *mut *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *mut libc::c_char,
                                _: *const libc::c_char,
                            )
                                -> crate::src::lib::xmltok::XML_Convert_Result,
                    ),
                    utf16Convert: Some(
                        little2_toUtf16
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *mut *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *mut libc::c_ushort,
                                _: *const libc::c_ushort,
                            )
                                -> crate::src::lib::xmltok::XML_Convert_Result,
                    ),
                    minBytesPerChar: 2 as libc::c_int,
                    isUtf8: 0 as libc::c_int as libc::c_char,
                    isUtf16: 1 as libc::c_int as libc::c_char,
                };
                init
            },
            type_0: [
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LF as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_EXCL as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_QUOT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NUM as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_PERCNT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_AMP as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_APOS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LPAR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_RPAR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_AST as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_PLUS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_COMMA as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_MINUS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NAME as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_SOL as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_COLON_0 as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_SEMI as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_EQUALS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_GT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_QUEST as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LSQB as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_RSQB as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_VERBAR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NAME as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            ],
            isName2: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isName3: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isName4: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isNmstrt2: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isNmstrt3: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isNmstrt4: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isInvalid2: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isInvalid3: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isInvalid4: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
        };
        init
    }
};

static mut internal_little2_encoding: normal_encoding = unsafe {
    {
        let mut init = normal_encoding {
            enc: {
                let mut init = crate::src::lib::xmltok::encoding {
                    scanners: [
                        Some(
                            little2_prologTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            little2_contentTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            little2_cdataSectionTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            little2_ignoreSectionTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                    ],
                    literalScanners: [
                        Some(
                            little2_attributeValueTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            little2_entityValueTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                    ],
                    nameMatchesAscii: Some(
                        little2_nameMatchesAscii
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    nameLength: Some(
                        little2_nameLength
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    skipS: Some(
                        little2_skipS
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                            )
                                -> *const libc::c_char,
                    ),
                    getAtts: Some(
                        little2_getAtts
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: libc::c_int,
                                _: *mut crate::src::lib::xmltok::ATTRIBUTE,
                            ) -> libc::c_int,
                    ),
                    charRefNumber: Some(
                        little2_charRefNumber
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    predefinedEntityName: Some(
                        little2_predefinedEntityName
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    updatePosition: Some(
                        little2_updatePosition
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut crate::src::lib::xmltok::POSITION,
                            ) -> (),
                    ),
                    isPublicId: Some(
                        little2_isPublicId
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    utf8Convert: Some(
                        little2_toUtf8
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *mut *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *mut libc::c_char,
                                _: *const libc::c_char,
                            )
                                -> crate::src::lib::xmltok::XML_Convert_Result,
                    ),
                    utf16Convert: Some(
                        little2_toUtf16
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *mut *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *mut libc::c_ushort,
                                _: *const libc::c_ushort,
                            )
                                -> crate::src::lib::xmltok::XML_Convert_Result,
                    ),
                    minBytesPerChar: 2 as libc::c_int,
                    isUtf8: 0 as libc::c_int as libc::c_char,
                    isUtf16: 1 as libc::c_int as libc::c_char,
                };
                init
            },
            type_0: [
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LF as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_EXCL as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_QUOT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NUM as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_PERCNT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_AMP as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_APOS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LPAR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_RPAR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_AST as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_PLUS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_COMMA as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_MINUS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NAME as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_SOL as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                BT_COLON_6 as libc::c_uchar,
                crate::xmltok_impl_h::BT_SEMI as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_EQUALS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_GT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_QUEST as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LSQB as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_RSQB as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_VERBAR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NAME as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            ],
            isName2: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isName3: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isName4: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isNmstrt2: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isNmstrt3: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isNmstrt4: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isInvalid2: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isInvalid3: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isInvalid4: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
        };
        init
    }
};

pub const BT_COLON_6: libc::c_int = crate::xmltok_impl_h::BT_NMSTRT as libc::c_int;
/* not XML_MIN_SIZE */
/* CHAR_MATCHES is guaranteed to have MINBPC bytes available. */
/* not XML_MIN_SIZE */

static mut big2_encoding_ns: normal_encoding = unsafe {
    {
        let mut init = normal_encoding {
            enc: {
                let mut init = crate::src::lib::xmltok::encoding {
                    scanners: [
                        Some(
                            big2_prologTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            big2_contentTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            big2_cdataSectionTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            big2_ignoreSectionTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                    ],
                    literalScanners: [
                        Some(
                            big2_attributeValueTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            big2_entityValueTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                    ],
                    nameMatchesAscii: Some(
                        big2_nameMatchesAscii
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    nameLength: Some(
                        big2_nameLength
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    skipS: Some(
                        big2_skipS
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                            )
                                -> *const libc::c_char,
                    ),
                    getAtts: Some(
                        big2_getAtts
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: libc::c_int,
                                _: *mut crate::src::lib::xmltok::ATTRIBUTE,
                            ) -> libc::c_int,
                    ),
                    charRefNumber: Some(
                        big2_charRefNumber
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    predefinedEntityName: Some(
                        big2_predefinedEntityName
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    updatePosition: Some(
                        big2_updatePosition
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut crate::src::lib::xmltok::POSITION,
                            ) -> (),
                    ),
                    isPublicId: Some(
                        big2_isPublicId
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    utf8Convert: Some(
                        big2_toUtf8
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *mut *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *mut libc::c_char,
                                _: *const libc::c_char,
                            )
                                -> crate::src::lib::xmltok::XML_Convert_Result,
                    ),
                    utf16Convert: Some(
                        big2_toUtf16
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *mut *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *mut libc::c_ushort,
                                _: *const libc::c_ushort,
                            )
                                -> crate::src::lib::xmltok::XML_Convert_Result,
                    ),
                    minBytesPerChar: 2 as libc::c_int,
                    isUtf8: 0 as libc::c_int as libc::c_char,
                    isUtf16: 0 as libc::c_int as libc::c_char,
                }; /* LCOV_EXCL_LINE */
                init
            },
            type_0: [
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LF as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_CR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_EXCL as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_QUOT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NUM as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_PERCNT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_AMP as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_APOS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LPAR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_RPAR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_AST as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_PLUS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_COMMA as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_MINUS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NAME as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_SOL as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_COLON_0 as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_SEMI as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_EQUALS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_GT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_QUEST as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LSQB as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_RSQB as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_VERBAR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NAME as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            ],
            isName2: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isName3: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isName4: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isNmstrt2: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isNmstrt3: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isNmstrt4: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isInvalid2: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isInvalid3: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isInvalid4: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
        };
        init
    }
};

static mut big2_encoding: normal_encoding = unsafe {
    {
        let mut init = normal_encoding {
            enc: {
                let mut init = crate::src::lib::xmltok::encoding {
                    scanners: [
                        Some(
                            big2_prologTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            big2_contentTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            big2_cdataSectionTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            big2_ignoreSectionTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                    ],
                    literalScanners: [
                        Some(
                            big2_attributeValueTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        Some(
                            big2_entityValueTok
                                as unsafe extern "C" fn(
                                    _: *const crate::src::lib::xmltok::ENCODING,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *mut *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                    ],
                    nameMatchesAscii: Some(
                        big2_nameMatchesAscii
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    nameLength: Some(
                        big2_nameLength
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    skipS: Some(
                        big2_skipS
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                            )
                                -> *const libc::c_char,
                    ),
                    getAtts: Some(
                        big2_getAtts
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: libc::c_int,
                                _: *mut crate::src::lib::xmltok::ATTRIBUTE,
                            ) -> libc::c_int,
                    ),
                    charRefNumber: Some(
                        big2_charRefNumber
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    predefinedEntityName: Some(
                        big2_predefinedEntityName
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    updatePosition: Some(
                        big2_updatePosition
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut crate::src::lib::xmltok::POSITION,
                            ) -> (),
                    ),
                    isPublicId: Some(
                        big2_isPublicId
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    utf8Convert: Some(
                        big2_toUtf8
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *mut *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *mut libc::c_char,
                                _: *const libc::c_char,
                            )
                                -> crate::src::lib::xmltok::XML_Convert_Result,
                    ),
                    utf16Convert: Some(
                        big2_toUtf16
                            as unsafe extern "C" fn(
                                _: *const crate::src::lib::xmltok::ENCODING,
                                _: *mut *const libc::c_char,
                                _: *const libc::c_char,
                                _: *mut *mut libc::c_ushort,
                                _: *const libc::c_ushort,
                            )
                                -> crate::src::lib::xmltok::XML_Convert_Result,
                    ),
                    minBytesPerChar: 2 as libc::c_int,
                    isUtf8: 0 as libc::c_int as libc::c_char,
                    isUtf16: 0 as libc::c_int as libc::c_char,
                };
                init
            },
            type_0: [
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LF as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_CR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_S as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_EXCL as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_QUOT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NUM as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_PERCNT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_AMP as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_APOS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LPAR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_RPAR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_AST as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_PLUS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_COMMA as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_MINUS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NAME as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_SOL as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_DIGIT as libc::c_int as libc::c_uchar,
                BT_COLON_3 as libc::c_uchar,
                crate::xmltok_impl_h::BT_SEMI as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_EQUALS as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_GT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_QUEST as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_LSQB as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_RSQB as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_HEX as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_VERBAR as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NAME as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
                crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar,
            ],
            isName2: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isName3: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isName4: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isNmstrt2: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isNmstrt3: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isNmstrt4: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isInvalid2: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isInvalid3: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
            isInvalid4: ::std::mem::transmute::<
                libc::intptr_t,
                Option<
                    unsafe extern "C" fn(
                        _: *const crate::src::lib::xmltok::ENCODING,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
                >,
            >(crate::stddef_h::NULL as libc::intptr_t),
        };
        init
    }
};

pub const BT_COLON_3: libc::c_int = crate::xmltok_impl_h::BT_NMSTRT as libc::c_int;

unsafe extern "C" fn streqci(
    mut s1: *const libc::c_char,
    mut s2: *const libc::c_char,
) -> libc::c_int {
    loop {
        let fresh58 = s1;
        s1 = s1.offset(1);
        let mut c1: libc::c_char = *fresh58;
        let fresh59 = s2;
        s2 = s2.offset(1);
        let mut c2: libc::c_char = *fresh59;
        if crate::ascii_h_0::ASCII_a <= c1 as libc::c_int
            && c1 as libc::c_int <= crate::ascii_h::ASCII_z
        {
            c1 = (c1 as libc::c_int + (crate::ascii_h::ASCII_A - crate::ascii_h_0::ASCII_a))
                as libc::c_char
        }
        if crate::ascii_h_0::ASCII_a <= c2 as libc::c_int
            && c2 as libc::c_int <= crate::ascii_h::ASCII_z
        {
            /* The following line will never get executed.  streqci() is
             * only called from two places, both of which guarantee to put
             * upper-case strings into s2.
             */
            c2 = (c2 as libc::c_int + (crate::ascii_h::ASCII_A - crate::ascii_h_0::ASCII_a))
                as libc::c_char
        }
        if c1 as libc::c_int != c2 as libc::c_int {
            return 0 as libc::c_int;
        }
        if c1 == 0 {
            break;
        }
    }
    return 1 as libc::c_int;
}

unsafe extern "C" fn initUpdatePosition(
    mut _enc: *const crate::src::lib::xmltok::ENCODING,
    mut ptr: *const libc::c_char,
    mut end: *const libc::c_char,
    mut pos: *mut crate::src::lib::xmltok::POSITION,
) {
    normal_updatePosition(&utf8_encoding.enc, ptr, end, pos);
}

unsafe extern "C" fn toAscii(
    mut enc: *const crate::src::lib::xmltok::ENCODING,
    mut ptr: *const libc::c_char,
    mut end: *const libc::c_char,
) -> libc::c_int {
    let mut buf: [libc::c_char; 1] = [0; 1];
    let mut p: *mut libc::c_char = buf.as_mut_ptr();
    (*enc).utf8Convert.expect("non-null function pointer")(
        enc,
        &mut ptr,
        end,
        &mut p,
        p.offset(1 as libc::c_int as isize),
    );
    if p == buf.as_mut_ptr() {
        return -(1 as libc::c_int);
    } else {
        return buf[0 as libc::c_int as usize] as libc::c_int;
    };
}

unsafe extern "C" fn isSpace(mut c: libc::c_int) -> libc::c_int {
    match c {
        32 | 13 | 10 | 9 => return 1 as libc::c_int,
        _ => {}
    }
    return 0 as libc::c_int;
}
/* Return 1 if there's just optional white space or there's an S
   followed by name=val.
*/

unsafe extern "C" fn parsePseudoAttribute(
    mut enc: *const crate::src::lib::xmltok::ENCODING,
    mut ptr: *const libc::c_char,
    mut end: *const libc::c_char,
    mut namePtr: *mut *const libc::c_char,
    mut nameEndPtr: *mut *const libc::c_char,
    mut valPtr: *mut *const libc::c_char,
    mut nextTokPtr: *mut *const libc::c_char,
) -> libc::c_int {
    let mut c: libc::c_int = 0;
    let mut open: libc::c_char = 0;
    if ptr == end {
        *namePtr = crate::stddef_h::NULL as *const libc::c_char;
        return 1 as libc::c_int;
    }
    if isSpace(toAscii(enc, ptr, end)) == 0 {
        *nextTokPtr = ptr;
        return 0 as libc::c_int;
    }
    loop {
        ptr = ptr.offset((*enc).minBytesPerChar as isize);
        if !(isSpace(toAscii(enc, ptr, end)) != 0) {
            break;
        }
    }
    if ptr == end {
        *namePtr = crate::stddef_h::NULL as *const libc::c_char;
        return 1 as libc::c_int;
    }
    *namePtr = ptr;
    loop {
        c = toAscii(enc, ptr, end);
        if c == -(1 as libc::c_int) {
            *nextTokPtr = ptr;
            return 0 as libc::c_int;
        }
        if c == crate::ascii_h::ASCII_EQUALS {
            *nameEndPtr = ptr;
            break;
        } else if isSpace(c) != 0 {
            *nameEndPtr = ptr;
            loop {
                ptr = ptr.offset((*enc).minBytesPerChar as isize);
                c = toAscii(enc, ptr, end);
                if !(isSpace(c) != 0) {
                    break;
                }
            }
            if c != crate::ascii_h::ASCII_EQUALS {
                *nextTokPtr = ptr;
                return 0 as libc::c_int;
            }
            break;
        } else {
            ptr = ptr.offset((*enc).minBytesPerChar as isize)
        }
    }
    if ptr == *namePtr {
        *nextTokPtr = ptr;
        return 0 as libc::c_int;
    }
    ptr = ptr.offset((*enc).minBytesPerChar as isize);
    c = toAscii(enc, ptr, end);
    while isSpace(c) != 0 {
        ptr = ptr.offset((*enc).minBytesPerChar as isize);
        c = toAscii(enc, ptr, end)
    }
    if c != crate::ascii_h::ASCII_QUOT && c != crate::ascii_h::ASCII_APOS {
        *nextTokPtr = ptr;
        return 0 as libc::c_int;
    }
    open = c as libc::c_char;
    ptr = ptr.offset((*enc).minBytesPerChar as isize);
    *valPtr = ptr;
    loop {
        c = toAscii(enc, ptr, end);
        if c == open as libc::c_int {
            break;
        }
        if !(crate::ascii_h_0::ASCII_a <= c && c <= crate::ascii_h::ASCII_z)
            && !(crate::ascii_h::ASCII_A <= c && c <= crate::ascii_h::ASCII_Z)
            && !(crate::ascii_h_0::ASCII_0 <= c && c <= crate::ascii_h_0::ASCII_9)
            && c != crate::ascii_h::ASCII_PERIOD
            && c != crate::ascii_h::ASCII_MINUS
            && c != crate::ascii_h::ASCII_UNDERSCORE
        {
            *nextTokPtr = ptr;
            return 0 as libc::c_int;
        }
        ptr = ptr.offset((*enc).minBytesPerChar as isize)
    }
    *nextTokPtr = ptr.offset((*enc).minBytesPerChar as isize);
    return 1 as libc::c_int;
}

static mut KW_version: [libc::c_char; 8] = [
    crate::ascii_h::ASCII_v as libc::c_char,
    crate::ascii_h_0::ASCII_e as libc::c_char,
    crate::ascii_h::ASCII_r as libc::c_char,
    crate::ascii_h::ASCII_s as libc::c_char,
    crate::ascii_h::ASCII_i as libc::c_char,
    crate::ascii_h::ASCII_o as libc::c_char,
    crate::ascii_h::ASCII_n as libc::c_char,
    '\u{0}' as i32 as libc::c_char,
];

static mut KW_encoding: [libc::c_char; 9] = [
    crate::ascii_h_0::ASCII_e as libc::c_char,
    crate::ascii_h::ASCII_n as libc::c_char,
    crate::ascii_h_0::ASCII_c as libc::c_char,
    crate::ascii_h::ASCII_o as libc::c_char,
    crate::ascii_h::ASCII_d as libc::c_char,
    crate::ascii_h::ASCII_i as libc::c_char,
    crate::ascii_h::ASCII_n as libc::c_char,
    crate::ascii_h_0::ASCII_g as libc::c_char,
    '\u{0}' as i32 as libc::c_char,
];

static mut KW_standalone: [libc::c_char; 11] = [
    crate::ascii_h::ASCII_s as libc::c_char,
    crate::ascii_h::ASCII_t as libc::c_char,
    crate::ascii_h_0::ASCII_a as libc::c_char,
    crate::ascii_h::ASCII_n as libc::c_char,
    crate::ascii_h::ASCII_d as libc::c_char,
    crate::ascii_h_0::ASCII_a as libc::c_char,
    crate::ascii_h_0::ASCII_l as libc::c_char,
    crate::ascii_h::ASCII_o as libc::c_char,
    crate::ascii_h::ASCII_n as libc::c_char,
    crate::ascii_h_0::ASCII_e as libc::c_char,
    '\u{0}' as i32 as libc::c_char,
];

static mut KW_yes: [libc::c_char; 4] = [
    crate::ascii_h::ASCII_y as libc::c_char,
    crate::ascii_h_0::ASCII_e as libc::c_char,
    crate::ascii_h::ASCII_s as libc::c_char,
    '\u{0}' as i32 as libc::c_char,
];

static mut KW_no: [libc::c_char; 3] = [
    crate::ascii_h::ASCII_n as libc::c_char,
    crate::ascii_h::ASCII_o as libc::c_char,
    '\u{0}' as i32 as libc::c_char,
];

unsafe extern "C" fn doParseXmlDecl(
    mut encodingFinder: Option<
        unsafe extern "C" fn(
            _: *const crate::src::lib::xmltok::ENCODING,
            _: *const libc::c_char,
            _: *const libc::c_char,
        ) -> *const crate::src::lib::xmltok::ENCODING,
    >,
    mut isGeneralTextEntity: libc::c_int,
    mut enc: *const crate::src::lib::xmltok::ENCODING,
    mut ptr: *const libc::c_char,
    mut end: *const libc::c_char,
    mut badPtr: *mut *const libc::c_char,
    mut versionPtr: *mut *const libc::c_char,
    mut versionEndPtr: *mut *const libc::c_char,
    mut encodingName: *mut *const libc::c_char,
    mut encoding: *mut *const crate::src::lib::xmltok::ENCODING,
    mut standalone: *mut libc::c_int,
) -> libc::c_int {
    let mut val: *const libc::c_char = crate::stddef_h::NULL as *const libc::c_char;
    let mut name: *const libc::c_char = crate::stddef_h::NULL as *const libc::c_char;
    let mut nameEnd: *const libc::c_char = crate::stddef_h::NULL as *const libc::c_char;
    ptr = ptr.offset((5 as libc::c_int * (*enc).minBytesPerChar) as isize);
    end = end.offset(-((2 as libc::c_int * (*enc).minBytesPerChar) as isize));
    if parsePseudoAttribute(enc, ptr, end, &mut name, &mut nameEnd, &mut val, &mut ptr) == 0
        || name.is_null()
    {
        *badPtr = ptr;
        return 0 as libc::c_int;
    }
    if (*enc).nameMatchesAscii.expect("non-null function pointer")(
        enc,
        name,
        nameEnd,
        KW_version.as_ptr(),
    ) == 0
    {
        if isGeneralTextEntity == 0 {
            *badPtr = name;
            return 0 as libc::c_int;
        }
    } else {
        if !versionPtr.is_null() {
            *versionPtr = val
        }
        if !versionEndPtr.is_null() {
            *versionEndPtr = ptr
        }
        if parsePseudoAttribute(enc, ptr, end, &mut name, &mut nameEnd, &mut val, &mut ptr) == 0 {
            *badPtr = ptr;
            return 0 as libc::c_int;
        }
        if name.is_null() {
            if isGeneralTextEntity != 0 {
                /* a TextDecl must have an EncodingDecl */
                *badPtr = ptr;
                return 0 as libc::c_int;
            }
            return 1 as libc::c_int;
        }
    }
    if (*enc).nameMatchesAscii.expect("non-null function pointer")(
        enc,
        name,
        nameEnd,
        KW_encoding.as_ptr(),
    ) != 0
    {
        let mut c: libc::c_int = toAscii(enc, val, end);
        if !(crate::ascii_h_0::ASCII_a <= c && c <= crate::ascii_h::ASCII_z)
            && !(crate::ascii_h::ASCII_A <= c && c <= crate::ascii_h::ASCII_Z)
        {
            *badPtr = val;
            return 0 as libc::c_int;
        }
        if !encodingName.is_null() {
            *encodingName = val
        }
        if !encoding.is_null() {
            *encoding = encodingFinder.expect("non-null function pointer")(
                enc,
                val,
                ptr.offset(-((*enc).minBytesPerChar as isize)),
            )
        }
        if parsePseudoAttribute(enc, ptr, end, &mut name, &mut nameEnd, &mut val, &mut ptr) == 0 {
            *badPtr = ptr;
            return 0 as libc::c_int;
        }
        if name.is_null() {
            return 1 as libc::c_int;
        }
    }
    if (*enc).nameMatchesAscii.expect("non-null function pointer")(
        enc,
        name,
        nameEnd,
        KW_standalone.as_ptr(),
    ) == 0
        || isGeneralTextEntity != 0
    {
        *badPtr = name;
        return 0 as libc::c_int;
    }
    if (*enc).nameMatchesAscii.expect("non-null function pointer")(
        enc,
        val,
        ptr.offset(-((*enc).minBytesPerChar as isize)),
        KW_yes.as_ptr(),
    ) != 0
    {
        if !standalone.is_null() {
            *standalone = 1 as libc::c_int
        }
    } else if (*enc).nameMatchesAscii.expect("non-null function pointer")(
        enc,
        val,
        ptr.offset(-((*enc).minBytesPerChar as isize)),
        KW_no.as_ptr(),
    ) != 0
    {
        if !standalone.is_null() {
            *standalone = 0 as libc::c_int
        }
    } else {
        *badPtr = val;
        return 0 as libc::c_int;
    }
    while isSpace(toAscii(enc, ptr, end)) != 0 {
        ptr = ptr.offset((*enc).minBytesPerChar as isize)
    }
    if ptr != end {
        *badPtr = ptr;
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
/* as nothing */
/* isName2 */
/* isName3 */
/* isName4 */
/* isNmstrt2 */
/* isNmstrt3 */
/* isNmstrt4 */
/* isInvalid2 */
/* isInvalid3 */
/* isInvalid4 */

unsafe extern "C" fn checkCharRefNumber(mut result: libc::c_int) -> libc::c_int {
    match result >> 8 as libc::c_int {
        216 | 217 | 218 | 219 | 220 | 221 | 222 | 223 => return -(1 as libc::c_int),
        0 => {
            if latin1_encoding.type_0[result as usize] as libc::c_int
                == crate::xmltok_impl_h::BT_NONXML as libc::c_int
            {
                return -(1 as libc::c_int);
            }
        }
        255 => {
            if result == 0xfffe as libc::c_int || result == 0xffff as libc::c_int {
                return -(1 as libc::c_int);
            }
        }
        _ => {}
    } /* LCOV_EXCL_LINE: this case is always eliminated beforehand */
    return result;
}
#[no_mangle]

pub unsafe extern "C" fn XmlUtf8Encode(
    mut c: libc::c_int,
    mut buf: *mut libc::c_char,
) -> libc::c_int {
    if c < 0 as libc::c_int {
        return 0 as libc::c_int;
    }
    if c < min2 as libc::c_int {
        *buf.offset(0 as libc::c_int as isize) = (c | UTF8_cval1 as libc::c_int) as libc::c_char;
        return 1 as libc::c_int;
    }
    if c < min3 as libc::c_int {
        *buf.offset(0 as libc::c_int as isize) =
            (c >> 6 as libc::c_int | UTF8_cval2 as libc::c_int) as libc::c_char;
        *buf.offset(1 as libc::c_int as isize) =
            (c & 0x3f as libc::c_int | 0x80 as libc::c_int) as libc::c_char;
        return 2 as libc::c_int;
    }
    if c < min4 as libc::c_int {
        *buf.offset(0 as libc::c_int as isize) =
            (c >> 12 as libc::c_int | UTF8_cval3 as libc::c_int) as libc::c_char;
        *buf.offset(1 as libc::c_int as isize) =
            (c >> 6 as libc::c_int & 0x3f as libc::c_int | 0x80 as libc::c_int) as libc::c_char;
        *buf.offset(2 as libc::c_int as isize) =
            (c & 0x3f as libc::c_int | 0x80 as libc::c_int) as libc::c_char;
        return 3 as libc::c_int;
    }
    if c < 0x110000 as libc::c_int {
        *buf.offset(0 as libc::c_int as isize) =
            (c >> 18 as libc::c_int | UTF8_cval4 as libc::c_int) as libc::c_char;
        *buf.offset(1 as libc::c_int as isize) =
            (c >> 12 as libc::c_int & 0x3f as libc::c_int | 0x80 as libc::c_int) as libc::c_char;
        *buf.offset(2 as libc::c_int as isize) =
            (c >> 6 as libc::c_int & 0x3f as libc::c_int | 0x80 as libc::c_int) as libc::c_char;
        *buf.offset(3 as libc::c_int as isize) =
            (c & 0x3f as libc::c_int | 0x80 as libc::c_int) as libc::c_char;
        return 4 as libc::c_int;
    }
    return 0 as libc::c_int;
    /* LCOV_EXCL_LINE: this case too is eliminated before calling */
}
#[no_mangle]

pub unsafe extern "C" fn XmlUtf16Encode(
    mut charNum: libc::c_int,
    mut buf: *mut libc::c_ushort,
) -> libc::c_int {
    if charNum < 0 as libc::c_int {
        return 0 as libc::c_int;
    }
    if charNum < 0x10000 as libc::c_int {
        *buf.offset(0 as libc::c_int as isize) = charNum as libc::c_ushort;
        return 1 as libc::c_int;
    }
    if charNum < 0x110000 as libc::c_int {
        charNum -= 0x10000 as libc::c_int;
        *buf.offset(0 as libc::c_int as isize) =
            ((charNum >> 10 as libc::c_int) + 0xd800 as libc::c_int) as libc::c_ushort;
        *buf.offset(1 as libc::c_int as isize) =
            ((charNum & 0x3ff as libc::c_int) + 0xdc00 as libc::c_int) as libc::c_ushort;
        return 2 as libc::c_int;
    }
    return 0 as libc::c_int;
}
#[no_mangle]

pub unsafe extern "C" fn XmlSizeOfUnknownEncoding() -> libc::c_int {
    return ::std::mem::size_of::<unknown_encoding>() as libc::c_ulong as libc::c_int;
}

unsafe extern "C" fn unknown_isName(
    mut enc: *const crate::src::lib::xmltok::ENCODING,
    mut p: *const libc::c_char,
) -> libc::c_int {
    let mut uenc: *const unknown_encoding = enc as *const unknown_encoding;
    let mut c: libc::c_int =
        (*uenc).convert.expect("non-null function pointer")((*uenc).userData, p);
    if c & !(0xffff as libc::c_int) != 0 {
        return 0 as libc::c_int;
    }
    return (namingBitmap[(((namePages[(c >> 8 as libc::c_int) as usize] as libc::c_int)
        << 3 as libc::c_int)
        + ((c & 0xff as libc::c_int) >> 5 as libc::c_int)) as usize]
        & (1 as libc::c_uint) << (c & 0xff as libc::c_int & 0x1f as libc::c_int))
        as libc::c_int;
}

unsafe extern "C" fn unknown_isNmstrt(
    mut enc: *const crate::src::lib::xmltok::ENCODING,
    mut p: *const libc::c_char,
) -> libc::c_int {
    let mut uenc: *const unknown_encoding = enc as *const unknown_encoding;
    let mut c: libc::c_int =
        (*uenc).convert.expect("non-null function pointer")((*uenc).userData, p);
    if c & !(0xffff as libc::c_int) != 0 {
        return 0 as libc::c_int;
    }
    return (namingBitmap[(((nmstrtPages[(c >> 8 as libc::c_int) as usize] as libc::c_int)
        << 3 as libc::c_int)
        + ((c & 0xff as libc::c_int) >> 5 as libc::c_int)) as usize]
        & (1 as libc::c_uint) << (c & 0xff as libc::c_int & 0x1f as libc::c_int))
        as libc::c_int;
}

unsafe extern "C" fn unknown_isInvalid(
    mut enc: *const crate::src::lib::xmltok::ENCODING,
    mut p: *const libc::c_char,
) -> libc::c_int {
    let mut uenc: *const unknown_encoding = enc as *const unknown_encoding;
    let mut c: libc::c_int =
        (*uenc).convert.expect("non-null function pointer")((*uenc).userData, p);
    return (c & !(0xffff as libc::c_int) != 0 || checkCharRefNumber(c) < 0 as libc::c_int)
        as libc::c_int;
}

unsafe extern "C" fn unknown_toUtf8(
    mut enc: *const crate::src::lib::xmltok::ENCODING,
    mut fromP: *mut *const libc::c_char,
    mut fromLim: *const libc::c_char,
    mut toP: *mut *mut libc::c_char,
    mut toLim: *const libc::c_char,
) -> crate::src::lib::xmltok::XML_Convert_Result {
    let mut uenc: *const unknown_encoding = enc as *const unknown_encoding;
    let mut buf: [libc::c_char; 4] = [0; 4];
    loop {
        let mut utf8: *const libc::c_char = 0 as *const libc::c_char;
        let mut n: libc::c_int = 0;
        if *fromP == fromLim {
            return crate::src::lib::xmltok::XML_CONVERT_COMPLETED;
        }
        utf8 = (*uenc).utf8[**fromP as libc::c_uchar as usize].as_ptr();
        let fresh60 = utf8;
        utf8 = utf8.offset(1);
        n = *fresh60 as libc::c_int;
        if n == 0 as libc::c_int {
            let mut c: libc::c_int =
                (*uenc).convert.expect("non-null function pointer")((*uenc).userData, *fromP);
            n = XmlUtf8Encode(c, buf.as_mut_ptr());
            if n as libc::c_long > toLim.wrapping_offset_from(*toP) as libc::c_long {
                return crate::src::lib::xmltok::XML_CONVERT_OUTPUT_EXHAUSTED;
            }
            utf8 = buf.as_mut_ptr();
            *fromP = (*fromP).offset(
                ((*(enc as *const normal_encoding)).type_0[**fromP as libc::c_uchar as usize]
                    as libc::c_int
                    - (crate::xmltok_impl_h::BT_LEAD2 as libc::c_int - 2 as libc::c_int))
                    as isize,
            )
        } else {
            if n as libc::c_long > toLim.wrapping_offset_from(*toP) as libc::c_long {
                return crate::src::lib::xmltok::XML_CONVERT_OUTPUT_EXHAUSTED;
            }
            *fromP = (*fromP).offset(1)
        }
        crate::stdlib::memcpy(
            *toP as *mut libc::c_void,
            utf8 as *const libc::c_void,
            n as libc::c_ulong,
        );
        *toP = (*toP).offset(n as isize)
    }
}

unsafe extern "C" fn unknown_toUtf16(
    mut enc: *const crate::src::lib::xmltok::ENCODING,
    mut fromP: *mut *const libc::c_char,
    mut fromLim: *const libc::c_char,
    mut toP: *mut *mut libc::c_ushort,
    mut toLim: *const libc::c_ushort,
) -> crate::src::lib::xmltok::XML_Convert_Result {
    let mut uenc: *const unknown_encoding = enc as *const unknown_encoding;
    while *fromP < fromLim && *toP < toLim as *mut libc::c_ushort {
        let mut c: libc::c_ushort = (*uenc).utf16[**fromP as libc::c_uchar as usize];
        if c as libc::c_int == 0 as libc::c_int {
            c = (*uenc).convert.expect("non-null function pointer")((*uenc).userData, *fromP)
                as libc::c_ushort;
            *fromP = (*fromP).offset(
                ((*(enc as *const normal_encoding)).type_0[**fromP as libc::c_uchar as usize]
                    as libc::c_int
                    - (crate::xmltok_impl_h::BT_LEAD2 as libc::c_int - 2 as libc::c_int))
                    as isize,
            )
        } else {
            *fromP = (*fromP).offset(1)
        }
        let fresh61 = *toP;
        *toP = (*toP).offset(1);
        *fresh61 = c
    }
    if *toP == toLim as *mut libc::c_ushort && *fromP < fromLim {
        return crate::src::lib::xmltok::XML_CONVERT_OUTPUT_EXHAUSTED;
    } else {
        return crate::src::lib::xmltok::XML_CONVERT_COMPLETED;
    };
}
#[no_mangle]

pub unsafe extern "C" fn XmlInitUnknownEncoding(
    mut mem: *mut libc::c_void,
    mut table: *mut libc::c_int,
    mut convert: crate::src::lib::xmltok::CONVERTER,
    mut userData: *mut libc::c_void,
) -> *mut crate::src::lib::xmltok::ENCODING {
    let mut i: libc::c_int = 0;
    let mut e: *mut unknown_encoding = mem as *mut unknown_encoding;
    crate::stdlib::memcpy(
        mem,
        &latin1_encoding as *const normal_encoding as *const libc::c_void,
        ::std::mem::size_of::<normal_encoding>() as libc::c_ulong,
    );
    i = 0 as libc::c_int;
    while i < 128 as libc::c_int {
        if latin1_encoding.type_0[i as usize] as libc::c_int
            != crate::xmltok_impl_h::BT_OTHER as libc::c_int
            && latin1_encoding.type_0[i as usize] as libc::c_int
                != crate::xmltok_impl_h::BT_NONXML as libc::c_int
            && *table.offset(i as isize) != i
        {
            return 0 as *mut crate::src::lib::xmltok::ENCODING;
        }
        i += 1
    }
    i = 0 as libc::c_int;
    while i < 256 as libc::c_int {
        let mut c: libc::c_int = *table.offset(i as isize);
        if c == -(1 as libc::c_int) {
            (*e).normal.type_0[i as usize] =
                crate::xmltok_impl_h::BT_MALFORM as libc::c_int as libc::c_uchar;
            /* This shouldn't really get used. */
            (*e).utf16[i as usize] = 0xffff as libc::c_int as libc::c_ushort;
            (*e).utf8[i as usize][0 as libc::c_int as usize] = 1 as libc::c_int as libc::c_char;
            (*e).utf8[i as usize][1 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char
        } else if c < 0 as libc::c_int {
            if c < -(4 as libc::c_int) {
                return 0 as *mut crate::src::lib::xmltok::ENCODING;
            }
            /* Multi-byte sequences need a converter function */
            if convert.is_none() {
                return 0 as *mut crate::src::lib::xmltok::ENCODING;
            }
            (*e).normal.type_0[i as usize] = (crate::xmltok_impl_h::BT_LEAD2 as libc::c_int
                - (c + 2 as libc::c_int))
                as libc::c_uchar;
            (*e).utf8[i as usize][0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
            (*e).utf16[i as usize] = 0 as libc::c_int as libc::c_ushort
        } else if c < 0x80 as libc::c_int {
            if latin1_encoding.type_0[c as usize] as libc::c_int
                != crate::xmltok_impl_h::BT_OTHER as libc::c_int
                && latin1_encoding.type_0[c as usize] as libc::c_int
                    != crate::xmltok_impl_h::BT_NONXML as libc::c_int
                && c != i
            {
                return 0 as *mut crate::src::lib::xmltok::ENCODING;
            }
            (*e).normal.type_0[i as usize] = latin1_encoding.type_0[c as usize];
            (*e).utf8[i as usize][0 as libc::c_int as usize] = 1 as libc::c_int as libc::c_char;
            (*e).utf8[i as usize][1 as libc::c_int as usize] = c as libc::c_char;
            (*e).utf16[i as usize] = if c == 0 as libc::c_int {
                0xffff as libc::c_int
            } else {
                c
            } as libc::c_ushort
        } else if checkCharRefNumber(c) < 0 as libc::c_int {
            (*e).normal.type_0[i as usize] =
                crate::xmltok_impl_h::BT_NONXML as libc::c_int as libc::c_uchar;
            /* This shouldn't really get used. */
            (*e).utf16[i as usize] = 0xffff as libc::c_int as libc::c_ushort;
            (*e).utf8[i as usize][0 as libc::c_int as usize] = 1 as libc::c_int as libc::c_char;
            (*e).utf8[i as usize][1 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char
        } else {
            if c > 0xffff as libc::c_int {
                return 0 as *mut crate::src::lib::xmltok::ENCODING;
            }
            if namingBitmap[(((nmstrtPages[(c >> 8 as libc::c_int) as usize] as libc::c_int)
                << 3 as libc::c_int)
                + ((c & 0xff as libc::c_int) >> 5 as libc::c_int))
                as usize]
                & (1 as libc::c_uint) << (c & 0xff as libc::c_int & 0x1f as libc::c_int)
                != 0
            {
                (*e).normal.type_0[i as usize] =
                    crate::xmltok_impl_h::BT_NMSTRT as libc::c_int as libc::c_uchar
            } else if namingBitmap[(((namePages[(c >> 8 as libc::c_int) as usize] as libc::c_int)
                << 3 as libc::c_int)
                + ((c & 0xff as libc::c_int) >> 5 as libc::c_int))
                as usize]
                & (1 as libc::c_uint) << (c & 0xff as libc::c_int & 0x1f as libc::c_int)
                != 0
            {
                (*e).normal.type_0[i as usize] =
                    crate::xmltok_impl_h::BT_NAME as libc::c_int as libc::c_uchar
            } else {
                (*e).normal.type_0[i as usize] =
                    crate::xmltok_impl_h::BT_OTHER as libc::c_int as libc::c_uchar
            }
            (*e).utf8[i as usize][0 as libc::c_int as usize] = XmlUtf8Encode(
                c,
                (*e).utf8[i as usize]
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize),
            ) as libc::c_char;
            (*e).utf16[i as usize] = c as libc::c_ushort
        }
        i += 1
    }
    (*e).userData = userData;
    (*e).convert = convert;
    if convert.is_some() {
        (*e).normal.isName2 = Some(
            unknown_isName
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        );
        (*e).normal.isName3 = Some(
            unknown_isName
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        );
        (*e).normal.isName4 = Some(
            unknown_isName
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        );
        (*e).normal.isNmstrt2 = Some(
            unknown_isNmstrt
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        );
        (*e).normal.isNmstrt3 = Some(
            unknown_isNmstrt
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        );
        (*e).normal.isNmstrt4 = Some(
            unknown_isNmstrt
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        );
        (*e).normal.isInvalid2 = Some(
            unknown_isInvalid
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        );
        (*e).normal.isInvalid3 = Some(
            unknown_isInvalid
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        );
        (*e).normal.isInvalid4 = Some(
            unknown_isInvalid
                as unsafe extern "C" fn(
                    _: *const crate::src::lib::xmltok::ENCODING,
                    _: *const libc::c_char,
                ) -> libc::c_int,
        )
    }
    (*e).normal.enc.utf8Convert = Some(
        unknown_toUtf8
            as unsafe extern "C" fn(
                _: *const crate::src::lib::xmltok::ENCODING,
                _: *mut *const libc::c_char,
                _: *const libc::c_char,
                _: *mut *mut libc::c_char,
                _: *const libc::c_char,
            ) -> crate::src::lib::xmltok::XML_Convert_Result,
    );
    (*e).normal.enc.utf16Convert = Some(
        unknown_toUtf16
            as unsafe extern "C" fn(
                _: *const crate::src::lib::xmltok::ENCODING,
                _: *mut *const libc::c_char,
                _: *const libc::c_char,
                _: *mut *mut libc::c_ushort,
                _: *const libc::c_ushort,
            ) -> crate::src::lib::xmltok::XML_Convert_Result,
    );
    return &mut (*e).normal.enc;
}

static mut KW_ISO_8859_1: [libc::c_char; 11] = [
    crate::ascii_h::ASCII_I as libc::c_char,
    crate::ascii_h::ASCII_S as libc::c_char,
    crate::ascii_h::ASCII_O as libc::c_char,
    crate::ascii_h::ASCII_MINUS as libc::c_char,
    crate::ascii_h_0::ASCII_8 as libc::c_char,
    crate::ascii_h_0::ASCII_8 as libc::c_char,
    crate::ascii_h::ASCII_5 as libc::c_char,
    crate::ascii_h_0::ASCII_9 as libc::c_char,
    crate::ascii_h::ASCII_MINUS as libc::c_char,
    crate::ascii_h_0::ASCII_1 as libc::c_char,
    '\u{0}' as i32 as libc::c_char,
];

static mut KW_US_ASCII: [libc::c_char; 9] = [
    crate::ascii_h::ASCII_U as libc::c_char,
    crate::ascii_h::ASCII_S as libc::c_char,
    crate::ascii_h::ASCII_MINUS as libc::c_char,
    crate::ascii_h::ASCII_A as libc::c_char,
    crate::ascii_h::ASCII_S as libc::c_char,
    crate::ascii_h::ASCII_C as libc::c_char,
    crate::ascii_h::ASCII_I as libc::c_char,
    crate::ascii_h::ASCII_I as libc::c_char,
    '\u{0}' as i32 as libc::c_char,
];

static mut KW_UTF_8: [libc::c_char; 6] = [
    crate::ascii_h::ASCII_U as libc::c_char,
    crate::ascii_h::ASCII_T as libc::c_char,
    crate::ascii_h_0::ASCII_F as libc::c_char,
    crate::ascii_h::ASCII_MINUS as libc::c_char,
    crate::ascii_h_0::ASCII_8 as libc::c_char,
    '\u{0}' as i32 as libc::c_char,
];

static mut KW_UTF_16: [libc::c_char; 7] = [
    crate::ascii_h::ASCII_U as libc::c_char,
    crate::ascii_h::ASCII_T as libc::c_char,
    crate::ascii_h_0::ASCII_F as libc::c_char,
    crate::ascii_h::ASCII_MINUS as libc::c_char,
    crate::ascii_h_0::ASCII_1 as libc::c_char,
    crate::ascii_h::ASCII_6 as libc::c_char,
    '\u{0}' as i32 as libc::c_char,
];

static mut KW_UTF_16BE: [libc::c_char; 9] = [
    crate::ascii_h::ASCII_U as libc::c_char,
    crate::ascii_h::ASCII_T as libc::c_char,
    crate::ascii_h_0::ASCII_F as libc::c_char,
    crate::ascii_h::ASCII_MINUS as libc::c_char,
    crate::ascii_h_0::ASCII_1 as libc::c_char,
    crate::ascii_h::ASCII_6 as libc::c_char,
    crate::ascii_h_0::ASCII_B as libc::c_char,
    crate::ascii_h_0::ASCII_E as libc::c_char,
    '\u{0}' as i32 as libc::c_char,
];

static mut KW_UTF_16LE: [libc::c_char; 9] = [
    crate::ascii_h::ASCII_U as libc::c_char,
    crate::ascii_h::ASCII_T as libc::c_char,
    crate::ascii_h_0::ASCII_F as libc::c_char,
    crate::ascii_h::ASCII_MINUS as libc::c_char,
    crate::ascii_h_0::ASCII_1 as libc::c_char,
    crate::ascii_h::ASCII_6 as libc::c_char,
    crate::ascii_h_0::ASCII_L as libc::c_char,
    crate::ascii_h_0::ASCII_E as libc::c_char,
    '\u{0}' as i32 as libc::c_char,
];

unsafe extern "C" fn getEncodingIndex(mut name: *const libc::c_char) -> libc::c_int {
    static mut encodingNames: [*const libc::c_char; 6] = unsafe {
        [
            KW_ISO_8859_1.as_ptr(),
            KW_US_ASCII.as_ptr(),
            KW_UTF_8.as_ptr(),
            KW_UTF_16.as_ptr(),
            KW_UTF_16BE.as_ptr(),
            KW_UTF_16LE.as_ptr(),
        ]
    };
    let mut i: libc::c_int = 0;
    if name.is_null() {
        return NO_ENC as libc::c_int;
    }
    i = 0 as libc::c_int;
    while i
        < (::std::mem::size_of::<[*const libc::c_char; 6]>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<*const libc::c_char>() as libc::c_ulong)
            as libc::c_int
    {
        if streqci(name, encodingNames[i as usize]) != 0 {
            return i;
        }
        i += 1
    }
    return UNKNOWN_ENC as libc::c_int;
}
/* For binary compatibility, we store the index of the encoding
   specified at initialization in the isUtf16 member.
*/
/* This is what detects the encoding.  encodingTable maps from
   encoding indices to encodings; INIT_ENC_INDEX(enc) is the index of
   the external (protocol) specified encoding; state is
   XML_CONTENT_STATE if we're parsing an external text entity, and
   XML_PROLOG_STATE otherwise.
*/

unsafe extern "C" fn initScan(
    mut encodingTable: *const *const crate::src::lib::xmltok::ENCODING,
    mut enc: *const crate::src::lib::xmltok::INIT_ENCODING,
    mut state: libc::c_int,
    mut ptr: *const libc::c_char,
    mut end: *const libc::c_char,
    mut nextTokPtr: *mut *const libc::c_char,
) -> libc::c_int {
    let mut encPtr: *mut *const crate::src::lib::xmltok::ENCODING =
        0 as *mut *const crate::src::lib::xmltok::ENCODING;
    if ptr >= end {
        return crate::xmltok_h::XML_TOK_NONE;
    }
    encPtr = (*enc).encPtr;
    if ptr.offset(1 as libc::c_int as isize) == end {
        /* only a single byte available for auto-detection */
        /* FIXME */
        /* so we're parsing an external text entity... */
        /* if UTF-16 was externally specified, then we need at least 2 bytes */
        match (*enc).initEnc.isUtf16 as libc::c_int {
            3 | 5 | 4 => return crate::xmltok_h::XML_TOK_PARTIAL,
            _ => {}
        }
        let mut current_block_5: u64;
        match *ptr as libc::c_uchar as libc::c_int {
            254 | 255 | 239 => {
                /* possibly first byte of UTF-8 BOM */
                if (*enc).initEnc.isUtf16 as libc::c_int == ISO_8859_1_ENC as libc::c_int
                    && state == crate::src::lib::xmltok::XML_CONTENT_STATE
                {
                    current_block_5 = 17965632435239708295;
                } else {
                    current_block_5 = 16867440708908940295;
                }
            }
            0 | 60 => {
                current_block_5 = 16867440708908940295;
            }
            _ => {
                current_block_5 = 17965632435239708295;
            }
        }
        match current_block_5 {
            17965632435239708295 => {}
            _ =>
            /* fall through */
            {
                return crate::xmltok_h::XML_TOK_PARTIAL
            }
        }
    } else {
        let mut current_block_26: u64;
        match (*ptr.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int)
            << 8 as libc::c_int
            | *ptr.offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int
        {
            65279 => {
                if !((*enc).initEnc.isUtf16 as libc::c_int == ISO_8859_1_ENC as libc::c_int
                    && state == crate::src::lib::xmltok::XML_CONTENT_STATE)
                {
                    *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                    *encPtr = *encodingTable.offset(UTF_16BE_ENC as libc::c_int as isize);
                    return crate::xmltok_h::XML_TOK_BOM;
                }
            }
            15360 => {
                /* 00 3C is handled in the default case */
                if !(((*enc).initEnc.isUtf16 as libc::c_int == UTF_16BE_ENC as libc::c_int
                    || (*enc).initEnc.isUtf16 as libc::c_int == UTF_16_ENC as libc::c_int)
                    && state == crate::src::lib::xmltok::XML_CONTENT_STATE)
                {
                    *encPtr = *encodingTable.offset(UTF_16LE_ENC as libc::c_int as isize);
                    return (**encPtr).scanners[state as usize].expect("non-null function pointer")(
                        *encPtr, ptr, end, nextTokPtr,
                    );
                }
            }
            65534 => {
                if !((*enc).initEnc.isUtf16 as libc::c_int == ISO_8859_1_ENC as libc::c_int
                    && state == crate::src::lib::xmltok::XML_CONTENT_STATE)
                {
                    *nextTokPtr = ptr.offset(2 as libc::c_int as isize);
                    *encPtr = *encodingTable.offset(UTF_16LE_ENC as libc::c_int as isize);
                    return crate::xmltok_h::XML_TOK_BOM;
                }
            }
            61371 => {
                /* Maybe a UTF-8 BOM (EF BB BF) */
                /* If there's an explicitly specified (external) encoding
                   of ISO-8859-1 or some flavour of UTF-16
                   and this is an external text entity,
                   don't look for the BOM,
                   because it might be a legal data.
                */
                if state == crate::src::lib::xmltok::XML_CONTENT_STATE {
                    let mut e: libc::c_int = (*enc).initEnc.isUtf16 as libc::c_int;
                    if e == ISO_8859_1_ENC as libc::c_int
                        || e == UTF_16BE_ENC as libc::c_int
                        || e == UTF_16LE_ENC as libc::c_int
                        || e == UTF_16_ENC as libc::c_int
                    {
                        current_block_26 = 10758786907990354186;
                    } else {
                        current_block_26 = 15925075030174552612;
                    }
                } else {
                    current_block_26 = 15925075030174552612;
                }
                match current_block_26 {
                    10758786907990354186 => {}
                    _ => {
                        if ptr.offset(2 as libc::c_int as isize) == end {
                            return crate::xmltok_h::XML_TOK_PARTIAL;
                        }
                        if *ptr.offset(2 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                            == 0xbf as libc::c_int
                        {
                            *nextTokPtr = ptr.offset(3 as libc::c_int as isize);
                            *encPtr = *encodingTable.offset(UTF_8_ENC as libc::c_int as isize);
                            return crate::xmltok_h::XML_TOK_BOM;
                        }
                    }
                }
            }
            _ => {
                if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == '\u{0}' as i32 {
                    /* 0 isn't a legal data character. Furthermore a document
                       entity can only start with ASCII characters.  So the only
                       way this can fail to be big-endian UTF-16 if it it's an
                       external parsed general entity that's labelled as
                       UTF-16LE.
                    */
                    if !(state == crate::src::lib::xmltok::XML_CONTENT_STATE
                        && (*enc).initEnc.isUtf16 as libc::c_int == UTF_16LE_ENC as libc::c_int)
                    {
                        *encPtr = *encodingTable.offset(UTF_16BE_ENC as libc::c_int as isize);
                        return (**encPtr).scanners[state as usize]
                            .expect("non-null function pointer")(
                            *encPtr, ptr, end, nextTokPtr
                        );
                    }
                } else if *ptr.offset(1 as libc::c_int as isize) as libc::c_int == '\u{0}' as i32 {
                    /* We could recover here in the case:
                        - parsing an external entity
                        - second byte is 0
                        - no externally specified encoding
                        - no encoding declaration
                       by assuming UTF-16LE.  But we don't, because this would mean when
                       presented just with a single byte, we couldn't reliably determine
                       whether we needed further bytes.
                    */
                    if !(state == crate::src::lib::xmltok::XML_CONTENT_STATE) {
                        *encPtr = *encodingTable.offset(UTF_16LE_ENC as libc::c_int as isize);
                        return (**encPtr).scanners[state as usize]
                            .expect("non-null function pointer")(
                            *encPtr, ptr, end, nextTokPtr
                        );
                    }
                }
            }
        }
    }
    *encPtr = *encodingTable.offset((*enc).initEnc.isUtf16 as libc::c_int as isize);
    return (**encPtr).scanners[state as usize].expect("non-null function pointer")(
        *encPtr, ptr, end, nextTokPtr,
    );
}
#[no_mangle]

pub unsafe extern "C" fn XmlInitUnknownEncodingNS(
    mut mem: *mut libc::c_void,
    mut table: *mut libc::c_int,
    mut convert: crate::src::lib::xmltok::CONVERTER,
    mut userData: *mut libc::c_void,
) -> *mut crate::src::lib::xmltok::ENCODING {
    let mut enc: *mut crate::src::lib::xmltok::ENCODING =
        XmlInitUnknownEncoding(mem, table, convert, userData);
    if !enc.is_null() {
        (*(enc as *mut normal_encoding)).type_0[crate::ascii_h::ASCII_COLON as usize] =
            crate::xmltok_impl_h::BT_COLON_0 as libc::c_int as libc::c_uchar
    }
    return enc;
}
unsafe extern "C" fn run_static_initializers() {
    encodingsNS = [
        &latin1_encoding_ns.enc,
        &ascii_encoding_ns.enc,
        &utf8_encoding_ns.enc,
        &big2_encoding_ns.enc,
        &big2_encoding_ns.enc,
        &little2_encoding_ns.enc,
        &utf8_encoding_ns.enc,
    ];
    encodings = [
        &latin1_encoding.enc,
        &ascii_encoding.enc,
        &utf8_encoding.enc,
        &big2_encoding.enc,
        &big2_encoding.enc,
        &little2_encoding.enc,
        &utf8_encoding.enc,
    ]
}
#[used]
#[cfg_attr(target_os = "linux", link_section = ".init_array")]
#[cfg_attr(target_os = "windows", link_section = ".CRT$XIB")]
#[cfg_attr(target_os = "macos", link_section = "__DATA,__mod_init_func")]
static INIT_ARRAY: [unsafe extern "C" fn(); 1] = [run_static_initializers];
/* XML_NS */
